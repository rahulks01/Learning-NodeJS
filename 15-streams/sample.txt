In 2001, Kent Beck and 16 other noted software developers, writers, and con
sultants [Bec01a] (referred to as the “Agile Alliance”) signed the “Manifesto for
 Agile Software Development.” It stated:
 We are uncovering better ways of developing software by doing it and helping others
 do it. Through this work we have come to value: 
Individuals and interactions over processes and tools
 Working software over comprehensive documentation
 Customer collaboration over contract negotiation
 Responding to change over following a plan
 That is, while there is value in the items on the right, we value the items on the 
left more.
 QUICK
 LOOK
 What is it? Agile software engi
neering combines a philosophy and
 a set of development guidelines. The
 philosophy encourages customer
 satisfaction and early incremental delivery of
 software; small, highly motivated project teams;
 informal methods; minimal software engineer
ing work products; and overall development
 simplicity. The development guidelines stress
 delivery over analysis and design (although
 these activities are not discouraged), and active
 and continuous communication between devel
opers and customers.
 Who does it? Software engineers and other
 project stakeholders (managers, customers, end
 users) work together on an agile team—a team
 that is self-organizing and in control of its own
 destiny. An agile team fosters communication
 and collaboration among all who serve on it.
 Why is it important? The modern business envi
ronment that spawns computer-based systems
 and software products is fast-paced and ever
changing. Agile software engineering repre
sents a reasonable alternative to conventional
 software engineering for certain classes of soft
ware and certain types of software projects. It
 has been demonstrated to deliver successful sys
tems quickly.
 Whatarethesteps? Agiledevelopmentmightbest
 be termed “software engineering lite.” The basic
 framework activities—communication, planning,
 modeling, construction, and deployment—
 remain. But they morph into a minimal task set
 that pushes the project team toward construction
 and delivery (some would argue that this is
 done at the expense of problem analysis and
 solution design).
 What is the work product? Both the customer
 and the software engineer have the same
 view—the only really important work product
 is an operational “software increment” that is
 delivered to the customer on the appropriate
 commitment date.
 How do I ensure that I’ve done it right? If the
 agile team agrees that the process works, and
 the team produces deliverable software
 increments that satisfy the customer, you’ve
 done it right.
 65
66
 PART ONE THE SOFTWARE PROCESS
 FDD . . . . . . . . . .86
 Industrial XP . . .77
 Lean Software
 Development . . .87
 pair 
programming . . .76
 project 
velocity . . . . . . .74
 refactoring . . . . .75
 Scrum . . . . . . . .82
 stories . . . . . . . .74
 XP process . . . . .73
 uote:
 “Agility: 1,
 everything else: 0.”
 Tom DeMarco
 A manifesto is normally associated with an emerging political movement—one
 that attacks the old guard and suggests revolutionary change (hopefully for the
 better). In some ways, that’s exactly what agile development is all about.
 Although the underlying ideas that guide agile development have been with us for
 many years, it has been less than two decades since these ideas have crystallized
 into a “movement.” In essence, agile1 methods were developed in an effort to over
come perceived and actual weaknesses in conventional software engineering. Agile
 development can provide important benefits, but it is not applicable to all projects,
 all products, all people, and all situations. It is also not antithetical to solid software
 engineering practice and can be applied as an overriding philosophy for all software
 work.
 In the modern economy, it is often difficult or impossible to predict how a
 computer-based system (e.g., a Web-based application) will evolve as time passes.
 Market conditions change rapidly, end-user needs evolve, and new competitive
 threats emerge without warning. In many situations, you won’t be able to define
 requirements fully before the project begins. You must be agile enough to respond to
 a fluid business environment.
 Fluidity implies change, and change is expensive. Particularly if it is uncontrolled
 or poorly managed. One of the most compelling characteristics of the agile approach
 is its ability to reduce the costs of change throughout the software process.
 Does this mean that a recognition of challenges posed by modern realities causes
 you to discard valuable software engineering principles, concepts, methods, and
 tools? Absolutely not! Like all engineering disciplines, software engineering contin
ues to evolve. It can be adapted easily to meet the challenges posed by a demand for
 agility.
 In a thought-provoking book on agile software development, Alistair Cockburn
 [Coc02] argues that the prescriptive process models introduced in Chapter 2 have a
 major failing: they forget the frailties of the people who build computer software. Software
 engineers are not robots. They exhibit great variation in working styles; significant dif
ferences in skill level, creativity, orderliness, consistency, and spontaneity. Some com
municate well in written form, others do not. Cockburn argues that process models
 can “deal with people’s common weaknesses with [either] discipline or tolerance” and
 that most prescriptive process models choose discipline. He states: “Because consis
tency in action is a human weakness, high discipline methodologies are fragile.”
 If process models are to work, they must provide a realistic mechanism for en
couraging the discipline that is necessary, or they must be characterized in a man
ner that shows “tolerance” for the people who do software engineering work.
 Invariably, tolerant practices are easier for software people to adopt and sustain, but
 (as Cockburn admits) they may be less productive. Like most things in life, trade-offs
 must be considered.
 1 Agile methods are sometimes referred to as light methods or lean methods.
67
 CHAPTER 3 AGILE DEVELOPMENT
 3.1 WHAT IS AGILITY?
 Just what is agility in the context of software engineering work? Ivar Jacobson
 [Jac02a] provides a useful discussion:
 Agility has become today’s buzzword when describing a modern software process. Every
one is agile. An agile team is a nimble team able to appropriately respond to changes.
 Change is what software development is very much about. Changes in the software be
ing built, changes to the team members, changes because of new technology, changes of
 all kinds that may have an impact on the product they build or the project that creates the
 product. Support for changes should be built-in everything we do in software, something
 we embrace because it is the heart and soul of software. An agile team recognizes that
 software is developed by individuals working in teams and that the skills of these people,
 their ability to collaborate is at the core for the success of the project.
 Don’t make the
 mistake of assuming
 that agility gives you
 license to hack out
 solutions. A process is
 required and discipline
 is essential.
 In Jacobson’s view, the pervasiveness of change is the primary driver for agility. Soft
ware engineers must be quick on their feet if they are to accommodate the rapid
 changes that Jacobson describes.
 But agility is more than an effective response to change. It also encompasses the
 philosophy espoused in the manifesto noted at the beginning of this chapter. It
 encourages team structures and attitudes that make communication (among team
 members, between technologists and business people, between software engineers
 and their managers) more facile. It emphasizes rapid delivery of operational soft
ware and de-emphasizes the importance of intermediate work products (not always
 a good thing); it adopts the customer as a part of the development team and works
 to eliminate the “us and them” attitude that continues to pervade many software
 projects; it recognizes that planning in an uncertain world has its limits and that a
 project plan must be flexible.
 Agility can be applied to any software process. However, to accomplish this, it is
 essential that the process be designed in a way that allows the project team to adapt
 tasks and to streamline them, conduct planning in a way that understands the fluid
ity of an agile development approach, eliminate all but the most essential work prod
ucts and keep them lean, and emphasize an incremental delivery strategy that gets
 working software to the customer as rapidly as feasible for the product type and
 operational environment.
 3.2 AGILITY AND THE COST OF CHANGE
 The conventional wisdom in software development (supported by decades of expe
rience) is that the cost of change increases nonlinearly as a project progresses
 (Figure 3.1, solid black curve). It is relatively easy to accommodate a change when a
 software team is gathering requirements (early in a project). A usage scenario might
 have to be modified, a list of functions may be extended, or a written specification
 can be edited. The costs of doing this work are minimal, and the time required will
68
 PART ONE THE SOFTWARE PROCESS
 FIGURE 3.1
 Change costs
 as a function
 of time in
 development
 uote:
 Development cost
 Cost of change
 using conventional
 software processes
 Cost of change
 using agile processes
 “Agility is dynamic,
 content specific,
 aggressively
 change embracing,
 and growth
 oriented.”
 Idealized cost of change
 using agile process
 Development schedule progress–Steven
 Goldman et al.
 An agile process
 reduces the cost of
 change because
 software is released in
 increments and change
 can be better
 controlled within an
 increment.
 not adversely affect the outcome of the project. But what if we fast-forward a num
ber of months? The team is in the middle of validation testing (something that occurs
 relatively late in the project), and an important stakeholder is requesting a major
 functional change. The change requires a modification to the architectural design of
 the software, the design and construction of three new components, modifications
 to another five components, the design of new tests, and so on. Costs escalate
 quickly, and the time and cost required to ensure that the change is made without
 unintended side effects is nontrivial.
 Proponents of agility (e.g., [Bec00], [Amb04]) argue that a well-designed agile
 process “flattens” the cost of change curve (Figure 3.1, shaded, solid curve), allowing
 a software team to accommodate changes late in a software project without dramatic
 cost and time impact. You’ve already learned that the agile process encompasses in
cremental delivery. When incremental delivery is coupled with other agile practices
 such as continuous unit testing and pair programming (discussed later in this chap
ter), the cost of making a change is attenuated. Although debate about the degree to
 which the cost curve flattens is ongoing, there is evidence [Coc01a] to suggest that a
 significant reduction in the cost of change can be achieved.
 3.3 WHAT IS ANAGILE PROCESS?
 Any agile software process is characterized in a manner that addresses a number of
 key assumptions [Fow02] about the majority of software projects: 
1. It is difficult to predict in advance which software requirements will persist
 and which will change. It is equally difficult to predict how customer
 priorities will change as the project proceeds.
69
 CHAPTER 3 AGILE DEVELOPMENT
 WebRef
 A comprehensive
 collection of articles on
 the agile process 
can be found at
 www.aanpo.org/
 articles/index.
 Although agile
 processes embrace
 change, it is still
 important to examine
 the reasons for
 change.
 Working software is
 important, but don’t
 forget that it must also
 exhibit a variety of
 quality attributes
 including reliability,
 usability, and 
maintainability.
 2. For many types of software, design and construction are interleaved. That is,
 both activities should be performed in tandem so that design models are
 proven as they are created. It is difficult to predict how much design is
 necessary before construction is used to prove the design.
 3. Analysis, design, construction, and testing are not as predictable (from a
 planning point of view) as we might like.
 Given these three assumptions, an important question arises: How do we create a
 process that can manage unpredictability? The answer, as I have already noted, lies
 in process adaptability (to rapidly changing project and technical conditions). An
 agile process, therefore, must be adaptable.
 But continual adaptation without forward progress accomplishes little. Therefore,
 an agile software process must adapt incrementally. To accomplish incremental adap
tation, an agile team requires customer feedback (so that the appropriate adaptations
 can be made). An effective catalyst for customer feedback is an operational prototype
 or a portion of an operational system. Hence, an incremental development strategy
 should be instituted. Software increments (executable prototypes or portions of an op
erational system) must be delivered in short time periods so that adaptation keeps pace
 with change (unpredictability). This iterative approach enables the customer to evalu
ate the software increment regularly, provide necessary feedback to the software team,
 and influence the process adaptations that are made to accommodate the feedback.
 3.3.1 Agility Principles
 The Agile Alliance (see [Agi03], [Fow01]) defines 12 agility principles for those who
 want to achieve agility: 
1. Our highest priority is to satisfy the customer through early and continuous
 delivery of valuable software.
 2. Welcome changing requirements, even late in development. Agile processes
 harness change for the customer’s competitive advantage.
 3. Deliver working software frequently, from a couple of weeks to a couple of
 months, with a preference to the shorter timescale.
 4. Business people and developers must work together daily throughout the
 project.
 5. Build projects around motivated individuals. Give them the environment and
 support they need, and trust them to get the job done.
 6. The most efficient and effective method of conveying information to and
 within a development team is face-to-face conversation.
 7. Working software is the primary measure of progress.
 8. Agile processes promote sustainable development. The sponsors, developers,
 and users should be able to maintain a constant pace indefinitely.
70
 PART ONE THE SOFTWARE PROCESS
 9. Continuous attention to technical excellence and good design enhances
 agility.
 10. Simplicity—the art of maximizing the amount of work not done—is 
essential.
 11. The best architectures, requirements, and designs emerge from self
organizing teams.
 12. At regular intervals, the team reflects on how to become more effective, then
 tunes and adjusts its behavior accordingly.
 Not every agile process model applies these 12 principles with equal weight, and
 some models choose to ignore (or at least downplay) the importance of one or more
 of the principles. However, the principles define an agile spirit that is maintained in
 each of the process models presented in this chapter.
 3.3.2 The Politics of Agile Development
 You don’t have to
 choose between agility
 and software engi
neering. Rather, define
 a software engineering
 approach that is agile.
 There is considerable debate (sometimes strident) about the benefits and applicabil
ity of agile software development as opposed to more conventional software engi
neering processes. Jim Highsmith [Hig02a] (facetiously) states the extremes when he
 characterizes the feeling of the pro-agility camp (“agilists”). “Traditional methodolo
gists are a bunch of stick-in-the-muds who’d rather produce flawless documentation
 than a working system that meets business needs.” As a counterpoint, he states
 (again, facetiously) the position of the traditional software engineering camp: “Light
weight, er, ‘agile’ methodologists are a bunch of glorified hackers who are going to
 be in for a heck of a surprise when they try to scale up their toys into enterprise-wide
 software.”
 Like all software technology arguments, this methodology debate risks degener
ating into a religious war. If warfare breaks out, rational thought disappears and
 beliefs rather than facts guide decision making.
 No one is against agility. The real question is: What is the best way to achieve it?
 As important, how do you build software that meets customers’ needs today and
 exhibits the quality characteristics that will enable it to be extended and scaled to
 meet customers’ needs over the long term?
 There are no absolute answers to either of these questions. Even within the agile
 school itself, there are many proposed process models (Section 3.4), each with a
 subtly different approach to the agility problem. Within each model there is a set of
 “ideas” (agilists are loath to call them “work tasks”) that represent a significant
 departure from traditional software engineering. And yet, many agile concepts are
 simply adaptations of good software engineering concepts. Bottom line: there is
 much that can be gained by considering the best of both schools and virtually
 nothing to be gained by denigrating either approach.
 If you have further interest, see [Hig01], [Hig02a], and [DeM02] for an entertain
ing summary of other important technical and political issues.
71
 CHAPTER 3 AGILE DEVELOPMENT
 uote:
 “Agile methods
 derive much of
 their agility by
 relying on the
 tacit knowledge
 embodied in the
 team, rather than
 writing the
 knowledge down
 in plans.”
 Barry Boehm
 ?
 What key
 traits must
 exist among the
 people on an
 effective software
 team?
 uote:
 “What counts as
 barely sufficient
 for one team is
 either overly
 sufficient or
 insufficient for
 another.”
 Alistair
 Cockburn
 3.3.3 Human Factors
 Proponents of agile software development take great pains to emphasize the impor
tance of “people factors.” As Cockburn and Highsmith [Coc01a] state, “Agile devel
opment focuses on the talents and skills of individuals, molding the process to
 specific people and teams.” The key point in this statement is that the process molds
 to the needs of the people and team, not the other way around.2
 If members of the software team are to drive the characteristics of the process that
 is applied to build software, a number of key traits must exist among the people on
 an agile team and the team itself:
 Competence. In an agile development (as well as software engineering)
 context, “competence” encompasses innate talent, specific software-related
 skills, and overall knowledge of the process that the team has chosen to
 apply. Skill and knowledge of process can and should be taught to all people
 who serve as agile team members.
 Common focus. Although members of the agile team may perform differ
ent tasks and bring different skills to the project, all should be focused on one
 goal—to deliver a working software increment to the customer within the
 time promised. To achieve this goal, the team will also focus on continual
 adaptations (small and large) that will make the process fit the needs of the
 team.
 Collaboration. Software engineering (regardless of process) is about as
sessing, analyzing, and using information that is communicated to the soft
ware team; creating information that will help all stakeholders understand
 the work of the team; and building information (computer software and rele
vant databases) that provides business value for the customer. To accomplish
 these tasks, team members must collaborate—with one another and all other
 stakeholders.
 Decision-making ability. Any good software team (including agile teams)
 must be allowed the freedom to control its own destiny. This implies that the
 team is given autonomy—decision-making authority for both technical and
 project issues.
 Fuzzy problem-solving ability. Software managers must recognize that
 the agile team will continually have to deal with ambiguity and will continu
ally be buffeted by change. In some cases, the team must accept the fact that
 the problem they are solving today may not be the problem that needs to be
 solved tomorrow. However, lessons learned from any problem-solving
 2 Successful software engineering organizations recognize this reality regardless of the process
 model they choose.
72
 PART ONE THE SOFTWARE PROCESS
 A self-organizing team
 is in control of the
 work it performs. The
 team makes its own
 commitments and
 defines plans to
 achieve them.
 activity (including those that solve the wrong problem) may be of benefit to
 the team later in the project.
 Mutual trust and respect. The agile team must become what DeMarco
 and Lister [DeM98] call a “jelled” team (Chapter 24). A jelled team exhibits
 the trust and respect that are necessary to make them “so strongly knit that
 the whole is greater than the sum of the parts.” [DeM98]
 Self-organization. In the context of agile development, self-organization
 implies three things: (1) the agile team organizes itself for the work to be
 done, (2) the team organizes the process to best accommodate its local envi
ronment, (3) the team organizes the work schedule to best achieve delivery
 of the software increment. Self-organization has a number of technical bene
fits, but more importantly, it serves to improve collaboration and boost team
 morale. In essence, the team serves as its own management. Ken Schwaber
 [Sch02] addresses these issues when he writes: “The team selects how much
 work it believes it can perform within the iteration, and the team commits to
 the work. Nothing demotivates a team as much as someone else making
 commitments for it. Nothing motivates a team as much as accepting the
 responsibility for fulfilling commitments that it made itself.”
 3.4 EXTREME PROGRAMMING (XP)
 In order to illustrate an agile process in a bit more detail, I’ll provide you with an
 overview of Extreme Programming (XP), the most widely used approach to agile soft
ware development. Although early work on the ideas and methods associated with
 XP occurred during the late 1980s, the seminal work on the subject has been written
 by Kent Beck [Bec04a]. More recently, a variant of XP, called Industrial XP (IXP) has
 been proposed [Ker05]. IXP refines XP and targets the agile process specifically for
 use within large organizations.
 3.4.1 XP Values
 Beck [Bec04a] defines a set of five values that establish a foundation for all work per
formed as part of XP—communication, simplicity, feedback, courage, and respect. Each
 of these values is used as a driver for specific XP activities, actions, and tasks.
 In order to achieve effective communication between software engineers and
 other stakeholders (e.g., to establish required features and functions for the soft
ware), XP emphasizes close, yet informal (verbal) collaboration between customers
 and developers, the establishment of effective metaphors3 for communicating
 important concepts, continuous feedback, and the avoidance of voluminous docu
mentation as a communication medium.
 3 In the XP context, a metaphor is “a story that everyone—customers, programmers, and managers—
 can tell about how the system works” [Bec04a].
73
 CHAPTER 3 AGILE DEVELOPMENT
 Keep it simple
 whenever you can, but
 recognize that
 continual “refactoring”
 can absorb significant
 time and resources.
 uote:
 “XP is the answer
 to the question,
 ‘How little can we
 do and still build
 great software?’“
 Anonymous
 WebRef
 An excellent overview
 of “rules” for XP can
 be found at www
 .extremeprogramm
 ing.org/rules.html.
 To achieve simplicity, XP restricts developers to design only for immediate needs,
 rather than consider future needs. The intent is to create a simple design that can be
 easily implemented in code). If the design must be improved, it can be refactored4 at
 a later time.
 Feedback is derived from three sources: the implemented software itself, the
 customer, and other software team members. By designing and implementing an
 effective testing strategy (Chapters 17 through 20), the software (via test results) pro
vides the agile team with feedback. XP makes use of the unit test as its primary test
ing tactic. As each class is developed, the team develops a unit test to exercise each
 operation according to its specified functionality. As an increment is delivered to a
 customer, the user stories or use cases (Chapter 5) that are implemented by the
 increment are used as a basis for acceptance tests. The degree to which the software
 implements the output, function, and behavior of the use case is a form of feedback.
 Finally, as new requirements are derived as part of iterative planning, the team pro
vides the customer with rapid feedback regarding cost and schedule impact.
 Beck [Bec04a] argues that strict adherence to certain XP practices demands
 courage. A better word might be discipline. For example, there is often significant
 pressure to design for future requirements. Most software teams succumb, arguing
 that “designing for tomorrow” will save time and effort in the long run. An agile XP
 team must have the discipline (courage) to design for today, recognizing that future
 requirements may change dramatically, thereby demanding substantial rework of
 the design and implemented code.
 By following each of these values, the agile team inculcates respect among it
 members, between other stakeholders and team members, and indirectly, for the
 software itself. As they achieve successful delivery of software increments, the team
 develops growing respect for the XP process.
 3.4.2 The XP Process
 Extreme Programming uses an object-oriented approach (Appendix 2) as its pre
ferred development paradigm and encompasses a set of rules and practices that
 occur within the context of four framework activities: planning, design, coding, and
 testing. Figure 3.2 illustrates the XP process and notes some of the key ideas and
 tasks that are associated with each framework activity. Key XP activities are sum
marized in the paragraphs that follow.
 Planning. The planning activity (also called the planning game) begins with
 listening—a requirements gathering activity that enables the technical members of
 the XP team to understand the business context for the software and to get a broad
 4 Refactoring allows a software engineer to improve the internal structure of a design (or source
 code) without changing its external functionality or behavior. In essence, refactoring can be used
 to improve the efficiency, readability, or performance of a design or the code that implements a
 design.
74
 PART ONE THE SOFTWARE PROCESS
 FIGURE 3.2
 The Extreme
 Programming
 process
 ?
 What is an
 XP “story”?
 WebRef
 A worthwhile XP
 “planning game” can
 be found at:
 c2.com/cgi/
 wiki?planningGame.
 simple design
 CRC cards
 user stories
 values
 acceptance test criteria
 iteration plan
 Release
 spike solutions
 prototypes
 refactoring
 design
 pair programming
 planning
 software increment
 project velocity computed
 unit test
 continuous integration
 acceptance testing
 test
 coding
 feel for required output and major features and functionality. Listening leads to the
 creation of a set of “stories” (also called user stories) that describe required output,
 features, and functionality for software to be built. Each story (similar to use cases
 described in Chapter 5) is written by the customer and is placed on an index card.
 The customer assigns a value (i.e., a priority) to the story based on the overall busi
ness value of the feature or function.5 Members of the XP team then assess each
 story and assign a cost—measured in development weeks—to it. If the story is esti
mated to require more than three development weeks, the customer is asked to split
 the story into smaller stories and the assignment of value and cost occurs again. It
 is important to note that new stories can be written at any time.
 Customers and developers work together to decide how to group stories into the
 next release (the next software increment) to be developed by the XP team. Once a
 basic commitment (agreement on stories to be included, delivery date, and other
 project matters) is made for a release, the XP team orders the stories that will be de
veloped in one of three ways: (1) all stories will be implemented immediately (within
 a few weeks), (2) the stories with highest value will be moved up in the schedule and
 implemented first, or (3) the riskiest stories will be moved up in the schedule and
 implemented first.
 After the first project release (also called a software increment) has been deliv
ered, the XP team computes project velocity. Stated simply, project velocity is the
 5 The value of a story may also be dependent on the presence of another story.
75
 CHAPTER 3 AGILE DEVELOPMENT
 Project velocity is a
 subtle measure of
 team productivity.
 XP deemphasizes the
 importance of design.
 Not everyone agrees.
 In fact, there are times
 when design should be
 emphasized.
 WebRef
 Refactoring techniques
 and tools can be
 found at:
 www.refactoring
 .com.
 number of customer stories implemented during the first release. Project velocity can
 then be used to (1) help estimate delivery dates and schedule for subsequent releases
 and (2) determine whether an overcommitment has been made for all stories across
 the entire development project. If an overcommitment occurs, the content of releases
 is modified or end delivery dates are changed.
 As development work proceeds, the customer can add stories, change the value
 of an existing story, split stories, or eliminate them. The XP team then reconsiders all
 remaining releases and modifies its plans accordingly.
 Design. XP design rigorously follows the KIS (keep it simple) principle. A simple
 design is always preferred over a more complex representation. In addition, the de
sign provides implementation guidance for a story as it is written—nothing less,
 nothing more. The design of extra functionality (because the developer assumes it
 will be required later) is discouraged.6
 XP encourages the use of CRC cards (Chapter 7) as an effective mechanism for
 thinking about the software in an object-oriented context. CRC (class-responsibility
collaborator) cards identify and organize the object-oriented classes7 that are rele
vant to the current software increment. The XP team conducts the design exercise
 using a process similar to the one described in Chapter 8. The CRC cards are the only
 design work product produced as part of the XP process.
 If a difficult design problem is encountered as part of the design of a story, XP rec
ommends the immediate creation of an operational prototype of that portion of the
 design. Called a spike solution, the design prototype is implemented and evaluated.
 The intent is to lower risk when true implementation starts and to validate the orig
inal estimates for the story containing the design problem.
 In the preceding section, we noted that XP encourages refactoring—a construction
 technique that is also a method for design optimization. Fowler [Fow00] describes
 refactoring in the following manner:
 Refactoring is the process of changing a software system in such a way that it does not
 alter the external behavior of the code yet improves the internal structure. It is a disci
plined way to clean up code [and modify/simplify the internal design] that minimizes the
 chances of introducing bugs. In essence, when you refactor you are improving the design
 of the code after it has been written.
 Because XP design uses virtually no notation and produces few, if any, work prod
ucts other than CRC cards and spike solutions, design is viewed as a transient arti
fact that can and should be continually modified as construction proceeds. The intent
 of refactoring is to control these modifications by suggesting small design changes
 6 These design guidelines should be followed in every software engineering method, although there
 are times when sophisticated design notation and terminology may get in the way of simplicity.
 7 Object-oriented classes are discussed in Appendix 2, in Chapter 8, and throughout Part 2 of this
 book.
76
 PART ONE THE SOFTWARE PROCESS
 Refactoring improves
 the internal structure of
 a design (or source
 code) without
 changing its external
 functionality or
 behavior.
 WebRef
 Useful information on
 XP can be obtained 
at www
 .xprogramming.
 com.
 ?
 What is 
pair
 programming?
 Many software teams
 are populated by indi
vidualists. You’ll have
 to work to change that
 culture if pair program
ming is to work effec
tively.
 ?
 XP?
 How are unit
 tests used in
 that “can radically improve the design” [Fow00]. It should be noted, however, that
 the effort required for refactoring can grow dramatically as the size of an application
 grows.
 A central notion in XP is that design occurs both before and after coding com
mences. Refactoring means that design occurs continuously as the system is con
structed. In fact, the construction activity itself will provide the XP team with
 guidance on how to improve the design.
 Coding. After stories are developed and preliminary design work is done, the team
 does not move to code, but rather develops a series of unit tests that will exercise
 each of the stories that is to be included in the current release (software increment).8
 Once the unit test9 has been created, the developer is better able to focus on what
 must be implemented to pass the test. Nothing extraneous is added (KIS). Once the
 code is complete, it can be unit-tested immediately, thereby providing instantaneous
 feedback to the developers.
 A key concept during the coding activity (and one of the most talked about aspects
 of XP) is pair programming. XP recommends that two people work together at one
 computer workstation to create code for a story. This provides a mechanism for real
time problem solving (two heads are often better than one) and real-time quality as
surance (the code is reviewed as it is created). It also keeps the developers focused
 on the problem at hand. In practice, each person takes on a slightly different role. For
 example, one person might think about the coding details of a particular portion of
 the design while the other ensures that coding standards (a required part of XP) are
 being followed or that the code for the story will satisfy the unit test that has been
 developed to validate the code against the story.
 As pair programmers complete their work, the code they develop is integrated
 with the work of others. In some cases this is performed on a daily basis by an inte
gration team. In other cases, the pair programmers have integration responsibility.
 This “continuous integration” strategy helps to avoid compatibility and interfacing
 problems and provides a “smoke testing” environment (Chapter 17) that helps to
 uncover errors early.
 Testing. I have already noted that the creation of unit tests before coding com
mences is a key element of the XP approach. The unit tests that are created should
 be implemented using a framework that enables them to be automated (hence, they
 can be executed easily and repeatedly). This encourages a regression testing strat
egy (Chapter 17) whenever code is modified (which is often, given the XP refactor
ing philosophy).
 8 This approach is analogous to knowing the exam questions before you begin to study. It makes
 studying much easier by focusing attention only on the questions that will be asked.
 9 Unit testing, discussed in detail in Chapter 17, focuses on an individual software component, exer
cising the component’s interface, data structures, and functionality in an effort to uncover errors
 that are local to the component.
77
 CHAPTER 3 AGILE DEVELOPMENT
 XP acceptance tests
 are derived from user
 stories.
 ?
 What new
 practices are
 appended to XP
 to create IXP?
 uote:
 “Ability is what
 you’re capable of
 doing. Motivation
 determines what
 you do. Attitude
 determines how
 well you do it.”
 Lou Holtz
 As the individual unit tests are organized into a “universal testing suite” [Wel99],
 integration and validation testing of the system can occur on a daily basis. This pro
vides the XP team with a continual indication of progress and also can raise warn
ing flags early if things go awry. Wells [Wel99] states: “Fixing small problems every
 few hours takes less time than fixing huge problems just before the deadline.”
 XP acceptance tests, also called customer tests, are specified by the customer and
 focus on overall system features and functionality that are visible and reviewable by
 the customer. Acceptance tests are derived from user stories that have been imple
mented as part of a software release.
 3.4.3 Industrial XP
 Joshua Kerievsky [Ker05] describes Industrial Extreme Programming (IXP) in the fol
lowing manner: “IXP is an organic evolution of XP. It is imbued with XP’s minimal
ist, customer-centric, test-driven spirit. IXP differs most from the original XP in its
 greater inclusion of management, its expanded role for customers, and its upgraded
 technical practices.” IXP incorporates six new practices that are designed to help
 ensure that an XP project works successfully for significant projects within a large
 organization.
 Readiness assessment. Prior to the initiation of an IXP project, the organ
ization should conduct a readiness assessment. The assessment ascertains
 whether (1) an appropriate development environment exists to support IXP,
 (2) the team will be populated by the proper set of stakeholders, (3) the or
ganization has a distinct quality program and supports continuous improve
ment, (4) the organizational culture will support the new values of an agile
 team, and (5) the broader project community will be populated appropriately.
 Project community. Classic XP suggests that the right people be used to
 populate the agile team to ensure success. The implication is that people on
 the team must be well-trained, adaptable and skilled, and have the proper
 temperament to contribute to a self-organizing team. When XP is to be
 applied for a significant project in a large organization, the concept of the
 “team” should morph into that of a community. A community may have a
 technologist and customers who are central to the success of a project as
 well as many other stakeholders (e.g., legal staff, quality auditors, manufac
turing or sales types) who “are often at the periphery of an IXP project yet
 they may play important roles on the project” [Ker05]. In IXP, the community
 members and their roles should be explicitly defined and mechanisms for
 communication and coordination between community members should be
 established.
 Project chartering. The IXP team assesses the project itself to determine
 whether an appropriate business justification for the project exists and
 whether the project will further the overall goals and objectives of the
78
 PART ONE THE SOFTWARE PROCESS
 organization. Chartering also examines the context of the project to deter
mine how it complements, extends, or replaces existing systems or
 processes.
 Test-driven management. An IXP project requires measurable criteria for
 assessing the state of the project and the progress that has been made to
 date. Test-driven management establishes a series of measurable “destina
tions” [Ker05] and then defines mechanisms for determining whether or not
 these destinations have been reached.
 Retrospectives. An IXP team conducts a specialized technical review
 (Chapter 15) after a software increment is delivered. Called a retrospective,
 the review examines “issues, events, and lessons-learned” [Ker05] across a
 software increment and/or the entire software release. The intent is to
 improve the IXP process.
 Continuous learning. Because learning is a vital part of continuous
 process improvement, members of the XP team are encouraged (and possi
bly, incented) to learn new methods and techniques that can lead to a higher
quality product.
 In addition to the six new practices discussed, IXP modifies a number of existing
 XP practices. Story-driven development (SDD) insists that stories for acceptance tests
 be written before a single line of code is generated. Domain-driven design (DDD) is
 an improvement on the “system metaphor” concept used in XP. DDD [Eva03] sug
gests the evolutionary creation of a domain model that “accurately represents how
 domain experts think about their subject” [Ker05]. Pairing extends the XP pair
programming concept to include managers and other stakeholders. The intent is to
 improve knowledge sharing among XP team members who may not be directly in
volved in technical development. Iterative usability discourages front-loaded inter
face design in favor of usability design that evolves as software increments are
 delivered and users’ interaction with the software is studied.
 IXP makes smaller modifications to other XP practices and redefines certain roles
 and responsibilities to make them more amenable to significant projects for large
 organizations. For further discussion of IXP, visit http://industrialxp.org.
 3.4.4 The XP Debate
 All new process models and methods spur worthwhile discussion and in some in
stances heated debate. Extreme Programming has done both. In an interesting book
 that examines the efficacy of XP, Stephens and Rosenberg [Ste03] argue that many
 XP practices are worthwhile, but others have been overhyped, and a few are prob
lematic. The authors suggest that the codependent nature of XP practices are both
 its strength and its weakness. Because many organizations adopt only a subset of XP
 practices, they weaken the efficacy of the entire process. Proponents counter that
 XP is continuously evolving and that many of the issues raised by critics have been
79
 CHAPTER 3 AGILE DEVELOPMENT
 addressed as XP practice matures. Among the issues that continue to trouble some
 critics of XP are:10
 ?
 What are
 some of the
 issues that lead to
 an XP debate?
 • Requirements volatility. Because the customer is an active member of the XP
 team, changes to requirements are requested informally. As a consequence,
 the scope of the project can change and earlier work may have to be
 modified to accommodate current needs. Proponents argue that this happens
 regardless of the process that is applied and that XP provides mechanisms for
 controlling scope creep.
 • Conflicting customer needs. Many projects have multiple customers, each with
 his own set of needs. In XP, the team itself is tasked with assimilating the
 needs of different customers, a job that may be beyond their scope of
 authority.
 • Requirements are expressed informally. User stories and acceptance tests are
 the only explicit manifestation of requirements in XP. Critics argue that a
 more formal model or specification is often needed to ensure that omissions,
 inconsistencies, and errors are uncovered before the system is built. Propo
nents counter that the changing nature of requirements makes such models
 and specification obsolete almost as soon as they are developed.
 • Lack of formal design. XP deemphasizes the need for architectural design and
 in many instances, suggests that design of all kinds should be relatively
 informal. Critics argue that when complex systems are built, design must be
 emphasized to ensure that the overall structure of the software will exhibit
 quality and maintainability. XP proponents suggest that the incremental
 nature of the XP process limits complexity (simplicity is a core value) and
 therefore reduces the need for extensive design.
 You should note that every software process has flaws and that many software or
ganizations have used XP successfully. The key is to recognize where a process may
 have weaknesses and to adapt it to the specific needs of your organization.
 SAFEHOME
 Considering Agile Software Development
 The scene: Doug Miller’s office.
 The Players: Doug Miller, software engineering
 manager; Jamie Lazar, software team member; Vinod
 Raman, software team member.
 The conversation:
 (A knock on the door, Jamie and Vinod enter Doug’s office)
 Jamie: Doug, you got a minute?
 10 For a detailed look at some thoughtful criticism that has been leveled at XP, visit
 www.softwarereality.com/ExtremeProgramming.jsp.
3.5 OTHERAGILEPROCESSMODELS
 The history of software engineering is littered with dozens of obsolete process
 descriptions and methodologies, modeling methods and notations, tools, and
 technology. Each flared in notoriety and was then eclipsed by something new and
 (purportedly) better. With the introduction of a wide array of agile process models—
 each contending for acceptance within the software development community—the
 agile movement is following the same historical path.11
 As I noted in the last section, the most widely used of all agile process models
 isExtreme Programming (XP). But many other agile process models have been
 proposed and are in use across the industry. Among the most common are:
 •Adaptive Software Development (ASD)
 •Scrum
 •Dynamic Systems Development Method (DSDM)
 80 PART ONE THE SOFTWARE PROCESS
 Doug: Sure Jamie, what’s up?
 Jamie:We’ve been thinking about our process
 discussion yesterday . . . you know, what process we’re
 going to choose for this new SafeHomeproject.
 Doug:And?
 Vinod: I was talking to a friend at another company,
 and he was telling me about Extreme Programming. It’s
 an agile process model . . . heard of it?
 Doug: Yeah, some good, some bad.
 Jamie:Well, it sounds pretty good to us. Lets you
 develop software really fast, uses something called pair
 programming to do real-time quality checks . . . it’s pretty
 cool, I think.
 Doug: It does have a lot of really good ideas. I like the
 pair-programming concept, for instance, and the idea
 that stakeholders should be part of the team.
 Jamie:Huh? You mean that marketing will work on the
 project team with us?
 Doug (nodding): They’re a stakeholder, aren’t they?
 Jamie: Jeez . . . they’ll be requesting changes every five
 minutes.
 Vinod:Not necessarily. My friend said that there are
 ways to “embrace” changes during an XP project.
 Doug: So you guys think we should use XP?
 Jamie: It’s definitely worth considering.
 Doug: I agree. And even if we choose an incremental
 model as our approach, there’s no reason why we can’t
 incorporate much of what XP has to offer.
 Vinod:Doug, before you said “some good, some bad.”
 What was the “bad”?
 Doug: The thing I don’t like is the way XP downplays
 analysis and design . . . sort of says that writing code is
 where the action is . . . 
(The team members look at one another and smile.)
 Doug: So you agree with the XP approach?
 Jamie (speaking for both):Writing code is what
 we do, Boss!
 Doug (laughing): True, but I’d like to see you spend a
 little less time coding and then recoding and a little more
 time analyzing what has to be done and designing a
 solution that works.
 Vinod:Maybe we can have it both ways, agility with a
 little discipline.
 Doug: I think we can, Vinod. In fact, I’m sure of it.
 uote:
 “Our profession
 goes through
 methodologies like
 a 14-year-old goes
 through clothing.”
 Stephen
 Hawrysh and
 JimRuprecht
 11This is not a bad thing. Before one or more models or methods are accepted as a de facto standard,
 all must contend for the hearts and minds of software engineers. The “winners” evolve into best
 practice, while the “losers” either disappear or merge with the winning models.
81
 CHAPTER 3 AGILE DEVELOPMENT
 • Crystal
 • Feature Drive Development (FDD)
 • Lean Software Development (LSD)
 • Agile Modeling (AM)
 • Agile Unified Process (AUP)
 In the sections that follow, I present a very brief overview of each of these agile
 process models. It is important to note that all agile process models conform (to a
 greater or lesser degree) to the Manifesto for Agile Software Development and the prin
ciples noted in Section 3.3.1. For additional detail, refer to the references noted in
 each subsection or for a survey, examine the “agile software development” entry
 in Wikipedia.12
 3.5.1 Adaptive Software Development (ASD)
 WebRef
 Useful resources for
 ASD can be found at
 www.adaptivesd
 .com.
 Adaptive Software Development (ASD) has been proposed by Jim Highsmith [Hig00] as
 a technique for building complex software and systems. The philosophical under
pinnings of ASD focus on human collaboration and team self-organization.
 Highsmith argues that an agile, adaptive development approach based on collab
oration is “as much a source of order in our complex interactions as discipline and
 engineering.” He defines an ASD “life cycle” (Figure 3.3) that incorporates three
 phases, speculation, collaboration, and learning.
 FIGURE 3.3
 Adaptive
 software
 development
 adaptive cycle planning
 mission statement
 project constraints
 basic requirements
 time-boxed release plan
 Release
 Requirements gathering
 JAD
 mini-specs
 speculation
 software increment
 adjustments for subsequent cycles
 collaboration
 components implemented/tested
 focus groups for feedback
 formal technical reviews
 learning
 postmortems
 12 See http://en.wikipedia.org/wiki/Agile_software_development#Agile_methods.
82
 PART ONE THE SOFTWARE PROCESS
 Effective collaboration
 with your customer will
 only occur if you
 jettison any “us and
 them” attitudes.
 ASD emphasizes
 learning as a key
 element in achieving 
a “self-organizing”
 team.
 WebRef
 Useful Scrum
 information and
 resources can be found
 at www
 .controlchaos.com.
 During speculation, the project is initiated and adaptive cycle planning is con
ducted. Adaptive cycle planning uses project initiation information—the customer’s
 mission statement, project constraints (e.g., delivery dates or user descriptions), and
 basic requirements—to define the set of release cycles (software increments) that
 will be required for the project.
 No matter how complete and farsighted the cycle plan, it will invariably change.
 Based on information obtained at the completion of the first cycle, the plan is re
viewed and adjusted so that planned work better fits the reality in which an ASD
 team is working.
 Motivated people use collaboration in a way that multiplies their talent and cre
ative output beyond their absolute numbers. This approach is a recurring theme in
 all agile methods. But collaboration is not easy. It encompasses communication and
 teamwork, but it also emphasizes individualism, because individual creativity plays
 an important role in collaborative thinking. It is, above all, a matter of trust. People
 working together must trust one another to (1) criticize without animosity, (2) assist
 without resentment, (3) work as hard as or harder than they do, (4) have the skill set
 to contribute to the work at hand, and (5) communicate problems or concerns in a
 way that leads to effective action.
 As members of an ASD team begin to develop the components that are part of an
 adaptive cycle, the emphasis is on “learning” as much as it is on progress toward
 a completed cycle. In fact, Highsmith [Hig00] argues that software developers often
 overestimate their own understanding (of the technology, the process, and the proj
ect) and that learning will help them to improve their level of real understanding.
 ASD teams learn in three ways: focus groups (Chapter 5), technical reviews (Chap
ter 14), and project postmortems.
 The ASD philosophy has merit regardless of the process model that is used. ASD’s
 overall emphasis on the dynamics of self-organizing teams, interpersonal collabo
ration, and individual and team learning yield software project teams that have a
 much higher likelihood of success.
 3.5.2 Scrum
 Scrum (the name is derived from an activity that occurs during a rugby match13) is
 an agile software development method that was conceived by Jeff Sutherland and his
 development team in the early 1990s. In recent years, further development on the
 Scrum methods has been performed by Schwaber and Beedle [Sch01a].
 Scrum principles are consistent with the agile manifesto and are used to guide
 development activities within a process that incorporates the following framework
 activities: requirements, analysis, design, evolution, and delivery. Within each
 13 A group of players forms around the ball and the teammates work together (sometimes violently!)
 to move the ball downfield.
every 24
 hours
 30 days
 Scrum: 15 minute daily meeting.
 Team members respond to basics:
 1) What did you do since last Scrum
 meeting?
 2) Do you have any obstacles?
 3) What will you do before next
 meeting?
 Sprint Backlog:
 Feature(s)
 assigned
 to sprint
 Product Backlog:
 Prioritized product features desired by the customer
 Backlog
 items
 expanded
 by team
 New functionality
 is demonstrated
 at end of sprint
 framework activity, work tasks occur within a process pattern (discussed in the fol
lowing paragraph) called a sprint.The work conducted within a sprint (the number
 of sprints required for each framework activity will vary depending on product com
plexity and size) is adapted to the problem at hand and is defined and often modified
 in real time by the Scrum team. The overall flow of the Scrum process is illustrated
 in Figure 3.4.
 Scrum emphasizes the use of a set of software process patterns [Noy02] that have
 proven effective for projects with tight timelines, changing requirements, and business
 criticality. Each of these process patterns defines a set of development actions:
 Backlog—a prioritized list of project requirements or features that provide busi
ness value for the customer. Items can be added to the backlog at any time (this is
 how changes are introduced). The product manager assesses the backlog and
 updates priorities as required.
 Sprints—consist of work units that are required to achieve a requirement de
fined in the backlog that must be fit into a predefined time-box14(typically 30 days).
 CHAPTER 3 AGILE DEVELOPMENT 83
 14A time-boxis a project management term (see Part 4 of this book) that indicates a period of time
 that has been allocated to accomplish some task.
 FIGURE3.4
 Scrum process
 flow
 Scrum incorporates a
 set of process patterns
 that emphasize project
 priorities,
 compartmentalized
 work units,
 communication, and
 frequent customer
 feedback.
84
 PART ONE THE SOFTWARE PROCESS
 Changes (e.g., backlog work items) are not introduced during the sprint. Hence, the
 sprint allows team members to work in a short-term, but stable environment.
 Scrum meetings—are short (typically 15 minutes) meetings held daily by the Scrum
 team. Three key questions are asked and answered by all team members [Noy02]:
 • What did you do since the last team meeting?
 • What obstacles are you encountering?
 • What do you plan to accomplish by the next team meeting?
 A team leader, called a Scrum master, leads the meeting and assesses the responses
 from each person. The Scrum meeting helps the team to uncover potential problems
 as early as possible. Also, these daily meetings lead to “knowledge socialization”
 [Bee99] and thereby promote a self-organizing team structure.
 Demos—deliver the software increment to the customer so that functionality that
 has been implemented can be demonstrated and evaluated by the customer. It is im
portant to note that the demo may not contain all planned functionality, but rather
 those functions that can be delivered within the time-box that was established.
 Beedle and his colleagues [Bee99] present a comprehensive discussion of these pat
terns in which they state: “Scrum assumes up-front the existence of chaos. . . . ” The
 Scrum process patterns enable a software team to work successfully in a world
 where the elimination of uncertainty is impossible.
 3.5.3 Dynamic Systems Development Method (DSDM)
 WebRef
 Useful resources for
 DSSD can be found at
 www.dsdm.org.
 The Dynamic Systems Development Method (DSDM) [Sta97] is an agile software devel
opment approach that “provides a framework for building and maintaining systems
 which meet tight time constraints through the use of incremental prototyping in a con
trolled project environment” [CCS02]. The DSDM philosophy is borrowed from a mod
ified version of the Pareto principle—80 percent of an application can be delivered in
 20 percent of the time it would take to deliver the complete (100 percent) application.
 DSDM is an iterative software process in which each iteration follows the 80 per
cent rule. That is, only enough work is required for each increment to facilitate
 movement to the next increment. The remaining detail can be completed later when
 more business requirements are known or changes have been requested and
 accommodated.
 The DSDM Consortium (www.dsdm.org) is a worldwide group of member com
panies that collectively take on the role of “keeper” of the method. The consortium
 has defined an agile process model, called the DSDM life cycle that defines three dif
ferent iterative cycles, preceded by two additional life cycle activities:
 Feasibility study—establishes the basic business requirements and constraints
 associated with the application to be built and then assesses whether the applica
tion is a viable candidate for the DSDM process.
85
 CHAPTER 3 AGILE DEVELOPMENT
 DSDM is a process
 framework that can
 adopt the tactics of
 another agile approach
 such as XP.
 Crystal is a family of
 process models with
 the same “genetic
 code” but different
 methods for adapting
 to project
 characteristics.
 Business study—establishes the functional and information requirements that
 will allow the application to provide business value; also, defines the basic
 application architecture and identifies the maintainability requirements for the
 application.
 Functional model iteration—produces a set of incremental prototypes that
 demonstrate functionality for the customer. (Note: All DSDM prototypes are in
tended to evolve into the deliverable application.) The intent during this iterative
 cycle is to gather additional requirements by eliciting feedback from users as they
 exercise the prototype.
 Design and build iteration—revisits prototypes built during functional model
 iteration to ensure that each has been engineered in a manner that will enable it to
 provide operational business value for end users. In some cases, functional model
 iteration and design and build iteration occur concurrently.
 Implementation—places the latest software increment (an “operationalized” pro
totype) into the operational environment. It should be noted that (1) the increment
 may not be 100 percent complete or (2) changes may be requested as the incre
ment is put into place. In either case, DSDM development work continues by
 returning to the functional model iteration activity.
 DSDM can be combined with XP (Section 3.4) to provide a combination approach
 that defines a solid process model (the DSDM life cycle) with the nuts and bolts prac
tices (XP) that are required to build software increments. In addition, the ASD con
cepts of collaboration and self-organizing teams can be adapted to a combined
 process model.
 3.5.4 Crystal
 Alistair Cockburn [Coc05] and Jim Highsmith [Hig02b] created the Crystal family of
 agile methods15 in order to achieve a software development approach that puts a
 premium on “maneuverability” during what Cockburn characterizes as “a resource
limited, cooperative game of invention and communication, with a primary goal of
 delivering useful, working software and a secondary goal of setting up for the next
 game” [Coc02].
 To achieve maneuverability, Cockburn and Highsmith have defined a set of
 methodologies, each with core elements that are common to all, and roles, process
 patterns, work products, and practice that are unique to each. The Crystal family is
 actually a set of example agile processes that have been proven effective for differ
ent types of projects. The intent is to allow agile teams to select the member of the
 crystal family that is most appropriate for their project and environment.
 15 The name “crystal” is derived from the characteristics of geological crystals, each with its own
 color, shape, and hardness.
86
 PART ONE THE SOFTWARE PROCESS
 3.5.5 Feature Driven Development (FDD)
 WebRef
 A wide variety of
 articles and
 presentations on FDD
 can be found at:
 www.featuredrive
 ndevelopment
 .com/.
 Feature Driven Development (FDD) was originally conceived by Peter Coad and his
 colleagues [Coa99] as a practical process model for object-oriented software engi
neering. Stephen Palmer and John Felsing [Pal02] have extended and improved
 Coad’s work, describing an adaptive, agile process that can be applied to moderately
 sized and larger software projects.
 Like other agile approaches, FDD adopts a philosophy that (1) emphasizes col
laboration among people on an FDD team; (2) manages problem and project
 complexity using feature-based decomposition followed by the integration of
 software increments, and (3) communication of technical detail using verbal,
 graphical, and text-based means. FDD emphasizes software quality assurance
 activities by encouraging an incremental development strategy, the use of design
 and code inspections, the application of software quality assurance audits (Chap
ter 16), the collection of metrics, and the use of patterns (for analysis, design, and
 construction).
 In the context of FDD, a feature “is a client-valued function that can be imple
mented in two weeks or less” [Coa99]. The emphasis on the definition of features
 provides the following benefits:
 • Because features are small blocks of deliverable functionality, users can
 describe them more easily; understand how they relate to one another more
 readily; and better review them for ambiguity, error, or omissions.
 • Features can be organized into a hierarchical business-related grouping.
 • Since a feature is the FDD deliverable software increment, the team develops
 operational features every two weeks.
 • Because features are small, their design and code representations are easier
 to inspect effectively.
 • Project planning, scheduling, and tracking are driven by the feature
 hierarchy, rather than an arbitrarily adopted software engineering 
task set.
 Coad and his colleagues [Coa99] suggest the following template for defining a
 feature:
 <action> the <result> <by for of to> a(n) <object>
 where an <object> is “a person, place, or thing (including roles, moments in time or
 intervals of time, or catalog-entry-like descriptions).” Examples of features for an 
e-commerce application might be:
 Add the product to shopping cart
 Display the technical-specifications of the product
 Store the shipping-information for the customer
87
 CHAPTER 3 AGILE DEVELOPMENT
 FIGURE 3.5
 Feature Driven
 Development
 [Coa99] (with
 permission)
 Develop
 an
 Overall
 Model
 Build a
 Features
 List
 Plan
 By
 Feature
 Design
 By
 Feature
 (more shape
 than content)
 A list of features
 grouped into sets
 and subject areas
 A development plan
 Class owners
 Feature Set Owners
 A design
 package
 (sequences)
 Build
 By
 Feature
 Completed
 client-value
 function
 A feature set groups related features into business-related categories and is defined
 [Coa99] as:
 <action><-ing> a(n) <object>
 For example: Making a product sale is a feature set that would encompass the fea
tures noted earlier and others.
 The FDD approach defines five “collaborating” [Coa99] framework activities (in
 FDD these are called “processes”) as shown in Figure 3.5.
 FDD provides greater emphasis on project management guidelines and tech
niques than many other agile methods. As projects grow in size and complexity,
 ad hoc project management is often inadequate. It is essential for developers, their
 managers, and other stakeholders to understand project status—what accomplish
ments have been made and problems have been encountered. If deadline pressure
 is significant, it is critical to determine if software increments (features) are properly
 scheduled. To accomplish this, FDD defines six milestones during the design and
 implementation of a feature: “design walkthrough, design, design inspection, code,
 code inspection, promote to build” [Coa99].
 3.5.6 Lean Software Development (LSD)
 Lean Software Development (LSD) has adapted the principles of lean manufacturing
 to the world of software engineering. The lean principles that inspire the LSD process
 can be summarized ([Pop03], [Pop06a]) as eliminate waste, build quality in, create
 knowledge, defer commitment, deliver fast, respect people, and optimize the whole.
 Each of these principles can be adapted to the software process. For example,
 eliminate waste within the context of an agile software project can be interpreted
 to mean [Das05]: (1) adding no extraneous features or functions, (2) assessing the
 cost and schedule impact of any newly requested requirement, (3) removing any
 superfluous process steps, (4) establishing mechanisms to improve the way team
 members find information, (5) ensuring the testing finds as many errors as possible,
88
 PART ONE THE SOFTWARE PROCESS
 (6) reducing the time required to request and get a decision that affects the software
 or the process that is applied to create it, and (7) streamlining the manner in which
 information is transmitted to all stakeholders involved in the process.
 For a detailed discussion of LSD and pragmatic guidelines for implementing the
 process, you should examine [Pop06a] and [Pop06b].
 3.5.7 Agile Modeling (AM)
 WebRef
 Comprehensive
 information on agile
 modeling can be found
 at: www
 .agilemodeling.com.
 uote:
 “I was in the drug
 store the other day
 trying to get a cold
 medication . . . not
 easy. There’s an
 entire wall of
 products you need.
 You stand there
 going, Well, this
 one is quick acting
 but this is long
 lasting. . . . Which
 is more important,
 the present or the
 future?”
 Jerry Seinfeld
 There are many situations in which software engineers must build large, business
critical systems. The scope and complexity of such systems must be modeled so that
 (1) all constituencies can better understand what needs to be accomplished, (2) the
 problem can be partitioned effectively among the people who must solve it, and
 (3) quality can be assessed as the system is being engineered and built.
 Over the past 30 years, a wide variety of software engineering modeling methods
 and notation have been proposed for analysis and design (both architectural and
 component-level). These methods have merit, but they have proven to be difficult
 to apply and challenging to sustain (over many projects). Part of the problem is the
 “weight” of these modeling methods. By this I mean the volume of notation required,
 the degree of formalism suggested, the sheer size of the models for large projects,
 and the difficulty in maintaining the model(s) as changes occur. Yet analysis and de
sign modeling have substantial benefit for large projects—if for no other reason than
 to make these projects intellectually manageable. Is there an agile approach to soft
ware engineering modeling that might provide an alternative?
 At “The Official Agile Modeling Site,” Scott Ambler [Amb02a] describes agile mod
eling (AM) in the following manner:
 Agile Modeling (AM) is a practice-based methodology for effective modeling and documen
tation of software-based systems. Simply put, Agile Modeling (AM) is a collection of values,
 principles, and practices for modeling software that can be applied on a software develop
ment project in an effective and light-weight manner. Agile models are more effective than
 traditional models because they are just barely good, they don’t have to be perfect.
 Agile modeling adopts all of the values that are consistent with the agile manifesto.
 The agile modeling philosophy recognizes that an agile team must have the courage
 to make decisions that may cause it to reject a design and refactor. The team must
 also have the humility to recognize that technologists do not have all the answers and
 that business experts and other stakeholders should be respected and embraced.
 Although AM suggests a wide array of “core” and “supplementary” modeling prin
ciples, those that make AM unique are [Amb02a]:
 Model with a purpose. A developer who uses AM should have a specific
 goal (e.g., to communicate information to the customer or to help better un
derstand some aspect of the software) in mind before creating the model.
 Once the goal for the model is identified, the type of notation to be used and
 level of detail required will be more obvious.
89
 CHAPTER 3 AGILE DEVELOPMENT
 Use multiple models. There are many different models and notations that
 can be used to describe software. Only a small subset is essential for most
 projects. AM suggests that to provide needed insight, each model should
 present a different aspect of the system and only those models that provide
 value to their intended audience should be used.
 “Traveling light” is an
 appropriate philosophy
 for all software engi
neering work. Build
 only those models that
 provide value … no
 more, no less.
 Travel light. As software engineering work proceeds, keep only those mod
els that will provide long-term value and jettison the rest. Every work product
 that is kept must be maintained as changes occur. This represents work that
 slows the team down. Ambler [Amb02a] notes that “Every time you decide to
 keep a model you trade-off agility for the convenience of having that informa
tion available to your team in an abstract manner (hence potentially enhanc
ing communication within your team as well as with project stakeholders).”
 Content is more important than representation. Modeling should im
part information to its intended audience. A syntactically perfect model that
 imparts little useful content is not as valuable as a model with flawed nota
tion that nevertheless provides valuable content for its audience.
 Know the models and the tools you use to create them. Understand
 the strengths and weaknesses of each model and the tools that are used to
 create it.
 Adapt locally. The modeling approach should be adapted to the needs of
 the agile team.
 A major segment of the software engineering community has adopted the Unified
 Modeling Language (UML)16 as the preferred method for representing analysis and
 design models. The Unified Process (Chapter 2) has been developed to provide a
 framework for the application of UML. Scott Ambler [Amb06] has developed a sim
plified version of the UP that integrates his agile modeling philosophy.
 3.5.8 Agile Unified Process (AUP)
 The Agile Unified Process (AUP) adopts a “serial in the large” and “iterative in the
 small” [Amb06] philosophy for building computer-based systems. By adopting the
 classic UP phased activities—inception, elaboration, construction, and transition—AUP
 provides a serial overlay (i.e., a linear sequence of software engineering activities)
 that enables a team to visualize the overall process flow for a software project. How
ever, within each of the activities, the team iterates to achieve agility and to deliver
 meaningful software increments to end users as rapidly as possible. Each AUP iter
ation addresses the following activities [Amb06]: 
• Modeling. UML representations of the business and problem domains are
 created. However, to stay agile, these models should be “just barely good
 enough” [Amb06] to allow the team to proceed.
 16 A brief tutorial on UML is presented in Appendix 1.
90
 PART ONE THE SOFTWARE PROCESS
 • Implementation. Models are translated into source code.
 • Testing. Like XP, the team designs and executes a series of tests to uncover
 errors and ensure that the source code meets its requirements.
 • Deployment. Like the generic process activity discussed in Chapters 1 and 2,
 deployment in this context focuses on the delivery of a software increment
 and the acquisition of feedback from end users.
 • Configuration and project management. In the context of AUP, configuration
 management (Chapter 22) addresses change management, risk manage
ment, and the control of any persistent work products17 that are produced by
 the team. Project management tracks and controls the progress of the team
 and coordinates team activities.
 • Environment management. Environment management coordinates a process
 infrastructure that includes standards, tools, and other support technology
 available to the team.
 Although the AUP has historical and technical connections to the Unified Modeling
 Language, it is important to note that UML modeling can be using in conjunction
 with any of the agile process models described in Section 3.5.
 SOFTWARE TOOLS
 Agile Development
 Objective: The objective of agile development
 tools is to assist in one or more aspects of agile
 development with an emphasis on facilitating the rapid
 generation of operational software. These tools can also
 be used when prescriptive process models (Chapter 2) are
 applied.
 Mechanics: Tool mechanics vary. In general, agile tool
 sets encompass automated support for project planning,
 use case development and requirements gathering, rapid
 design, code generation, and testing.
 Representative Tools:18
 Note: Because agile development is a hot topic, most
 software tools vendors purport to sell tools that support 
the agile approach. The tools noted here have
 characteristics that make them particularly useful for
 agile projects.
 OnTime, developed by Axosoft (www.axosoft.com),
 provides agile process management support for
 various technical activities within the process.
 Ideogramic UML, developed by Ideogramic
 (www.ideogramic.com) is a UML tool set
 specifically developed for use within an agile 
process.
 Together Tool Set, distributed by Borland
 (www.borland.com), provides a tools suite that
 supports many technical activities within XP and other
 agile processes.
 17 A persistent work product is a model or document or test case produced by the team that will be kept
 for an indeterminate period of time. It will not be discarded once the software increment is
 delivered.
 18 Tools noted here do not represent an endorsement, but rather a sampling of tools in this category.
 In most cases, tool names are trademarked by their respective developers.
91
 CHAPTER 3 AGILE DEVELOPMENT
 3.6 A TOOL SET FOR THE AGILE PROCESS
 The “tool set” that
 supports agile
 processes focuses
 more on people issues
 than it does on
 technology issues.
 Some proponents of the agile philosophy argue that automated software tools (e.g.,
 design tools) should be viewed as a minor supplement to the team’s activities, and
 not at all pivotal to the success of the team. However, Alistair Cockburn [Coc04] sug
gests that tools can have a benefit and that “agile teams stress using tools that per
mit the rapid flow of understanding. Some of those tools are social, starting even at
 the hiring stage. Some tools are technological, helping distributed teams simulate
 being physically present. Many tools are physical, allowing people to manipulate
 them in workshops.”
 Because acquiring the right people (hiring), team collaboration, stakeholder com
munication, and indirect management are key elements in virtually all agile process
 models, Cockburn argues that “tools” that address these issues are critical success
 factors for agility. For example, a hiring “tool” might be the requirement to have a
 prospective team member spend a few hours pair programming with an existing
 member of the team. The “fit” can be assessed immediately.
 Collaborative and communication “tools” are generally low tech and incorporate
 any mechanism (“physical proximity, whiteboards, poster sheets, index cards, and
 sticky notes” [Coc04]) that provides information and coordination among agile de
velopers. Active communication is achieved via the team dynamics (e.g., pair pro
gramming), while passive communication is achieved by “information radiators”
 (e.g., a flat panel display that presents the overall status of different components of
 an increment). Project management tools deemphasize the Gantt chart and replace
 it with earned value charts or “graphs of tests created versus passed . . . other agile
 tools are used to optimize the environment in which the agile team works (e.g., more
 efficient meeting areas), improve the team culture by nurturing social interactions
 (e.g., collocated teams), physical devices (e.g., electronic whiteboards), and process
 enhancement (e.g., pair programming or time-boxing)” [Coc04].
 Are any of these things really tools? They are, if they facilitate the work performed
 by an agile team member and enhance the quality of the end product.
 3.7 SUMMARY
 In a modern economy, market conditions change rapidly, customer and end-user
 needs evolve, and new competitive threats emerge without warning. Practitioners
 must approach software engineering in a manner that allows them to remain agile—
 to define maneuverable, adaptive, lean processes that can accommodate the needs
 of modern business.
 An agile philosophy for software engineering stresses four key issues: the impor
tance of self-organizing teams that have control over the work they perform, com
munication and collaboration between team members and between practitioners
 and their customers, a recognition that change represents an opportunity, and
92
 PART ONE THE SOFTWARE PROCESS
 an emphasis on rapid delivery of software that satisfies the customer. Agile process
 models have been designed to address each of these issues.
 Extreme programming (XP) is the most widely used agile process. Organized as
 four framework activities—planning, design, coding, and testing—XP suggests a
 number of innovative and powerful techniques that allow an agile team to create
 frequent software releases that deliver features and functionality that have been de
scribed and then prioritized by stakeholders.
 Other agile process models also stress human collaboration and team self
organization, but define their own framework activities and select different points of
 emphasis. For example, ASD uses an iterative process that incorporates adaptive
 cycle planning, relatively rigorous requirement gathering methods, and an iterative
 development cycle that incorporates customer focus groups and formal technical re
views as real-time feedback mechanisms. Scrum emphasizes the use of a set of soft
ware process patterns that have proven effective for projects with tight time lines,
 changing requirements, and business criticality. Each process pattern defines a set
 of development tasks and allows the Scrum team to construct a process that is
 adapted to the needs of the project. The Dynamic Systems Development Method
 (DSDM) advocates the use of time-box scheduling and suggests that only enough
 work is required for each software increment to facilitate movement to the next
 increment. Crystal is a family of agile process models that can be adopted to the spe
cific characteristics of a project.
 Feature Driven Development (FDD) is somewhat more “formal” than other agile
 methods, but still maintains agility by focusing the project team on the development
 of features—a client-valued function that can be implemented in two weeks or less.
 Lean Software Development (LSD) has adapted the principles of lean manufacturing
 to the world of software engineering. Agile modeling (AM) suggests that modeling is
 essential for all systems, but that the complexity, type, and size of the model must be
 tuned to the software to be built. The Agile Unified Process (AUP) adopts a “serial in
 the large” and “iterative in the small” philosophy for building software.
 PROBLEMS AND POINTS TO PONDER
 3.1. Reread “The Manifesto for Agile Software Development” at the beginning of this chapter.
 Can you think of a situation in which one or more of the four “values” could get a software team
 into trouble?
 3.2. Describe agility (for software projects) in your own words.
 3.3. Why does an iterative process make it easier to manage change? Is every agile process dis
cussed in this chapter iterative? Is it possible to complete a project in just one iteration and still
 be agile? Explain your answers.
 3.4. Could each of the agile processes be described using the generic framework activities
 noted in Chapter 2? Build a table that maps the generic activities into the activities defined for
 each agile process.
 3.5. Try to come up with one more “agility principle” that would help a software engineering
 team become even more maneuverable.
93
 CHAPTER 3 AGILE DEVELOPMENT
 3.6. Select one agility principle noted in Section 3.3.1 and try to determine whether each of the
 process models presented in this chapter exhibits the principle. [Note: I have presented an
 overview of these process models only, so it may not be possible to determine whether a prin
ciple has been addressed by one or more of the models, unless you do additional research
 (which is not required for this problem).]
 3.7. Why do requirements change so much? After all, don’t people know what they want?
 3.8. Most agile process models recommend face-to-face communication. Yet today, members
 of a software team and their customers may be geographically separated from one another. Do
 you think this implies that geographical separation is something to avoid? Can you think of ways
 to overcome this problem?
 3.9. Write an XP user story that describes the “favorite places” or “bookmarks” feature avail
able on most Web browsers.
 3.10. What is a spike solution in XP?
 3.11. Describe the XP concepts of refactoring and pair programming in your own words.
 3.12. Do a bit more reading and describe what a time-box is. How does this assist an ASD team
 in delivering software increments in a short time period?
 3.13. Do the 80 percent rule in DSDM and the time-boxing approach defined for ASD achieve
 the same result?
 3.14. Using the process pattern template presented in Chapter 2, develop a process pattern for
 any one of the Scrum patterns presented in Section 3.5.2.
 3.15. Why is Crystal called a family of agile methods?
 3.16. Using the FDD feature template described in Section 3.5.5, define a feature set for a Web
 browser. Now develop a set of features for the feature set.
 3.17. Visit the Official Agile Modeling Site and make a complete list of all core and supple
mentary AM principles.
 3.18. The tool set proposed in Section 3.6 supports many of the “soft” aspects of agile meth
ods. Since communication is so important, recommend an actual tool set that might be used to
 enhance communication among stakeholders on an agile team.
 FURTHER READINGS AND INFORMATION SOURCES
 The overall philosophy and underlying principles of agile software development are considered
 in depth in many of the books referenced in the body of this chapter. In addition, books by Shaw
 and Warden (The Art of Agile Development, O’Reilly Media, Inc., 2008), Hunt (Agile Software Con
struction, Springer, 2005), and Carmichael and Haywood (Better Software Faster, Prentice-Hall,
 2002) present useful discussions of the subject. Aguanno (Managing Agile Projects, Multi
Media Publications, 2005), Highsmith (Agile Project Management: Creating Innovative Products,
 Addison-Wesley, 2004), and Larman (Agile and Iterative Development: A Manager’s Guide,
 Addison-Wesley, 2003) present a management overview and consider project management
 issues. Highsmith (Agile Software Development Ecosystems, Addison-Wesley, 2002) presents a
 survey of agile principles, processes, and practices. A worthwhile discussion of the delicate bal
ance between agility and discipline is presented by Booch and his colleagues (Balancing Agility
 and Discipline, Addison-Wesley, 2004).
 Martin (Clean Code: A Handbook of Agile Software Craftsmanship, Prentice-Hall, 2009) pres
ents the principles, patterns, and practices required to develop “clean code” in an agile software
 engineering environment. Leffingwell (Scaling Software Agility: Best Practices for Large Enter
prises, Addison-Wesley, 2007) discusses strategies for scaling up agile practices for large proj
ects. Lippert and Rook (Refactoring in Large Software Projects: Performing Complex Restructurings
 Successfully, Wiley, 2006) discuss the use of refactoring when applied in large, complex systems.
94
 PART ONE THE SOFTWARE PROCESS
 Stamelos and Sfetsos (Agile Software Development Quality Assurance, IGI Global, 2007) discuss
 SQA techniques that conform to the agile philosophy.
 Dozens of books have been written about Extreme Programming over the past decade. Beck
 (Extreme Programming Explained: Embrace Change, 2d ed., Addison-Wesley, 2004) remains the
 definitive treatment of the subject. In addition, Jeffries and his colleagues (Extreme Programming
 Installed, Addison-Wesley, 2000), Succi and Marchesi (Extreme Programming Examined,
 Addison-Wesley, 2001), Newkirk and Martin (Extreme Programming in Practice, Addison-Wesley,
 2001), and Auer and his colleagues (Extreme Programming Applied: Play to Win, Addison-Wesley,
 2001) provide a nuts-and-bolts discussion of XP along with guidance on how best to apply it.
 McBreen (Questioning Extreme Programming, Addison-Wesley, 2003) takes a critical look at XP,
 defining when and where it is appropriate. An in-depth consideration of pair programming is
 presented by McBreen (Pair Programming Illuminated, Addison-Wesley, 2003).
 ASD is addressed in depth by Highsmith [Hig00]. Schwaber (The Enterprise and Scrum,
 Microsoft Press, 2007) discusses the use of Scrum for projects that have a major business
 impact. The nuts and bolts of Scrum are discussed by Schwaber and Beedle (Agile Software
 Development with SCRUM, Prentice-Hall, 2001). Worthwhile treatments of DSDM have been
 written by the DSDM Consortium (DSDM: Business Focused Development, 2d ed., Pearson Edu
cation, 2003) and Stapleton (DSDM: The Method in Practice, Addison-Wesley, 1997). Cockburn
 (Crystal Clear, Addison-Wesley, 2005) presents an excellent overview of the Crystal family of
 processes. Palmer and Felsing [Pal02] present a detailed treatment of FDD. Carmichael and
 Haywood (Better Software Faster, Prentice-Hall, 2002) provides another useful treatment of FDD
 that includes a step-by-step journey through the mechanics of the process. Poppendieck and 
Poppendieck (Lean Development: An Agile Toolkit for Software Development Managers, Addison
Wesley, 2003) provide guidelines for managing and controlling agile projects. Ambler and
 Jeffries (Agile Modeling, Wiley, 2002) discuss AM in some depth.
 A wide variety of information sources on agile software development are available on the
 Internet. An up-to-date list of World Wide Web references that are relevant to the agile process
 can be found at the SEPA website: www.mhhe.com/engcs/compsci/pressman/
 professional/olc/ser.htm.
In 2001, Kent Beck and 16 other noted software developers, writers, and con
sultants [Bec01a] (referred to as the “Agile Alliance”) signed the “Manifesto for
 Agile Software Development.” It stated:
 We are uncovering better ways of developing software by doing it and helping others
 do it. Through this work we have come to value: 
Individuals and interactions over processes and tools
 Working software over comprehensive documentation
 Customer collaboration over contract negotiation
 Responding to change over following a plan
 That is, while there is value in the items on the right, we value the items on the 
left more.
 QUICK
 LOOK
 What is it? Agile software engi
neering combines a philosophy and
 a set of development guidelines. The
 philosophy encourages customer
 satisfaction and early incremental delivery of
 software; small, highly motivated project teams;
 informal methods; minimal software engineer
ing work products; and overall development
 simplicity. The development guidelines stress
 delivery over analysis and design (although
 these activities are not discouraged), and active
 and continuous communication between devel
opers and customers.
 Who does it? Software engineers and other
 project stakeholders (managers, customers, end
 users) work together on an agile team—a team
 that is self-organizing and in control of its own
 destiny. An agile team fosters communication
 and collaboration among all who serve on it.
 Why is it important? The modern business envi
ronment that spawns computer-based systems
 and software products is fast-paced and ever
changing. Agile software engineering repre
sents a reasonable alternative to conventional
 software engineering for certain classes of soft
ware and certain types of software projects. It
 has been demonstrated to deliver successful sys
tems quickly.
 Whatarethesteps? Agiledevelopmentmightbest
 be termed “software engineering lite.” The basic
 framework activities—communication, planning,
 modeling, construction, and deployment—
 remain. But they morph into a minimal task set
 that pushes the project team toward construction
 and delivery (some would argue that this is
 done at the expense of problem analysis and
 solution design).
 What is the work product? Both the customer
 and the software engineer have the same
 view—the only really important work product
 is an operational “software increment” that is
 delivered to the customer on the appropriate
 commitment date.
 How do I ensure that I’ve done it right? If the
 agile team agrees that the process works, and
 the team produces deliverable software
 increments that satisfy the customer, you’ve
 done it right.
 65
66
 PART ONE THE SOFTWARE PROCESS
 FDD . . . . . . . . . .86
 Industrial XP . . .77
 Lean Software
 Development . . .87
 pair 
programming . . .76
 project 
velocity . . . . . . .74
 refactoring . . . . .75
 Scrum . . . . . . . .82
 stories . . . . . . . .74
 XP process . . . . .73
 uote:
 “Agility: 1,
 everything else: 0.”
 Tom DeMarco
 A manifesto is normally associated with an emerging political movement—one
 that attacks the old guard and suggests revolutionary change (hopefully for the
 better). In some ways, that’s exactly what agile development is all about.
 Although the underlying ideas that guide agile development have been with us for
 many years, it has been less than two decades since these ideas have crystallized
 into a “movement.” In essence, agile1 methods were developed in an effort to over
come perceived and actual weaknesses in conventional software engineering. Agile
 development can provide important benefits, but it is not applicable to all projects,
 all products, all people, and all situations. It is also not antithetical to solid software
 engineering practice and can be applied as an overriding philosophy for all software
 work.
 In the modern economy, it is often difficult or impossible to predict how a
 computer-based system (e.g., a Web-based application) will evolve as time passes.
 Market conditions change rapidly, end-user needs evolve, and new competitive
 threats emerge without warning. In many situations, you won’t be able to define
 requirements fully before the project begins. You must be agile enough to respond to
 a fluid business environment.
 Fluidity implies change, and change is expensive. Particularly if it is uncontrolled
 or poorly managed. One of the most compelling characteristics of the agile approach
 is its ability to reduce the costs of change throughout the software process.
 Does this mean that a recognition of challenges posed by modern realities causes
 you to discard valuable software engineering principles, concepts, methods, and
 tools? Absolutely not! Like all engineering disciplines, software engineering contin
ues to evolve. It can be adapted easily to meet the challenges posed by a demand for
 agility.
 In a thought-provoking book on agile software development, Alistair Cockburn
 [Coc02] argues that the prescriptive process models introduced in Chapter 2 have a
 major failing: they forget the frailties of the people who build computer software. Software
 engineers are not robots. They exhibit great variation in working styles; significant dif
ferences in skill level, creativity, orderliness, consistency, and spontaneity. Some com
municate well in written form, others do not. Cockburn argues that process models
 can “deal with people’s common weaknesses with [either] discipline or tolerance” and
 that most prescriptive process models choose discipline. He states: “Because consis
tency in action is a human weakness, high discipline methodologies are fragile.”
 If process models are to work, they must provide a realistic mechanism for en
couraging the discipline that is necessary, or they must be characterized in a man
ner that shows “tolerance” for the people who do software engineering work.
 Invariably, tolerant practices are easier for software people to adopt and sustain, but
 (as Cockburn admits) they may be less productive. Like most things in life, trade-offs
 must be considered.
 1 Agile methods are sometimes referred to as light methods or lean methods.
67
 CHAPTER 3 AGILE DEVELOPMENT
 3.1 WHAT IS AGILITY?
 Just what is agility in the context of software engineering work? Ivar Jacobson
 [Jac02a] provides a useful discussion:
 Agility has become today’s buzzword when describing a modern software process. Every
one is agile. An agile team is a nimble team able to appropriately respond to changes.
 Change is what software development is very much about. Changes in the software be
ing built, changes to the team members, changes because of new technology, changes of
 all kinds that may have an impact on the product they build or the project that creates the
 product. Support for changes should be built-in everything we do in software, something
 we embrace because it is the heart and soul of software. An agile team recognizes that
 software is developed by individuals working in teams and that the skills of these people,
 their ability to collaborate is at the core for the success of the project.
 Don’t make the
 mistake of assuming
 that agility gives you
 license to hack out
 solutions. A process is
 required and discipline
 is essential.
 In Jacobson’s view, the pervasiveness of change is the primary driver for agility. Soft
ware engineers must be quick on their feet if they are to accommodate the rapid
 changes that Jacobson describes.
 But agility is more than an effective response to change. It also encompasses the
 philosophy espoused in the manifesto noted at the beginning of this chapter. It
 encourages team structures and attitudes that make communication (among team
 members, between technologists and business people, between software engineers
 and their managers) more facile. It emphasizes rapid delivery of operational soft
ware and de-emphasizes the importance of intermediate work products (not always
 a good thing); it adopts the customer as a part of the development team and works
 to eliminate the “us and them” attitude that continues to pervade many software
 projects; it recognizes that planning in an uncertain world has its limits and that a
 project plan must be flexible.
 Agility can be applied to any software process. However, to accomplish this, it is
 essential that the process be designed in a way that allows the project team to adapt
 tasks and to streamline them, conduct planning in a way that understands the fluid
ity of an agile development approach, eliminate all but the most essential work prod
ucts and keep them lean, and emphasize an incremental delivery strategy that gets
 working software to the customer as rapidly as feasible for the product type and
 operational environment.
 3.2 AGILITY AND THE COST OF CHANGE
 The conventional wisdom in software development (supported by decades of expe
rience) is that the cost of change increases nonlinearly as a project progresses
 (Figure 3.1, solid black curve). It is relatively easy to accommodate a change when a
 software team is gathering requirements (early in a project). A usage scenario might
 have to be modified, a list of functions may be extended, or a written specification
 can be edited. The costs of doing this work are minimal, and the time required will
68
 PART ONE THE SOFTWARE PROCESS
 FIGURE 3.1
 Change costs
 as a function
 of time in
 development
 uote:
 Development cost
 Cost of change
 using conventional
 software processes
 Cost of change
 using agile processes
 “Agility is dynamic,
 content specific,
 aggressively
 change embracing,
 and growth
 oriented.”
 Idealized cost of change
 using agile process
 Development schedule progress–Steven
 Goldman et al.
 An agile process
 reduces the cost of
 change because
 software is released in
 increments and change
 can be better
 controlled within an
 increment.
 not adversely affect the outcome of the project. But what if we fast-forward a num
ber of months? The team is in the middle of validation testing (something that occurs
 relatively late in the project), and an important stakeholder is requesting a major
 functional change. The change requires a modification to the architectural design of
 the software, the design and construction of three new components, modifications
 to another five components, the design of new tests, and so on. Costs escalate
 quickly, and the time and cost required to ensure that the change is made without
 unintended side effects is nontrivial.
 Proponents of agility (e.g., [Bec00], [Amb04]) argue that a well-designed agile
 process “flattens” the cost of change curve (Figure 3.1, shaded, solid curve), allowing
 a software team to accommodate changes late in a software project without dramatic
 cost and time impact. You’ve already learned that the agile process encompasses in
cremental delivery. When incremental delivery is coupled with other agile practices
 such as continuous unit testing and pair programming (discussed later in this chap
ter), the cost of making a change is attenuated. Although debate about the degree to
 which the cost curve flattens is ongoing, there is evidence [Coc01a] to suggest that a
 significant reduction in the cost of change can be achieved.
 3.3 WHAT IS ANAGILE PROCESS?
 Any agile software process is characterized in a manner that addresses a number of
 key assumptions [Fow02] about the majority of software projects: 
1. It is difficult to predict in advance which software requirements will persist
 and which will change. It is equally difficult to predict how customer
 priorities will change as the project proceeds.
69
 CHAPTER 3 AGILE DEVELOPMENT
 WebRef
 A comprehensive
 collection of articles on
 the agile process 
can be found at
 www.aanpo.org/
 articles/index.
 Although agile
 processes embrace
 change, it is still
 important to examine
 the reasons for
 change.
 Working software is
 important, but don’t
 forget that it must also
 exhibit a variety of
 quality attributes
 including reliability,
 usability, and 
maintainability.
 2. For many types of software, design and construction are interleaved. That is,
 both activities should be performed in tandem so that design models are
 proven as they are created. It is difficult to predict how much design is
 necessary before construction is used to prove the design.
 3. Analysis, design, construction, and testing are not as predictable (from a
 planning point of view) as we might like.
 Given these three assumptions, an important question arises: How do we create a
 process that can manage unpredictability? The answer, as I have already noted, lies
 in process adaptability (to rapidly changing project and technical conditions). An
 agile process, therefore, must be adaptable.
 But continual adaptation without forward progress accomplishes little. Therefore,
 an agile software process must adapt incrementally. To accomplish incremental adap
tation, an agile team requires customer feedback (so that the appropriate adaptations
 can be made). An effective catalyst for customer feedback is an operational prototype
 or a portion of an operational system. Hence, an incremental development strategy
 should be instituted. Software increments (executable prototypes or portions of an op
erational system) must be delivered in short time periods so that adaptation keeps pace
 with change (unpredictability). This iterative approach enables the customer to evalu
ate the software increment regularly, provide necessary feedback to the software team,
 and influence the process adaptations that are made to accommodate the feedback.
 3.3.1 Agility Principles
 The Agile Alliance (see [Agi03], [Fow01]) defines 12 agility principles for those who
 want to achieve agility: 
1. Our highest priority is to satisfy the customer through early and continuous
 delivery of valuable software.
 2. Welcome changing requirements, even late in development. Agile processes
 harness change for the customer’s competitive advantage.
 3. Deliver working software frequently, from a couple of weeks to a couple of
 months, with a preference to the shorter timescale.
 4. Business people and developers must work together daily throughout the
 project.
 5. Build projects around motivated individuals. Give them the environment and
 support they need, and trust them to get the job done.
 6. The most efficient and effective method of conveying information to and
 within a development team is face-to-face conversation.
 7. Working software is the primary measure of progress.
 8. Agile processes promote sustainable development. The sponsors, developers,
 and users should be able to maintain a constant pace indefinitely.
70
 PART ONE THE SOFTWARE PROCESS
 9. Continuous attention to technical excellence and good design enhances
 agility.
 10. Simplicity—the art of maximizing the amount of work not done—is 
essential.
 11. The best architectures, requirements, and designs emerge from self
organizing teams.
 12. At regular intervals, the team reflects on how to become more effective, then
 tunes and adjusts its behavior accordingly.
 Not every agile process model applies these 12 principles with equal weight, and
 some models choose to ignore (or at least downplay) the importance of one or more
 of the principles. However, the principles define an agile spirit that is maintained in
 each of the process models presented in this chapter.
 3.3.2 The Politics of Agile Development
 You don’t have to
 choose between agility
 and software engi
neering. Rather, define
 a software engineering
 approach that is agile.
 There is considerable debate (sometimes strident) about the benefits and applicabil
ity of agile software development as opposed to more conventional software engi
neering processes. Jim Highsmith [Hig02a] (facetiously) states the extremes when he
 characterizes the feeling of the pro-agility camp (“agilists”). “Traditional methodolo
gists are a bunch of stick-in-the-muds who’d rather produce flawless documentation
 than a working system that meets business needs.” As a counterpoint, he states
 (again, facetiously) the position of the traditional software engineering camp: “Light
weight, er, ‘agile’ methodologists are a bunch of glorified hackers who are going to
 be in for a heck of a surprise when they try to scale up their toys into enterprise-wide
 software.”
 Like all software technology arguments, this methodology debate risks degener
ating into a religious war. If warfare breaks out, rational thought disappears and
 beliefs rather than facts guide decision making.
 No one is against agility. The real question is: What is the best way to achieve it?
 As important, how do you build software that meets customers’ needs today and
 exhibits the quality characteristics that will enable it to be extended and scaled to
 meet customers’ needs over the long term?
 There are no absolute answers to either of these questions. Even within the agile
 school itself, there are many proposed process models (Section 3.4), each with a
 subtly different approach to the agility problem. Within each model there is a set of
 “ideas” (agilists are loath to call them “work tasks”) that represent a significant
 departure from traditional software engineering. And yet, many agile concepts are
 simply adaptations of good software engineering concepts. Bottom line: there is
 much that can be gained by considering the best of both schools and virtually
 nothing to be gained by denigrating either approach.
 If you have further interest, see [Hig01], [Hig02a], and [DeM02] for an entertain
ing summary of other important technical and political issues.
71
 CHAPTER 3 AGILE DEVELOPMENT
 uote:
 “Agile methods
 derive much of
 their agility by
 relying on the
 tacit knowledge
 embodied in the
 team, rather than
 writing the
 knowledge down
 in plans.”
 Barry Boehm
 ?
 What key
 traits must
 exist among the
 people on an
 effective software
 team?
 uote:
 “What counts as
 barely sufficient
 for one team is
 either overly
 sufficient or
 insufficient for
 another.”
 Alistair
 Cockburn
 3.3.3 Human Factors
 Proponents of agile software development take great pains to emphasize the impor
tance of “people factors.” As Cockburn and Highsmith [Coc01a] state, “Agile devel
opment focuses on the talents and skills of individuals, molding the process to
 specific people and teams.” The key point in this statement is that the process molds
 to the needs of the people and team, not the other way around.2
 If members of the software team are to drive the characteristics of the process that
 is applied to build software, a number of key traits must exist among the people on
 an agile team and the team itself:
 Competence. In an agile development (as well as software engineering)
 context, “competence” encompasses innate talent, specific software-related
 skills, and overall knowledge of the process that the team has chosen to
 apply. Skill and knowledge of process can and should be taught to all people
 who serve as agile team members.
 Common focus. Although members of the agile team may perform differ
ent tasks and bring different skills to the project, all should be focused on one
 goal—to deliver a working software increment to the customer within the
 time promised. To achieve this goal, the team will also focus on continual
 adaptations (small and large) that will make the process fit the needs of the
 team.
 Collaboration. Software engineering (regardless of process) is about as
sessing, analyzing, and using information that is communicated to the soft
ware team; creating information that will help all stakeholders understand
 the work of the team; and building information (computer software and rele
vant databases) that provides business value for the customer. To accomplish
 these tasks, team members must collaborate—with one another and all other
 stakeholders.
 Decision-making ability. Any good software team (including agile teams)
 must be allowed the freedom to control its own destiny. This implies that the
 team is given autonomy—decision-making authority for both technical and
 project issues.
 Fuzzy problem-solving ability. Software managers must recognize that
 the agile team will continually have to deal with ambiguity and will continu
ally be buffeted by change. In some cases, the team must accept the fact that
 the problem they are solving today may not be the problem that needs to be
 solved tomorrow. However, lessons learned from any problem-solving
 2 Successful software engineering organizations recognize this reality regardless of the process
 model they choose.
72
 PART ONE THE SOFTWARE PROCESS
 A self-organizing team
 is in control of the
 work it performs. The
 team makes its own
 commitments and
 defines plans to
 achieve them.
 activity (including those that solve the wrong problem) may be of benefit to
 the team later in the project.
 Mutual trust and respect. The agile team must become what DeMarco
 and Lister [DeM98] call a “jelled” team (Chapter 24). A jelled team exhibits
 the trust and respect that are necessary to make them “so strongly knit that
 the whole is greater than the sum of the parts.” [DeM98]
 Self-organization. In the context of agile development, self-organization
 implies three things: (1) the agile team organizes itself for the work to be
 done, (2) the team organizes the process to best accommodate its local envi
ronment, (3) the team organizes the work schedule to best achieve delivery
 of the software increment. Self-organization has a number of technical bene
fits, but more importantly, it serves to improve collaboration and boost team
 morale. In essence, the team serves as its own management. Ken Schwaber
 [Sch02] addresses these issues when he writes: “The team selects how much
 work it believes it can perform within the iteration, and the team commits to
 the work. Nothing demotivates a team as much as someone else making
 commitments for it. Nothing motivates a team as much as accepting the
 responsibility for fulfilling commitments that it made itself.”
 3.4 EXTREME PROGRAMMING (XP)
 In order to illustrate an agile process in a bit more detail, I’ll provide you with an
 overview of Extreme Programming (XP), the most widely used approach to agile soft
ware development. Although early work on the ideas and methods associated with
 XP occurred during the late 1980s, the seminal work on the subject has been written
 by Kent Beck [Bec04a]. More recently, a variant of XP, called Industrial XP (IXP) has
 been proposed [Ker05]. IXP refines XP and targets the agile process specifically for
 use within large organizations.
 3.4.1 XP Values
 Beck [Bec04a] defines a set of five values that establish a foundation for all work per
formed as part of XP—communication, simplicity, feedback, courage, and respect. Each
 of these values is used as a driver for specific XP activities, actions, and tasks.
 In order to achieve effective communication between software engineers and
 other stakeholders (e.g., to establish required features and functions for the soft
ware), XP emphasizes close, yet informal (verbal) collaboration between customers
 and developers, the establishment of effective metaphors3 for communicating
 important concepts, continuous feedback, and the avoidance of voluminous docu
mentation as a communication medium.
 3 In the XP context, a metaphor is “a story that everyone—customers, programmers, and managers—
 can tell about how the system works” [Bec04a].
73
 CHAPTER 3 AGILE DEVELOPMENT
 Keep it simple
 whenever you can, but
 recognize that
 continual “refactoring”
 can absorb significant
 time and resources.
 uote:
 “XP is the answer
 to the question,
 ‘How little can we
 do and still build
 great software?’“
 Anonymous
 WebRef
 An excellent overview
 of “rules” for XP can
 be found at www
 .extremeprogramm
 ing.org/rules.html.
 To achieve simplicity, XP restricts developers to design only for immediate needs,
 rather than consider future needs. The intent is to create a simple design that can be
 easily implemented in code). If the design must be improved, it can be refactored4 at
 a later time.
 Feedback is derived from three sources: the implemented software itself, the
 customer, and other software team members. By designing and implementing an
 effective testing strategy (Chapters 17 through 20), the software (via test results) pro
vides the agile team with feedback. XP makes use of the unit test as its primary test
ing tactic. As each class is developed, the team develops a unit test to exercise each
 operation according to its specified functionality. As an increment is delivered to a
 customer, the user stories or use cases (Chapter 5) that are implemented by the
 increment are used as a basis for acceptance tests. The degree to which the software
 implements the output, function, and behavior of the use case is a form of feedback.
 Finally, as new requirements are derived as part of iterative planning, the team pro
vides the customer with rapid feedback regarding cost and schedule impact.
 Beck [Bec04a] argues that strict adherence to certain XP practices demands
 courage. A better word might be discipline. For example, there is often significant
 pressure to design for future requirements. Most software teams succumb, arguing
 that “designing for tomorrow” will save time and effort in the long run. An agile XP
 team must have the discipline (courage) to design for today, recognizing that future
 requirements may change dramatically, thereby demanding substantial rework of
 the design and implemented code.
 By following each of these values, the agile team inculcates respect among it
 members, between other stakeholders and team members, and indirectly, for the
 software itself. As they achieve successful delivery of software increments, the team
 develops growing respect for the XP process.
 3.4.2 The XP Process
 Extreme Programming uses an object-oriented approach (Appendix 2) as its pre
ferred development paradigm and encompasses a set of rules and practices that
 occur within the context of four framework activities: planning, design, coding, and
 testing. Figure 3.2 illustrates the XP process and notes some of the key ideas and
 tasks that are associated with each framework activity. Key XP activities are sum
marized in the paragraphs that follow.
 Planning. The planning activity (also called the planning game) begins with
 listening—a requirements gathering activity that enables the technical members of
 the XP team to understand the business context for the software and to get a broad
 4 Refactoring allows a software engineer to improve the internal structure of a design (or source
 code) without changing its external functionality or behavior. In essence, refactoring can be used
 to improve the efficiency, readability, or performance of a design or the code that implements a
 design.
74
 PART ONE THE SOFTWARE PROCESS
 FIGURE 3.2
 The Extreme
 Programming
 process
 ?
 What is an
 XP “story”?
 WebRef
 A worthwhile XP
 “planning game” can
 be found at:
 c2.com/cgi/
 wiki?planningGame.
 simple design
 CRC cards
 user stories
 values
 acceptance test criteria
 iteration plan
 Release
 spike solutions
 prototypes
 refactoring
 design
 pair programming
 planning
 software increment
 project velocity computed
 unit test
 continuous integration
 acceptance testing
 test
 coding
 feel for required output and major features and functionality. Listening leads to the
 creation of a set of “stories” (also called user stories) that describe required output,
 features, and functionality for software to be built. Each story (similar to use cases
 described in Chapter 5) is written by the customer and is placed on an index card.
 The customer assigns a value (i.e., a priority) to the story based on the overall busi
ness value of the feature or function.5 Members of the XP team then assess each
 story and assign a cost—measured in development weeks—to it. If the story is esti
mated to require more than three development weeks, the customer is asked to split
 the story into smaller stories and the assignment of value and cost occurs again. It
 is important to note that new stories can be written at any time.
 Customers and developers work together to decide how to group stories into the
 next release (the next software increment) to be developed by the XP team. Once a
 basic commitment (agreement on stories to be included, delivery date, and other
 project matters) is made for a release, the XP team orders the stories that will be de
veloped in one of three ways: (1) all stories will be implemented immediately (within
 a few weeks), (2) the stories with highest value will be moved up in the schedule and
 implemented first, or (3) the riskiest stories will be moved up in the schedule and
 implemented first.
 After the first project release (also called a software increment) has been deliv
ered, the XP team computes project velocity. Stated simply, project velocity is the
 5 The value of a story may also be dependent on the presence of another story.
75
 CHAPTER 3 AGILE DEVELOPMENT
 Project velocity is a
 subtle measure of
 team productivity.
 XP deemphasizes the
 importance of design.
 Not everyone agrees.
 In fact, there are times
 when design should be
 emphasized.
 WebRef
 Refactoring techniques
 and tools can be
 found at:
 www.refactoring
 .com.
 number of customer stories implemented during the first release. Project velocity can
 then be used to (1) help estimate delivery dates and schedule for subsequent releases
 and (2) determine whether an overcommitment has been made for all stories across
 the entire development project. If an overcommitment occurs, the content of releases
 is modified or end delivery dates are changed.
 As development work proceeds, the customer can add stories, change the value
 of an existing story, split stories, or eliminate them. The XP team then reconsiders all
 remaining releases and modifies its plans accordingly.
 Design. XP design rigorously follows the KIS (keep it simple) principle. A simple
 design is always preferred over a more complex representation. In addition, the de
sign provides implementation guidance for a story as it is written—nothing less,
 nothing more. The design of extra functionality (because the developer assumes it
 will be required later) is discouraged.6
 XP encourages the use of CRC cards (Chapter 7) as an effective mechanism for
 thinking about the software in an object-oriented context. CRC (class-responsibility
collaborator) cards identify and organize the object-oriented classes7 that are rele
vant to the current software increment. The XP team conducts the design exercise
 using a process similar to the one described in Chapter 8. The CRC cards are the only
 design work product produced as part of the XP process.
 If a difficult design problem is encountered as part of the design of a story, XP rec
ommends the immediate creation of an operational prototype of that portion of the
 design. Called a spike solution, the design prototype is implemented and evaluated.
 The intent is to lower risk when true implementation starts and to validate the orig
inal estimates for the story containing the design problem.
 In the preceding section, we noted that XP encourages refactoring—a construction
 technique that is also a method for design optimization. Fowler [Fow00] describes
 refactoring in the following manner:
 Refactoring is the process of changing a software system in such a way that it does not
 alter the external behavior of the code yet improves the internal structure. It is a disci
plined way to clean up code [and modify/simplify the internal design] that minimizes the
 chances of introducing bugs. In essence, when you refactor you are improving the design
 of the code after it has been written.
 Because XP design uses virtually no notation and produces few, if any, work prod
ucts other than CRC cards and spike solutions, design is viewed as a transient arti
fact that can and should be continually modified as construction proceeds. The intent
 of refactoring is to control these modifications by suggesting small design changes
 6 These design guidelines should be followed in every software engineering method, although there
 are times when sophisticated design notation and terminology may get in the way of simplicity.
 7 Object-oriented classes are discussed in Appendix 2, in Chapter 8, and throughout Part 2 of this
 book.
76
 PART ONE THE SOFTWARE PROCESS
 Refactoring improves
 the internal structure of
 a design (or source
 code) without
 changing its external
 functionality or
 behavior.
 WebRef
 Useful information on
 XP can be obtained 
at www
 .xprogramming.
 com.
 ?
 What is 
pair
 programming?
 Many software teams
 are populated by indi
vidualists. You’ll have
 to work to change that
 culture if pair program
ming is to work effec
tively.
 ?
 XP?
 How are unit
 tests used in
 that “can radically improve the design” [Fow00]. It should be noted, however, that
 the effort required for refactoring can grow dramatically as the size of an application
 grows.
 A central notion in XP is that design occurs both before and after coding com
mences. Refactoring means that design occurs continuously as the system is con
structed. In fact, the construction activity itself will provide the XP team with
 guidance on how to improve the design.
 Coding. After stories are developed and preliminary design work is done, the team
 does not move to code, but rather develops a series of unit tests that will exercise
 each of the stories that is to be included in the current release (software increment).8
 Once the unit test9 has been created, the developer is better able to focus on what
 must be implemented to pass the test. Nothing extraneous is added (KIS). Once the
 code is complete, it can be unit-tested immediately, thereby providing instantaneous
 feedback to the developers.
 A key concept during the coding activity (and one of the most talked about aspects
 of XP) is pair programming. XP recommends that two people work together at one
 computer workstation to create code for a story. This provides a mechanism for real
time problem solving (two heads are often better than one) and real-time quality as
surance (the code is reviewed as it is created). It also keeps the developers focused
 on the problem at hand. In practice, each person takes on a slightly different role. For
 example, one person might think about the coding details of a particular portion of
 the design while the other ensures that coding standards (a required part of XP) are
 being followed or that the code for the story will satisfy the unit test that has been
 developed to validate the code against the story.
 As pair programmers complete their work, the code they develop is integrated
 with the work of others. In some cases this is performed on a daily basis by an inte
gration team. In other cases, the pair programmers have integration responsibility.
 This “continuous integration” strategy helps to avoid compatibility and interfacing
 problems and provides a “smoke testing” environment (Chapter 17) that helps to
 uncover errors early.
 Testing. I have already noted that the creation of unit tests before coding com
mences is a key element of the XP approach. The unit tests that are created should
 be implemented using a framework that enables them to be automated (hence, they
 can be executed easily and repeatedly). This encourages a regression testing strat
egy (Chapter 17) whenever code is modified (which is often, given the XP refactor
ing philosophy).
 8 This approach is analogous to knowing the exam questions before you begin to study. It makes
 studying much easier by focusing attention only on the questions that will be asked.
 9 Unit testing, discussed in detail in Chapter 17, focuses on an individual software component, exer
cising the component’s interface, data structures, and functionality in an effort to uncover errors
 that are local to the component.
77
 CHAPTER 3 AGILE DEVELOPMENT
 XP acceptance tests
 are derived from user
 stories.
 ?
 What new
 practices are
 appended to XP
 to create IXP?
 uote:
 “Ability is what
 you’re capable of
 doing. Motivation
 determines what
 you do. Attitude
 determines how
 well you do it.”
 Lou Holtz
 As the individual unit tests are organized into a “universal testing suite” [Wel99],
 integration and validation testing of the system can occur on a daily basis. This pro
vides the XP team with a continual indication of progress and also can raise warn
ing flags early if things go awry. Wells [Wel99] states: “Fixing small problems every
 few hours takes less time than fixing huge problems just before the deadline.”
 XP acceptance tests, also called customer tests, are specified by the customer and
 focus on overall system features and functionality that are visible and reviewable by
 the customer. Acceptance tests are derived from user stories that have been imple
mented as part of a software release.
 3.4.3 Industrial XP
 Joshua Kerievsky [Ker05] describes Industrial Extreme Programming (IXP) in the fol
lowing manner: “IXP is an organic evolution of XP. It is imbued with XP’s minimal
ist, customer-centric, test-driven spirit. IXP differs most from the original XP in its
 greater inclusion of management, its expanded role for customers, and its upgraded
 technical practices.” IXP incorporates six new practices that are designed to help
 ensure that an XP project works successfully for significant projects within a large
 organization.
 Readiness assessment. Prior to the initiation of an IXP project, the organ
ization should conduct a readiness assessment. The assessment ascertains
 whether (1) an appropriate development environment exists to support IXP,
 (2) the team will be populated by the proper set of stakeholders, (3) the or
ganization has a distinct quality program and supports continuous improve
ment, (4) the organizational culture will support the new values of an agile
 team, and (5) the broader project community will be populated appropriately.
 Project community. Classic XP suggests that the right people be used to
 populate the agile team to ensure success. The implication is that people on
 the team must be well-trained, adaptable and skilled, and have the proper
 temperament to contribute to a self-organizing team. When XP is to be
 applied for a significant project in a large organization, the concept of the
 “team” should morph into that of a community. A community may have a
 technologist and customers who are central to the success of a project as
 well as many other stakeholders (e.g., legal staff, quality auditors, manufac
turing or sales types) who “are often at the periphery of an IXP project yet
 they may play important roles on the project” [Ker05]. In IXP, the community
 members and their roles should be explicitly defined and mechanisms for
 communication and coordination between community members should be
 established.
 Project chartering. The IXP team assesses the project itself to determine
 whether an appropriate business justification for the project exists and
 whether the project will further the overall goals and objectives of the
78
 PART ONE THE SOFTWARE PROCESS
 organization. Chartering also examines the context of the project to deter
mine how it complements, extends, or replaces existing systems or
 processes.
 Test-driven management. An IXP project requires measurable criteria for
 assessing the state of the project and the progress that has been made to
 date. Test-driven management establishes a series of measurable “destina
tions” [Ker05] and then defines mechanisms for determining whether or not
 these destinations have been reached.
 Retrospectives. An IXP team conducts a specialized technical review
 (Chapter 15) after a software increment is delivered. Called a retrospective,
 the review examines “issues, events, and lessons-learned” [Ker05] across a
 software increment and/or the entire software release. The intent is to
 improve the IXP process.
 Continuous learning. Because learning is a vital part of continuous
 process improvement, members of the XP team are encouraged (and possi
bly, incented) to learn new methods and techniques that can lead to a higher
quality product.
 In addition to the six new practices discussed, IXP modifies a number of existing
 XP practices. Story-driven development (SDD) insists that stories for acceptance tests
 be written before a single line of code is generated. Domain-driven design (DDD) is
 an improvement on the “system metaphor” concept used in XP. DDD [Eva03] sug
gests the evolutionary creation of a domain model that “accurately represents how
 domain experts think about their subject” [Ker05]. Pairing extends the XP pair
programming concept to include managers and other stakeholders. The intent is to
 improve knowledge sharing among XP team members who may not be directly in
volved in technical development. Iterative usability discourages front-loaded inter
face design in favor of usability design that evolves as software increments are
 delivered and users’ interaction with the software is studied.
 IXP makes smaller modifications to other XP practices and redefines certain roles
 and responsibilities to make them more amenable to significant projects for large
 organizations. For further discussion of IXP, visit http://industrialxp.org.
 3.4.4 The XP Debate
 All new process models and methods spur worthwhile discussion and in some in
stances heated debate. Extreme Programming has done both. In an interesting book
 that examines the efficacy of XP, Stephens and Rosenberg [Ste03] argue that many
 XP practices are worthwhile, but others have been overhyped, and a few are prob
lematic. The authors suggest that the codependent nature of XP practices are both
 its strength and its weakness. Because many organizations adopt only a subset of XP
 practices, they weaken the efficacy of the entire process. Proponents counter that
 XP is continuously evolving and that many of the issues raised by critics have been
79
 CHAPTER 3 AGILE DEVELOPMENT
 addressed as XP practice matures. Among the issues that continue to trouble some
 critics of XP are:10
 ?
 What are
 some of the
 issues that lead to
 an XP debate?
 • Requirements volatility. Because the customer is an active member of the XP
 team, changes to requirements are requested informally. As a consequence,
 the scope of the project can change and earlier work may have to be
 modified to accommodate current needs. Proponents argue that this happens
 regardless of the process that is applied and that XP provides mechanisms for
 controlling scope creep.
 • Conflicting customer needs. Many projects have multiple customers, each with
 his own set of needs. In XP, the team itself is tasked with assimilating the
 needs of different customers, a job that may be beyond their scope of
 authority.
 • Requirements are expressed informally. User stories and acceptance tests are
 the only explicit manifestation of requirements in XP. Critics argue that a
 more formal model or specification is often needed to ensure that omissions,
 inconsistencies, and errors are uncovered before the system is built. Propo
nents counter that the changing nature of requirements makes such models
 and specification obsolete almost as soon as they are developed.
 • Lack of formal design. XP deemphasizes the need for architectural design and
 in many instances, suggests that design of all kinds should be relatively
 informal. Critics argue that when complex systems are built, design must be
 emphasized to ensure that the overall structure of the software will exhibit
 quality and maintainability. XP proponents suggest that the incremental
 nature of the XP process limits complexity (simplicity is a core value) and
 therefore reduces the need for extensive design.
 You should note that every software process has flaws and that many software or
ganizations have used XP successfully. The key is to recognize where a process may
 have weaknesses and to adapt it to the specific needs of your organization.
 SAFEHOME
 Considering Agile Software Development
 The scene: Doug Miller’s office.
 The Players: Doug Miller, software engineering
 manager; Jamie Lazar, software team member; Vinod
 Raman, software team member.
 The conversation:
 (A knock on the door, Jamie and Vinod enter Doug’s office)
 Jamie: Doug, you got a minute?
 10 For a detailed look at some thoughtful criticism that has been leveled at XP, visit
 www.softwarereality.com/ExtremeProgramming.jsp.
3.5 OTHERAGILEPROCESSMODELS
 The history of software engineering is littered with dozens of obsolete process
 descriptions and methodologies, modeling methods and notations, tools, and
 technology. Each flared in notoriety and was then eclipsed by something new and
 (purportedly) better. With the introduction of a wide array of agile process models—
 each contending for acceptance within the software development community—the
 agile movement is following the same historical path.11
 As I noted in the last section, the most widely used of all agile process models
 isExtreme Programming (XP). But many other agile process models have been
 proposed and are in use across the industry. Among the most common are:
 •Adaptive Software Development (ASD)
 •Scrum
 •Dynamic Systems Development Method (DSDM)
 80 PART ONE THE SOFTWARE PROCESS
 Doug: Sure Jamie, what’s up?
 Jamie:We’ve been thinking about our process
 discussion yesterday . . . you know, what process we’re
 going to choose for this new SafeHomeproject.
 Doug:And?
 Vinod: I was talking to a friend at another company,
 and he was telling me about Extreme Programming. It’s
 an agile process model . . . heard of it?
 Doug: Yeah, some good, some bad.
 Jamie:Well, it sounds pretty good to us. Lets you
 develop software really fast, uses something called pair
 programming to do real-time quality checks . . . it’s pretty
 cool, I think.
 Doug: It does have a lot of really good ideas. I like the
 pair-programming concept, for instance, and the idea
 that stakeholders should be part of the team.
 Jamie:Huh? You mean that marketing will work on the
 project team with us?
 Doug (nodding): They’re a stakeholder, aren’t they?
 Jamie: Jeez . . . they’ll be requesting changes every five
 minutes.
 Vinod:Not necessarily. My friend said that there are
 ways to “embrace” changes during an XP project.
 Doug: So you guys think we should use XP?
 Jamie: It’s definitely worth considering.
 Doug: I agree. And even if we choose an incremental
 model as our approach, there’s no reason why we can’t
 incorporate much of what XP has to offer.
 Vinod:Doug, before you said “some good, some bad.”
 What was the “bad”?
 Doug: The thing I don’t like is the way XP downplays
 analysis and design . . . sort of says that writing code is
 where the action is . . . 
(The team members look at one another and smile.)
 Doug: So you agree with the XP approach?
 Jamie (speaking for both):Writing code is what
 we do, Boss!
 Doug (laughing): True, but I’d like to see you spend a
 little less time coding and then recoding and a little more
 time analyzing what has to be done and designing a
 solution that works.
 Vinod:Maybe we can have it both ways, agility with a
 little discipline.
 Doug: I think we can, Vinod. In fact, I’m sure of it.
 uote:
 “Our profession
 goes through
 methodologies like
 a 14-year-old goes
 through clothing.”
 Stephen
 Hawrysh and
 JimRuprecht
 11This is not a bad thing. Before one or more models or methods are accepted as a de facto standard,
 all must contend for the hearts and minds of software engineers. The “winners” evolve into best
 practice, while the “losers” either disappear or merge with the winning models.
81
 CHAPTER 3 AGILE DEVELOPMENT
 • Crystal
 • Feature Drive Development (FDD)
 • Lean Software Development (LSD)
 • Agile Modeling (AM)
 • Agile Unified Process (AUP)
 In the sections that follow, I present a very brief overview of each of these agile
 process models. It is important to note that all agile process models conform (to a
 greater or lesser degree) to the Manifesto for Agile Software Development and the prin
ciples noted in Section 3.3.1. For additional detail, refer to the references noted in
 each subsection or for a survey, examine the “agile software development” entry
 in Wikipedia.12
 3.5.1 Adaptive Software Development (ASD)
 WebRef
 Useful resources for
 ASD can be found at
 www.adaptivesd
 .com.
 Adaptive Software Development (ASD) has been proposed by Jim Highsmith [Hig00] as
 a technique for building complex software and systems. The philosophical under
pinnings of ASD focus on human collaboration and team self-organization.
 Highsmith argues that an agile, adaptive development approach based on collab
oration is “as much a source of order in our complex interactions as discipline and
 engineering.” He defines an ASD “life cycle” (Figure 3.3) that incorporates three
 phases, speculation, collaboration, and learning.
 FIGURE 3.3
 Adaptive
 software
 development
 adaptive cycle planning
 mission statement
 project constraints
 basic requirements
 time-boxed release plan
 Release
 Requirements gathering
 JAD
 mini-specs
 speculation
 software increment
 adjustments for subsequent cycles
 collaboration
 components implemented/tested
 focus groups for feedback
 formal technical reviews
 learning
 postmortems
 12 See http://en.wikipedia.org/wiki/Agile_software_development#Agile_methods.
82
 PART ONE THE SOFTWARE PROCESS
 Effective collaboration
 with your customer will
 only occur if you
 jettison any “us and
 them” attitudes.
 ASD emphasizes
 learning as a key
 element in achieving 
a “self-organizing”
 team.
 WebRef
 Useful Scrum
 information and
 resources can be found
 at www
 .controlchaos.com.
 During speculation, the project is initiated and adaptive cycle planning is con
ducted. Adaptive cycle planning uses project initiation information—the customer’s
 mission statement, project constraints (e.g., delivery dates or user descriptions), and
 basic requirements—to define the set of release cycles (software increments) that
 will be required for the project.
 No matter how complete and farsighted the cycle plan, it will invariably change.
 Based on information obtained at the completion of the first cycle, the plan is re
viewed and adjusted so that planned work better fits the reality in which an ASD
 team is working.
 Motivated people use collaboration in a way that multiplies their talent and cre
ative output beyond their absolute numbers. This approach is a recurring theme in
 all agile methods. But collaboration is not easy. It encompasses communication and
 teamwork, but it also emphasizes individualism, because individual creativity plays
 an important role in collaborative thinking. It is, above all, a matter of trust. People
 working together must trust one another to (1) criticize without animosity, (2) assist
 without resentment, (3) work as hard as or harder than they do, (4) have the skill set
 to contribute to the work at hand, and (5) communicate problems or concerns in a
 way that leads to effective action.
 As members of an ASD team begin to develop the components that are part of an
 adaptive cycle, the emphasis is on “learning” as much as it is on progress toward
 a completed cycle. In fact, Highsmith [Hig00] argues that software developers often
 overestimate their own understanding (of the technology, the process, and the proj
ect) and that learning will help them to improve their level of real understanding.
 ASD teams learn in three ways: focus groups (Chapter 5), technical reviews (Chap
ter 14), and project postmortems.
 The ASD philosophy has merit regardless of the process model that is used. ASD’s
 overall emphasis on the dynamics of self-organizing teams, interpersonal collabo
ration, and individual and team learning yield software project teams that have a
 much higher likelihood of success.
 3.5.2 Scrum
 Scrum (the name is derived from an activity that occurs during a rugby match13) is
 an agile software development method that was conceived by Jeff Sutherland and his
 development team in the early 1990s. In recent years, further development on the
 Scrum methods has been performed by Schwaber and Beedle [Sch01a].
 Scrum principles are consistent with the agile manifesto and are used to guide
 development activities within a process that incorporates the following framework
 activities: requirements, analysis, design, evolution, and delivery. Within each
 13 A group of players forms around the ball and the teammates work together (sometimes violently!)
 to move the ball downfield.
every 24
 hours
 30 days
 Scrum: 15 minute daily meeting.
 Team members respond to basics:
 1) What did you do since last Scrum
 meeting?
 2) Do you have any obstacles?
 3) What will you do before next
 meeting?
 Sprint Backlog:
 Feature(s)
 assigned
 to sprint
 Product Backlog:
 Prioritized product features desired by the customer
 Backlog
 items
 expanded
 by team
 New functionality
 is demonstrated
 at end of sprint
 framework activity, work tasks occur within a process pattern (discussed in the fol
lowing paragraph) called a sprint.The work conducted within a sprint (the number
 of sprints required for each framework activity will vary depending on product com
plexity and size) is adapted to the problem at hand and is defined and often modified
 in real time by the Scrum team. The overall flow of the Scrum process is illustrated
 in Figure 3.4.
 Scrum emphasizes the use of a set of software process patterns [Noy02] that have
 proven effective for projects with tight timelines, changing requirements, and business
 criticality. Each of these process patterns defines a set of development actions:
 Backlog—a prioritized list of project requirements or features that provide busi
ness value for the customer. Items can be added to the backlog at any time (this is
 how changes are introduced). The product manager assesses the backlog and
 updates priorities as required.
 Sprints—consist of work units that are required to achieve a requirement de
fined in the backlog that must be fit into a predefined time-box14(typically 30 days).
 CHAPTER 3 AGILE DEVELOPMENT 83
 14A time-boxis a project management term (see Part 4 of this book) that indicates a period of time
 that has been allocated to accomplish some task.
 FIGURE3.4
 Scrum process
 flow
 Scrum incorporates a
 set of process patterns
 that emphasize project
 priorities,
 compartmentalized
 work units,
 communication, and
 frequent customer
 feedback.
84
 PART ONE THE SOFTWARE PROCESS
 Changes (e.g., backlog work items) are not introduced during the sprint. Hence, the
 sprint allows team members to work in a short-term, but stable environment.
 Scrum meetings—are short (typically 15 minutes) meetings held daily by the Scrum
 team. Three key questions are asked and answered by all team members [Noy02]:
 • What did you do since the last team meeting?
 • What obstacles are you encountering?
 • What do you plan to accomplish by the next team meeting?
 A team leader, called a Scrum master, leads the meeting and assesses the responses
 from each person. The Scrum meeting helps the team to uncover potential problems
 as early as possible. Also, these daily meetings lead to “knowledge socialization”
 [Bee99] and thereby promote a self-organizing team structure.
 Demos—deliver the software increment to the customer so that functionality that
 has been implemented can be demonstrated and evaluated by the customer. It is im
portant to note that the demo may not contain all planned functionality, but rather
 those functions that can be delivered within the time-box that was established.
 Beedle and his colleagues [Bee99] present a comprehensive discussion of these pat
terns in which they state: “Scrum assumes up-front the existence of chaos. . . . ” The
 Scrum process patterns enable a software team to work successfully in a world
 where the elimination of uncertainty is impossible.
 3.5.3 Dynamic Systems Development Method (DSDM)
 WebRef
 Useful resources for
 DSSD can be found at
 www.dsdm.org.
 The Dynamic Systems Development Method (DSDM) [Sta97] is an agile software devel
opment approach that “provides a framework for building and maintaining systems
 which meet tight time constraints through the use of incremental prototyping in a con
trolled project environment” [CCS02]. The DSDM philosophy is borrowed from a mod
ified version of the Pareto principle—80 percent of an application can be delivered in
 20 percent of the time it would take to deliver the complete (100 percent) application.
 DSDM is an iterative software process in which each iteration follows the 80 per
cent rule. That is, only enough work is required for each increment to facilitate
 movement to the next increment. The remaining detail can be completed later when
 more business requirements are known or changes have been requested and
 accommodated.
 The DSDM Consortium (www.dsdm.org) is a worldwide group of member com
panies that collectively take on the role of “keeper” of the method. The consortium
 has defined an agile process model, called the DSDM life cycle that defines three dif
ferent iterative cycles, preceded by two additional life cycle activities:
 Feasibility study—establishes the basic business requirements and constraints
 associated with the application to be built and then assesses whether the applica
tion is a viable candidate for the DSDM process.
85
 CHAPTER 3 AGILE DEVELOPMENT
 DSDM is a process
 framework that can
 adopt the tactics of
 another agile approach
 such as XP.
 Crystal is a family of
 process models with
 the same “genetic
 code” but different
 methods for adapting
 to project
 characteristics.
 Business study—establishes the functional and information requirements that
 will allow the application to provide business value; also, defines the basic
 application architecture and identifies the maintainability requirements for the
 application.
 Functional model iteration—produces a set of incremental prototypes that
 demonstrate functionality for the customer. (Note: All DSDM prototypes are in
tended to evolve into the deliverable application.) The intent during this iterative
 cycle is to gather additional requirements by eliciting feedback from users as they
 exercise the prototype.
 Design and build iteration—revisits prototypes built during functional model
 iteration to ensure that each has been engineered in a manner that will enable it to
 provide operational business value for end users. In some cases, functional model
 iteration and design and build iteration occur concurrently.
 Implementation—places the latest software increment (an “operationalized” pro
totype) into the operational environment. It should be noted that (1) the increment
 may not be 100 percent complete or (2) changes may be requested as the incre
ment is put into place. In either case, DSDM development work continues by
 returning to the functional model iteration activity.
 DSDM can be combined with XP (Section 3.4) to provide a combination approach
 that defines a solid process model (the DSDM life cycle) with the nuts and bolts prac
tices (XP) that are required to build software increments. In addition, the ASD con
cepts of collaboration and self-organizing teams can be adapted to a combined
 process model.
 3.5.4 Crystal
 Alistair Cockburn [Coc05] and Jim Highsmith [Hig02b] created the Crystal family of
 agile methods15 in order to achieve a software development approach that puts a
 premium on “maneuverability” during what Cockburn characterizes as “a resource
limited, cooperative game of invention and communication, with a primary goal of
 delivering useful, working software and a secondary goal of setting up for the next
 game” [Coc02].
 To achieve maneuverability, Cockburn and Highsmith have defined a set of
 methodologies, each with core elements that are common to all, and roles, process
 patterns, work products, and practice that are unique to each. The Crystal family is
 actually a set of example agile processes that have been proven effective for differ
ent types of projects. The intent is to allow agile teams to select the member of the
 crystal family that is most appropriate for their project and environment.
 15 The name “crystal” is derived from the characteristics of geological crystals, each with its own
 color, shape, and hardness.
86
 PART ONE THE SOFTWARE PROCESS
 3.5.5 Feature Driven Development (FDD)
 WebRef
 A wide variety of
 articles and
 presentations on FDD
 can be found at:
 www.featuredrive
 ndevelopment
 .com/.
 Feature Driven Development (FDD) was originally conceived by Peter Coad and his
 colleagues [Coa99] as a practical process model for object-oriented software engi
neering. Stephen Palmer and John Felsing [Pal02] have extended and improved
 Coad’s work, describing an adaptive, agile process that can be applied to moderately
 sized and larger software projects.
 Like other agile approaches, FDD adopts a philosophy that (1) emphasizes col
laboration among people on an FDD team; (2) manages problem and project
 complexity using feature-based decomposition followed by the integration of
 software increments, and (3) communication of technical detail using verbal,
 graphical, and text-based means. FDD emphasizes software quality assurance
 activities by encouraging an incremental development strategy, the use of design
 and code inspections, the application of software quality assurance audits (Chap
ter 16), the collection of metrics, and the use of patterns (for analysis, design, and
 construction).
 In the context of FDD, a feature “is a client-valued function that can be imple
mented in two weeks or less” [Coa99]. The emphasis on the definition of features
 provides the following benefits:
 • Because features are small blocks of deliverable functionality, users can
 describe them more easily; understand how they relate to one another more
 readily; and better review them for ambiguity, error, or omissions.
 • Features can be organized into a hierarchical business-related grouping.
 • Since a feature is the FDD deliverable software increment, the team develops
 operational features every two weeks.
 • Because features are small, their design and code representations are easier
 to inspect effectively.
 • Project planning, scheduling, and tracking are driven by the feature
 hierarchy, rather than an arbitrarily adopted software engineering 
task set.
 Coad and his colleagues [Coa99] suggest the following template for defining a
 feature:
 <action> the <result> <by for of to> a(n) <object>
 where an <object> is “a person, place, or thing (including roles, moments in time or
 intervals of time, or catalog-entry-like descriptions).” Examples of features for an 
e-commerce application might be:
 Add the product to shopping cart
 Display the technical-specifications of the product
 Store the shipping-information for the customer
87
 CHAPTER 3 AGILE DEVELOPMENT
 FIGURE 3.5
 Feature Driven
 Development
 [Coa99] (with
 permission)
 Develop
 an
 Overall
 Model
 Build a
 Features
 List
 Plan
 By
 Feature
 Design
 By
 Feature
 (more shape
 than content)
 A list of features
 grouped into sets
 and subject areas
 A development plan
 Class owners
 Feature Set Owners
 A design
 package
 (sequences)
 Build
 By
 Feature
 Completed
 client-value
 function
 A feature set groups related features into business-related categories and is defined
 [Coa99] as:
 <action><-ing> a(n) <object>
 For example: Making a product sale is a feature set that would encompass the fea
tures noted earlier and others.
 The FDD approach defines five “collaborating” [Coa99] framework activities (in
 FDD these are called “processes”) as shown in Figure 3.5.
 FDD provides greater emphasis on project management guidelines and tech
niques than many other agile methods. As projects grow in size and complexity,
 ad hoc project management is often inadequate. It is essential for developers, their
 managers, and other stakeholders to understand project status—what accomplish
ments have been made and problems have been encountered. If deadline pressure
 is significant, it is critical to determine if software increments (features) are properly
 scheduled. To accomplish this, FDD defines six milestones during the design and
 implementation of a feature: “design walkthrough, design, design inspection, code,
 code inspection, promote to build” [Coa99].
 3.5.6 Lean Software Development (LSD)
 Lean Software Development (LSD) has adapted the principles of lean manufacturing
 to the world of software engineering. The lean principles that inspire the LSD process
 can be summarized ([Pop03], [Pop06a]) as eliminate waste, build quality in, create
 knowledge, defer commitment, deliver fast, respect people, and optimize the whole.
 Each of these principles can be adapted to the software process. For example,
 eliminate waste within the context of an agile software project can be interpreted
 to mean [Das05]: (1) adding no extraneous features or functions, (2) assessing the
 cost and schedule impact of any newly requested requirement, (3) removing any
 superfluous process steps, (4) establishing mechanisms to improve the way team
 members find information, (5) ensuring the testing finds as many errors as possible,
88
 PART ONE THE SOFTWARE PROCESS
 (6) reducing the time required to request and get a decision that affects the software
 or the process that is applied to create it, and (7) streamlining the manner in which
 information is transmitted to all stakeholders involved in the process.
 For a detailed discussion of LSD and pragmatic guidelines for implementing the
 process, you should examine [Pop06a] and [Pop06b].
 3.5.7 Agile Modeling (AM)
 WebRef
 Comprehensive
 information on agile
 modeling can be found
 at: www
 .agilemodeling.com.
 uote:
 “I was in the drug
 store the other day
 trying to get a cold
 medication . . . not
 easy. There’s an
 entire wall of
 products you need.
 You stand there
 going, Well, this
 one is quick acting
 but this is long
 lasting. . . . Which
 is more important,
 the present or the
 future?”
 Jerry Seinfeld
 There are many situations in which software engineers must build large, business
critical systems. The scope and complexity of such systems must be modeled so that
 (1) all constituencies can better understand what needs to be accomplished, (2) the
 problem can be partitioned effectively among the people who must solve it, and
 (3) quality can be assessed as the system is being engineered and built.
 Over the past 30 years, a wide variety of software engineering modeling methods
 and notation have been proposed for analysis and design (both architectural and
 component-level). These methods have merit, but they have proven to be difficult
 to apply and challenging to sustain (over many projects). Part of the problem is the
 “weight” of these modeling methods. By this I mean the volume of notation required,
 the degree of formalism suggested, the sheer size of the models for large projects,
 and the difficulty in maintaining the model(s) as changes occur. Yet analysis and de
sign modeling have substantial benefit for large projects—if for no other reason than
 to make these projects intellectually manageable. Is there an agile approach to soft
ware engineering modeling that might provide an alternative?
 At “The Official Agile Modeling Site,” Scott Ambler [Amb02a] describes agile mod
eling (AM) in the following manner:
 Agile Modeling (AM) is a practice-based methodology for effective modeling and documen
tation of software-based systems. Simply put, Agile Modeling (AM) is a collection of values,
 principles, and practices for modeling software that can be applied on a software develop
ment project in an effective and light-weight manner. Agile models are more effective than
 traditional models because they are just barely good, they don’t have to be perfect.
 Agile modeling adopts all of the values that are consistent with the agile manifesto.
 The agile modeling philosophy recognizes that an agile team must have the courage
 to make decisions that may cause it to reject a design and refactor. The team must
 also have the humility to recognize that technologists do not have all the answers and
 that business experts and other stakeholders should be respected and embraced.
 Although AM suggests a wide array of “core” and “supplementary” modeling prin
ciples, those that make AM unique are [Amb02a]:
 Model with a purpose. A developer who uses AM should have a specific
 goal (e.g., to communicate information to the customer or to help better un
derstand some aspect of the software) in mind before creating the model.
 Once the goal for the model is identified, the type of notation to be used and
 level of detail required will be more obvious.
89
 CHAPTER 3 AGILE DEVELOPMENT
 Use multiple models. There are many different models and notations that
 can be used to describe software. Only a small subset is essential for most
 projects. AM suggests that to provide needed insight, each model should
 present a different aspect of the system and only those models that provide
 value to their intended audience should be used.
 “Traveling light” is an
 appropriate philosophy
 for all software engi
neering work. Build
 only those models that
 provide value … no
 more, no less.
 Travel light. As software engineering work proceeds, keep only those mod
els that will provide long-term value and jettison the rest. Every work product
 that is kept must be maintained as changes occur. This represents work that
 slows the team down. Ambler [Amb02a] notes that “Every time you decide to
 keep a model you trade-off agility for the convenience of having that informa
tion available to your team in an abstract manner (hence potentially enhanc
ing communication within your team as well as with project stakeholders).”
 Content is more important than representation. Modeling should im
part information to its intended audience. A syntactically perfect model that
 imparts little useful content is not as valuable as a model with flawed nota
tion that nevertheless provides valuable content for its audience.
 Know the models and the tools you use to create them. Understand
 the strengths and weaknesses of each model and the tools that are used to
 create it.
 Adapt locally. The modeling approach should be adapted to the needs of
 the agile team.
 A major segment of the software engineering community has adopted the Unified
 Modeling Language (UML)16 as the preferred method for representing analysis and
 design models. The Unified Process (Chapter 2) has been developed to provide a
 framework for the application of UML. Scott Ambler [Amb06] has developed a sim
plified version of the UP that integrates his agile modeling philosophy.
 3.5.8 Agile Unified Process (AUP)
 The Agile Unified Process (AUP) adopts a “serial in the large” and “iterative in the
 small” [Amb06] philosophy for building computer-based systems. By adopting the
 classic UP phased activities—inception, elaboration, construction, and transition—AUP
 provides a serial overlay (i.e., a linear sequence of software engineering activities)
 that enables a team to visualize the overall process flow for a software project. How
ever, within each of the activities, the team iterates to achieve agility and to deliver
 meaningful software increments to end users as rapidly as possible. Each AUP iter
ation addresses the following activities [Amb06]: 
• Modeling. UML representations of the business and problem domains are
 created. However, to stay agile, these models should be “just barely good
 enough” [Amb06] to allow the team to proceed.
 16 A brief tutorial on UML is presented in Appendix 1.
90
 PART ONE THE SOFTWARE PROCESS
 • Implementation. Models are translated into source code.
 • Testing. Like XP, the team designs and executes a series of tests to uncover
 errors and ensure that the source code meets its requirements.
 • Deployment. Like the generic process activity discussed in Chapters 1 and 2,
 deployment in this context focuses on the delivery of a software increment
 and the acquisition of feedback from end users.
 • Configuration and project management. In the context of AUP, configuration
 management (Chapter 22) addresses change management, risk manage
ment, and the control of any persistent work products17 that are produced by
 the team. Project management tracks and controls the progress of the team
 and coordinates team activities.
 • Environment management. Environment management coordinates a process
 infrastructure that includes standards, tools, and other support technology
 available to the team.
 Although the AUP has historical and technical connections to the Unified Modeling
 Language, it is important to note that UML modeling can be using in conjunction
 with any of the agile process models described in Section 3.5.
 SOFTWARE TOOLS
 Agile Development
 Objective: The objective of agile development
 tools is to assist in one or more aspects of agile
 development with an emphasis on facilitating the rapid
 generation of operational software. These tools can also
 be used when prescriptive process models (Chapter 2) are
 applied.
 Mechanics: Tool mechanics vary. In general, agile tool
 sets encompass automated support for project planning,
 use case development and requirements gathering, rapid
 design, code generation, and testing.
 Representative Tools:18
 Note: Because agile development is a hot topic, most
 software tools vendors purport to sell tools that support 
the agile approach. The tools noted here have
 characteristics that make them particularly useful for
 agile projects.
 OnTime, developed by Axosoft (www.axosoft.com),
 provides agile process management support for
 various technical activities within the process.
 Ideogramic UML, developed by Ideogramic
 (www.ideogramic.com) is a UML tool set
 specifically developed for use within an agile 
process.
 Together Tool Set, distributed by Borland
 (www.borland.com), provides a tools suite that
 supports many technical activities within XP and other
 agile processes.
 17 A persistent work product is a model or document or test case produced by the team that will be kept
 for an indeterminate period of time. It will not be discarded once the software increment is
 delivered.
 18 Tools noted here do not represent an endorsement, but rather a sampling of tools in this category.
 In most cases, tool names are trademarked by their respective developers.
91
 CHAPTER 3 AGILE DEVELOPMENT
 3.6 A TOOL SET FOR THE AGILE PROCESS
 The “tool set” that
 supports agile
 processes focuses
 more on people issues
 than it does on
 technology issues.
 Some proponents of the agile philosophy argue that automated software tools (e.g.,
 design tools) should be viewed as a minor supplement to the team’s activities, and
 not at all pivotal to the success of the team. However, Alistair Cockburn [Coc04] sug
gests that tools can have a benefit and that “agile teams stress using tools that per
mit the rapid flow of understanding. Some of those tools are social, starting even at
 the hiring stage. Some tools are technological, helping distributed teams simulate
 being physically present. Many tools are physical, allowing people to manipulate
 them in workshops.”
 Because acquiring the right people (hiring), team collaboration, stakeholder com
munication, and indirect management are key elements in virtually all agile process
 models, Cockburn argues that “tools” that address these issues are critical success
 factors for agility. For example, a hiring “tool” might be the requirement to have a
 prospective team member spend a few hours pair programming with an existing
 member of the team. The “fit” can be assessed immediately.
 Collaborative and communication “tools” are generally low tech and incorporate
 any mechanism (“physical proximity, whiteboards, poster sheets, index cards, and
 sticky notes” [Coc04]) that provides information and coordination among agile de
velopers. Active communication is achieved via the team dynamics (e.g., pair pro
gramming), while passive communication is achieved by “information radiators”
 (e.g., a flat panel display that presents the overall status of different components of
 an increment). Project management tools deemphasize the Gantt chart and replace
 it with earned value charts or “graphs of tests created versus passed . . . other agile
 tools are used to optimize the environment in which the agile team works (e.g., more
 efficient meeting areas), improve the team culture by nurturing social interactions
 (e.g., collocated teams), physical devices (e.g., electronic whiteboards), and process
 enhancement (e.g., pair programming or time-boxing)” [Coc04].
 Are any of these things really tools? They are, if they facilitate the work performed
 by an agile team member and enhance the quality of the end product.
 3.7 SUMMARY
 In a modern economy, market conditions change rapidly, customer and end-user
 needs evolve, and new competitive threats emerge without warning. Practitioners
 must approach software engineering in a manner that allows them to remain agile—
 to define maneuverable, adaptive, lean processes that can accommodate the needs
 of modern business.
 An agile philosophy for software engineering stresses four key issues: the impor
tance of self-organizing teams that have control over the work they perform, com
munication and collaboration between team members and between practitioners
 and their customers, a recognition that change represents an opportunity, and
92
 PART ONE THE SOFTWARE PROCESS
 an emphasis on rapid delivery of software that satisfies the customer. Agile process
 models have been designed to address each of these issues.
 Extreme programming (XP) is the most widely used agile process. Organized as
 four framework activities—planning, design, coding, and testing—XP suggests a
 number of innovative and powerful techniques that allow an agile team to create
 frequent software releases that deliver features and functionality that have been de
scribed and then prioritized by stakeholders.
 Other agile process models also stress human collaboration and team self
organization, but define their own framework activities and select different points of
 emphasis. For example, ASD uses an iterative process that incorporates adaptive
 cycle planning, relatively rigorous requirement gathering methods, and an iterative
 development cycle that incorporates customer focus groups and formal technical re
views as real-time feedback mechanisms. Scrum emphasizes the use of a set of soft
ware process patterns that have proven effective for projects with tight time lines,
 changing requirements, and business criticality. Each process pattern defines a set
 of development tasks and allows the Scrum team to construct a process that is
 adapted to the needs of the project. The Dynamic Systems Development Method
 (DSDM) advocates the use of time-box scheduling and suggests that only enough
 work is required for each software increment to facilitate movement to the next
 increment. Crystal is a family of agile process models that can be adopted to the spe
cific characteristics of a project.
 Feature Driven Development (FDD) is somewhat more “formal” than other agile
 methods, but still maintains agility by focusing the project team on the development
 of features—a client-valued function that can be implemented in two weeks or less.
 Lean Software Development (LSD) has adapted the principles of lean manufacturing
 to the world of software engineering. Agile modeling (AM) suggests that modeling is
 essential for all systems, but that the complexity, type, and size of the model must be
 tuned to the software to be built. The Agile Unified Process (AUP) adopts a “serial in
 the large” and “iterative in the small” philosophy for building software.
 PROBLEMS AND POINTS TO PONDER
 3.1. Reread “The Manifesto for Agile Software Development” at the beginning of this chapter.
 Can you think of a situation in which one or more of the four “values” could get a software team
 into trouble?
 3.2. Describe agility (for software projects) in your own words.
 3.3. Why does an iterative process make it easier to manage change? Is every agile process dis
cussed in this chapter iterative? Is it possible to complete a project in just one iteration and still
 be agile? Explain your answers.
 3.4. Could each of the agile processes be described using the generic framework activities
 noted in Chapter 2? Build a table that maps the generic activities into the activities defined for
 each agile process.
 3.5. Try to come up with one more “agility principle” that would help a software engineering
 team become even more maneuverable.
93
 CHAPTER 3 AGILE DEVELOPMENT
 3.6. Select one agility principle noted in Section 3.3.1 and try to determine whether each of the
 process models presented in this chapter exhibits the principle. [Note: I have presented an
 overview of these process models only, so it may not be possible to determine whether a prin
ciple has been addressed by one or more of the models, unless you do additional research
 (which is not required for this problem).]
 3.7. Why do requirements change so much? After all, don’t people know what they want?
 3.8. Most agile process models recommend face-to-face communication. Yet today, members
 of a software team and their customers may be geographically separated from one another. Do
 you think this implies that geographical separation is something to avoid? Can you think of ways
 to overcome this problem?
 3.9. Write an XP user story that describes the “favorite places” or “bookmarks” feature avail
able on most Web browsers.
 3.10. What is a spike solution in XP?
 3.11. Describe the XP concepts of refactoring and pair programming in your own words.
 3.12. Do a bit more reading and describe what a time-box is. How does this assist an ASD team
 in delivering software increments in a short time period?
 3.13. Do the 80 percent rule in DSDM and the time-boxing approach defined for ASD achieve
 the same result?
 3.14. Using the process pattern template presented in Chapter 2, develop a process pattern for
 any one of the Scrum patterns presented in Section 3.5.2.
 3.15. Why is Crystal called a family of agile methods?
 3.16. Using the FDD feature template described in Section 3.5.5, define a feature set for a Web
 browser. Now develop a set of features for the feature set.
 3.17. Visit the Official Agile Modeling Site and make a complete list of all core and supple
mentary AM principles.
 3.18. The tool set proposed in Section 3.6 supports many of the “soft” aspects of agile meth
ods. Since communication is so important, recommend an actual tool set that might be used to
 enhance communication among stakeholders on an agile team.
 FURTHER READINGS AND INFORMATION SOURCES
 The overall philosophy and underlying principles of agile software development are considered
 in depth in many of the books referenced in the body of this chapter. In addition, books by Shaw
 and Warden (The Art of Agile Development, O’Reilly Media, Inc., 2008), Hunt (Agile Software Con
struction, Springer, 2005), and Carmichael and Haywood (Better Software Faster, Prentice-Hall,
 2002) present useful discussions of the subject. Aguanno (Managing Agile Projects, Multi
Media Publications, 2005), Highsmith (Agile Project Management: Creating Innovative Products,
 Addison-Wesley, 2004), and Larman (Agile and Iterative Development: A Manager’s Guide,
 Addison-Wesley, 2003) present a management overview and consider project management
 issues. Highsmith (Agile Software Development Ecosystems, Addison-Wesley, 2002) presents a
 survey of agile principles, processes, and practices. A worthwhile discussion of the delicate bal
ance between agility and discipline is presented by Booch and his colleagues (Balancing Agility
 and Discipline, Addison-Wesley, 2004).
 Martin (Clean Code: A Handbook of Agile Software Craftsmanship, Prentice-Hall, 2009) pres
ents the principles, patterns, and practices required to develop “clean code” in an agile software
 engineering environment. Leffingwell (Scaling Software Agility: Best Practices for Large Enter
prises, Addison-Wesley, 2007) discusses strategies for scaling up agile practices for large proj
ects. Lippert and Rook (Refactoring in Large Software Projects: Performing Complex Restructurings
 Successfully, Wiley, 2006) discuss the use of refactoring when applied in large, complex systems.
94
 PART ONE THE SOFTWARE PROCESS
 Stamelos and Sfetsos (Agile Software Development Quality Assurance, IGI Global, 2007) discuss
 SQA techniques that conform to the agile philosophy.
 Dozens of books have been written about Extreme Programming over the past decade. Beck
 (Extreme Programming Explained: Embrace Change, 2d ed., Addison-Wesley, 2004) remains the
 definitive treatment of the subject. In addition, Jeffries and his colleagues (Extreme Programming
 Installed, Addison-Wesley, 2000), Succi and Marchesi (Extreme Programming Examined,
 Addison-Wesley, 2001), Newkirk and Martin (Extreme Programming in Practice, Addison-Wesley,
 2001), and Auer and his colleagues (Extreme Programming Applied: Play to Win, Addison-Wesley,
 2001) provide a nuts-and-bolts discussion of XP along with guidance on how best to apply it.
 McBreen (Questioning Extreme Programming, Addison-Wesley, 2003) takes a critical look at XP,
 defining when and where it is appropriate. An in-depth consideration of pair programming is
 presented by McBreen (Pair Programming Illuminated, Addison-Wesley, 2003).
 ASD is addressed in depth by Highsmith [Hig00]. Schwaber (The Enterprise and Scrum,
 Microsoft Press, 2007) discusses the use of Scrum for projects that have a major business
 impact. The nuts and bolts of Scrum are discussed by Schwaber and Beedle (Agile Software
 Development with SCRUM, Prentice-Hall, 2001). Worthwhile treatments of DSDM have been
 written by the DSDM Consortium (DSDM: Business Focused Development, 2d ed., Pearson Edu
cation, 2003) and Stapleton (DSDM: The Method in Practice, Addison-Wesley, 1997). Cockburn
 (Crystal Clear, Addison-Wesley, 2005) presents an excellent overview of the Crystal family of
 processes. Palmer and Felsing [Pal02] present a detailed treatment of FDD. Carmichael and
 Haywood (Better Software Faster, Prentice-Hall, 2002) provides another useful treatment of FDD
 that includes a step-by-step journey through the mechanics of the process. Poppendieck and 
Poppendieck (Lean Development: An Agile Toolkit for Software Development Managers, Addison
Wesley, 2003) provide guidelines for managing and controlling agile projects. Ambler and
 Jeffries (Agile Modeling, Wiley, 2002) discuss AM in some depth.
 A wide variety of information sources on agile software development are available on the
 Internet. An up-to-date list of World Wide Web references that are relevant to the agile process
 can be found at the SEPA website: www.mhhe.com/engcs/compsci/pressman/
 professional/olc/ser.htm.
In 2001, Kent Beck and 16 other noted software developers, writers, and con
sultants [Bec01a] (referred to as the “Agile Alliance”) signed the “Manifesto for
 Agile Software Development.” It stated:
 We are uncovering better ways of developing software by doing it and helping others
 do it. Through this work we have come to value: 
Individuals and interactions over processes and tools
 Working software over comprehensive documentation
 Customer collaboration over contract negotiation
 Responding to change over following a plan
 That is, while there is value in the items on the right, we value the items on the 
left more.
 QUICK
 LOOK
 What is it? Agile software engi
neering combines a philosophy and
 a set of development guidelines. The
 philosophy encourages customer
 satisfaction and early incremental delivery of
 software; small, highly motivated project teams;
 informal methods; minimal software engineer
ing work products; and overall development
 simplicity. The development guidelines stress
 delivery over analysis and design (although
 these activities are not discouraged), and active
 and continuous communication between devel
opers and customers.
 Who does it? Software engineers and other
 project stakeholders (managers, customers, end
 users) work together on an agile team—a team
 that is self-organizing and in control of its own
 destiny. An agile team fosters communication
 and collaboration among all who serve on it.
 Why is it important? The modern business envi
ronment that spawns computer-based systems
 and software products is fast-paced and ever
changing. Agile software engineering repre
sents a reasonable alternative to conventional
 software engineering for certain classes of soft
ware and certain types of software projects. It
 has been demonstrated to deliver successful sys
tems quickly.
 Whatarethesteps? Agiledevelopmentmightbest
 be termed “software engineering lite.” The basic
 framework activities—communication, planning,
 modeling, construction, and deployment—
 remain. But they morph into a minimal task set
 that pushes the project team toward construction
 and delivery (some would argue that this is
 done at the expense of problem analysis and
 solution design).
 What is the work product? Both the customer
 and the software engineer have the same
 view—the only really important work product
 is an operational “software increment” that is
 delivered to the customer on the appropriate
 commitment date.
 How do I ensure that I’ve done it right? If the
 agile team agrees that the process works, and
 the team produces deliverable software
 increments that satisfy the customer, you’ve
 done it right.
 65
66
 PART ONE THE SOFTWARE PROCESS
 FDD . . . . . . . . . .86
 Industrial XP . . .77
 Lean Software
 Development . . .87
 pair 
programming . . .76
 project 
velocity . . . . . . .74
 refactoring . . . . .75
 Scrum . . . . . . . .82
 stories . . . . . . . .74
 XP process . . . . .73
 uote:
 “Agility: 1,
 everything else: 0.”
 Tom DeMarco
 A manifesto is normally associated with an emerging political movement—one
 that attacks the old guard and suggests revolutionary change (hopefully for the
 better). In some ways, that’s exactly what agile development is all about.
 Although the underlying ideas that guide agile development have been with us for
 many years, it has been less than two decades since these ideas have crystallized
 into a “movement.” In essence, agile1 methods were developed in an effort to over
come perceived and actual weaknesses in conventional software engineering. Agile
 development can provide important benefits, but it is not applicable to all projects,
 all products, all people, and all situations. It is also not antithetical to solid software
 engineering practice and can be applied as an overriding philosophy for all software
 work.
 In the modern economy, it is often difficult or impossible to predict how a
 computer-based system (e.g., a Web-based application) will evolve as time passes.
 Market conditions change rapidly, end-user needs evolve, and new competitive
 threats emerge without warning. In many situations, you won’t be able to define
 requirements fully before the project begins. You must be agile enough to respond to
 a fluid business environment.
 Fluidity implies change, and change is expensive. Particularly if it is uncontrolled
 or poorly managed. One of the most compelling characteristics of the agile approach
 is its ability to reduce the costs of change throughout the software process.
 Does this mean that a recognition of challenges posed by modern realities causes
 you to discard valuable software engineering principles, concepts, methods, and
 tools? Absolutely not! Like all engineering disciplines, software engineering contin
ues to evolve. It can be adapted easily to meet the challenges posed by a demand for
 agility.
 In a thought-provoking book on agile software development, Alistair Cockburn
 [Coc02] argues that the prescriptive process models introduced in Chapter 2 have a
 major failing: they forget the frailties of the people who build computer software. Software
 engineers are not robots. They exhibit great variation in working styles; significant dif
ferences in skill level, creativity, orderliness, consistency, and spontaneity. Some com
municate well in written form, others do not. Cockburn argues that process models
 can “deal with people’s common weaknesses with [either] discipline or tolerance” and
 that most prescriptive process models choose discipline. He states: “Because consis
tency in action is a human weakness, high discipline methodologies are fragile.”
 If process models are to work, they must provide a realistic mechanism for en
couraging the discipline that is necessary, or they must be characterized in a man
ner that shows “tolerance” for the people who do software engineering work.
 Invariably, tolerant practices are easier for software people to adopt and sustain, but
 (as Cockburn admits) they may be less productive. Like most things in life, trade-offs
 must be considered.
 1 Agile methods are sometimes referred to as light methods or lean methods.
67
 CHAPTER 3 AGILE DEVELOPMENT
 3.1 WHAT IS AGILITY?
 Just what is agility in the context of software engineering work? Ivar Jacobson
 [Jac02a] provides a useful discussion:
 Agility has become today’s buzzword when describing a modern software process. Every
one is agile. An agile team is a nimble team able to appropriately respond to changes.
 Change is what software development is very much about. Changes in the software be
ing built, changes to the team members, changes because of new technology, changes of
 all kinds that may have an impact on the product they build or the project that creates the
 product. Support for changes should be built-in everything we do in software, something
 we embrace because it is the heart and soul of software. An agile team recognizes that
 software is developed by individuals working in teams and that the skills of these people,
 their ability to collaborate is at the core for the success of the project.
 Don’t make the
 mistake of assuming
 that agility gives you
 license to hack out
 solutions. A process is
 required and discipline
 is essential.
 In Jacobson’s view, the pervasiveness of change is the primary driver for agility. Soft
ware engineers must be quick on their feet if they are to accommodate the rapid
 changes that Jacobson describes.
 But agility is more than an effective response to change. It also encompasses the
 philosophy espoused in the manifesto noted at the beginning of this chapter. It
 encourages team structures and attitudes that make communication (among team
 members, between technologists and business people, between software engineers
 and their managers) more facile. It emphasizes rapid delivery of operational soft
ware and de-emphasizes the importance of intermediate work products (not always
 a good thing); it adopts the customer as a part of the development team and works
 to eliminate the “us and them” attitude that continues to pervade many software
 projects; it recognizes that planning in an uncertain world has its limits and that a
 project plan must be flexible.
 Agility can be applied to any software process. However, to accomplish this, it is
 essential that the process be designed in a way that allows the project team to adapt
 tasks and to streamline them, conduct planning in a way that understands the fluid
ity of an agile development approach, eliminate all but the most essential work prod
ucts and keep them lean, and emphasize an incremental delivery strategy that gets
 working software to the customer as rapidly as feasible for the product type and
 operational environment.
 3.2 AGILITY AND THE COST OF CHANGE
 The conventional wisdom in software development (supported by decades of expe
rience) is that the cost of change increases nonlinearly as a project progresses
 (Figure 3.1, solid black curve). It is relatively easy to accommodate a change when a
 software team is gathering requirements (early in a project). A usage scenario might
 have to be modified, a list of functions may be extended, or a written specification
 can be edited. The costs of doing this work are minimal, and the time required will
68
 PART ONE THE SOFTWARE PROCESS
 FIGURE 3.1
 Change costs
 as a function
 of time in
 development
 uote:
 Development cost
 Cost of change
 using conventional
 software processes
 Cost of change
 using agile processes
 “Agility is dynamic,
 content specific,
 aggressively
 change embracing,
 and growth
 oriented.”
 Idealized cost of change
 using agile process
 Development schedule progress–Steven
 Goldman et al.
 An agile process
 reduces the cost of
 change because
 software is released in
 increments and change
 can be better
 controlled within an
 increment.
 not adversely affect the outcome of the project. But what if we fast-forward a num
ber of months? The team is in the middle of validation testing (something that occurs
 relatively late in the project), and an important stakeholder is requesting a major
 functional change. The change requires a modification to the architectural design of
 the software, the design and construction of three new components, modifications
 to another five components, the design of new tests, and so on. Costs escalate
 quickly, and the time and cost required to ensure that the change is made without
 unintended side effects is nontrivial.
 Proponents of agility (e.g., [Bec00], [Amb04]) argue that a well-designed agile
 process “flattens” the cost of change curve (Figure 3.1, shaded, solid curve), allowing
 a software team to accommodate changes late in a software project without dramatic
 cost and time impact. You’ve already learned that the agile process encompasses in
cremental delivery. When incremental delivery is coupled with other agile practices
 such as continuous unit testing and pair programming (discussed later in this chap
ter), the cost of making a change is attenuated. Although debate about the degree to
 which the cost curve flattens is ongoing, there is evidence [Coc01a] to suggest that a
 significant reduction in the cost of change can be achieved.
 3.3 WHAT IS ANAGILE PROCESS?
 Any agile software process is characterized in a manner that addresses a number of
 key assumptions [Fow02] about the majority of software projects: 
1. It is difficult to predict in advance which software requirements will persist
 and which will change. It is equally difficult to predict how customer
 priorities will change as the project proceeds.
69
 CHAPTER 3 AGILE DEVELOPMENT
 WebRef
 A comprehensive
 collection of articles on
 the agile process 
can be found at
 www.aanpo.org/
 articles/index.
 Although agile
 processes embrace
 change, it is still
 important to examine
 the reasons for
 change.
 Working software is
 important, but don’t
 forget that it must also
 exhibit a variety of
 quality attributes
 including reliability,
 usability, and 
maintainability.
 2. For many types of software, design and construction are interleaved. That is,
 both activities should be performed in tandem so that design models are
 proven as they are created. It is difficult to predict how much design is
 necessary before construction is used to prove the design.
 3. Analysis, design, construction, and testing are not as predictable (from a
 planning point of view) as we might like.
 Given these three assumptions, an important question arises: How do we create a
 process that can manage unpredictability? The answer, as I have already noted, lies
 in process adaptability (to rapidly changing project and technical conditions). An
 agile process, therefore, must be adaptable.
 But continual adaptation without forward progress accomplishes little. Therefore,
 an agile software process must adapt incrementally. To accomplish incremental adap
tation, an agile team requires customer feedback (so that the appropriate adaptations
 can be made). An effective catalyst for customer feedback is an operational prototype
 or a portion of an operational system. Hence, an incremental development strategy
 should be instituted. Software increments (executable prototypes or portions of an op
erational system) must be delivered in short time periods so that adaptation keeps pace
 with change (unpredictability). This iterative approach enables the customer to evalu
ate the software increment regularly, provide necessary feedback to the software team,
 and influence the process adaptations that are made to accommodate the feedback.
 3.3.1 Agility Principles
 The Agile Alliance (see [Agi03], [Fow01]) defines 12 agility principles for those who
 want to achieve agility: 
1. Our highest priority is to satisfy the customer through early and continuous
 delivery of valuable software.
 2. Welcome changing requirements, even late in development. Agile processes
 harness change for the customer’s competitive advantage.
 3. Deliver working software frequently, from a couple of weeks to a couple of
 months, with a preference to the shorter timescale.
 4. Business people and developers must work together daily throughout the
 project.
 5. Build projects around motivated individuals. Give them the environment and
 support they need, and trust them to get the job done.
 6. The most efficient and effective method of conveying information to and
 within a development team is face-to-face conversation.
 7. Working software is the primary measure of progress.
 8. Agile processes promote sustainable development. The sponsors, developers,
 and users should be able to maintain a constant pace indefinitely.
70
 PART ONE THE SOFTWARE PROCESS
 9. Continuous attention to technical excellence and good design enhances
 agility.
 10. Simplicity—the art of maximizing the amount of work not done—is 
essential.
 11. The best architectures, requirements, and designs emerge from self
organizing teams.
 12. At regular intervals, the team reflects on how to become more effective, then
 tunes and adjusts its behavior accordingly.
 Not every agile process model applies these 12 principles with equal weight, and
 some models choose to ignore (or at least downplay) the importance of one or more
 of the principles. However, the principles define an agile spirit that is maintained in
 each of the process models presented in this chapter.
 3.3.2 The Politics of Agile Development
 You don’t have to
 choose between agility
 and software engi
neering. Rather, define
 a software engineering
 approach that is agile.
 There is considerable debate (sometimes strident) about the benefits and applicabil
ity of agile software development as opposed to more conventional software engi
neering processes. Jim Highsmith [Hig02a] (facetiously) states the extremes when he
 characterizes the feeling of the pro-agility camp (“agilists”). “Traditional methodolo
gists are a bunch of stick-in-the-muds who’d rather produce flawless documentation
 than a working system that meets business needs.” As a counterpoint, he states
 (again, facetiously) the position of the traditional software engineering camp: “Light
weight, er, ‘agile’ methodologists are a bunch of glorified hackers who are going to
 be in for a heck of a surprise when they try to scale up their toys into enterprise-wide
 software.”
 Like all software technology arguments, this methodology debate risks degener
ating into a religious war. If warfare breaks out, rational thought disappears and
 beliefs rather than facts guide decision making.
 No one is against agility. The real question is: What is the best way to achieve it?
 As important, how do you build software that meets customers’ needs today and
 exhibits the quality characteristics that will enable it to be extended and scaled to
 meet customers’ needs over the long term?
 There are no absolute answers to either of these questions. Even within the agile
 school itself, there are many proposed process models (Section 3.4), each with a
 subtly different approach to the agility problem. Within each model there is a set of
 “ideas” (agilists are loath to call them “work tasks”) that represent a significant
 departure from traditional software engineering. And yet, many agile concepts are
 simply adaptations of good software engineering concepts. Bottom line: there is
 much that can be gained by considering the best of both schools and virtually
 nothing to be gained by denigrating either approach.
 If you have further interest, see [Hig01], [Hig02a], and [DeM02] for an entertain
ing summary of other important technical and political issues.
71
 CHAPTER 3 AGILE DEVELOPMENT
 uote:
 “Agile methods
 derive much of
 their agility by
 relying on the
 tacit knowledge
 embodied in the
 team, rather than
 writing the
 knowledge down
 in plans.”
 Barry Boehm
 ?
 What key
 traits must
 exist among the
 people on an
 effective software
 team?
 uote:
 “What counts as
 barely sufficient
 for one team is
 either overly
 sufficient or
 insufficient for
 another.”
 Alistair
 Cockburn
 3.3.3 Human Factors
 Proponents of agile software development take great pains to emphasize the impor
tance of “people factors.” As Cockburn and Highsmith [Coc01a] state, “Agile devel
opment focuses on the talents and skills of individuals, molding the process to
 specific people and teams.” The key point in this statement is that the process molds
 to the needs of the people and team, not the other way around.2
 If members of the software team are to drive the characteristics of the process that
 is applied to build software, a number of key traits must exist among the people on
 an agile team and the team itself:
 Competence. In an agile development (as well as software engineering)
 context, “competence” encompasses innate talent, specific software-related
 skills, and overall knowledge of the process that the team has chosen to
 apply. Skill and knowledge of process can and should be taught to all people
 who serve as agile team members.
 Common focus. Although members of the agile team may perform differ
ent tasks and bring different skills to the project, all should be focused on one
 goal—to deliver a working software increment to the customer within the
 time promised. To achieve this goal, the team will also focus on continual
 adaptations (small and large) that will make the process fit the needs of the
 team.
 Collaboration. Software engineering (regardless of process) is about as
sessing, analyzing, and using information that is communicated to the soft
ware team; creating information that will help all stakeholders understand
 the work of the team; and building information (computer software and rele
vant databases) that provides business value for the customer. To accomplish
 these tasks, team members must collaborate—with one another and all other
 stakeholders.
 Decision-making ability. Any good software team (including agile teams)
 must be allowed the freedom to control its own destiny. This implies that the
 team is given autonomy—decision-making authority for both technical and
 project issues.
 Fuzzy problem-solving ability. Software managers must recognize that
 the agile team will continually have to deal with ambiguity and will continu
ally be buffeted by change. In some cases, the team must accept the fact that
 the problem they are solving today may not be the problem that needs to be
 solved tomorrow. However, lessons learned from any problem-solving
 2 Successful software engineering organizations recognize this reality regardless of the process
 model they choose.
72
 PART ONE THE SOFTWARE PROCESS
 A self-organizing team
 is in control of the
 work it performs. The
 team makes its own
 commitments and
 defines plans to
 achieve them.
 activity (including those that solve the wrong problem) may be of benefit to
 the team later in the project.
 Mutual trust and respect. The agile team must become what DeMarco
 and Lister [DeM98] call a “jelled” team (Chapter 24). A jelled team exhibits
 the trust and respect that are necessary to make them “so strongly knit that
 the whole is greater than the sum of the parts.” [DeM98]
 Self-organization. In the context of agile development, self-organization
 implies three things: (1) the agile team organizes itself for the work to be
 done, (2) the team organizes the process to best accommodate its local envi
ronment, (3) the team organizes the work schedule to best achieve delivery
 of the software increment. Self-organization has a number of technical bene
fits, but more importantly, it serves to improve collaboration and boost team
 morale. In essence, the team serves as its own management. Ken Schwaber
 [Sch02] addresses these issues when he writes: “The team selects how much
 work it believes it can perform within the iteration, and the team commits to
 the work. Nothing demotivates a team as much as someone else making
 commitments for it. Nothing motivates a team as much as accepting the
 responsibility for fulfilling commitments that it made itself.”
 3.4 EXTREME PROGRAMMING (XP)
 In order to illustrate an agile process in a bit more detail, I’ll provide you with an
 overview of Extreme Programming (XP), the most widely used approach to agile soft
ware development. Although early work on the ideas and methods associated with
 XP occurred during the late 1980s, the seminal work on the subject has been written
 by Kent Beck [Bec04a]. More recently, a variant of XP, called Industrial XP (IXP) has
 been proposed [Ker05]. IXP refines XP and targets the agile process specifically for
 use within large organizations.
 3.4.1 XP Values
 Beck [Bec04a] defines a set of five values that establish a foundation for all work per
formed as part of XP—communication, simplicity, feedback, courage, and respect. Each
 of these values is used as a driver for specific XP activities, actions, and tasks.
 In order to achieve effective communication between software engineers and
 other stakeholders (e.g., to establish required features and functions for the soft
ware), XP emphasizes close, yet informal (verbal) collaboration between customers
 and developers, the establishment of effective metaphors3 for communicating
 important concepts, continuous feedback, and the avoidance of voluminous docu
mentation as a communication medium.
 3 In the XP context, a metaphor is “a story that everyone—customers, programmers, and managers—
 can tell about how the system works” [Bec04a].
73
 CHAPTER 3 AGILE DEVELOPMENT
 Keep it simple
 whenever you can, but
 recognize that
 continual “refactoring”
 can absorb significant
 time and resources.
 uote:
 “XP is the answer
 to the question,
 ‘How little can we
 do and still build
 great software?’“
 Anonymous
 WebRef
 An excellent overview
 of “rules” for XP can
 be found at www
 .extremeprogramm
 ing.org/rules.html.
 To achieve simplicity, XP restricts developers to design only for immediate needs,
 rather than consider future needs. The intent is to create a simple design that can be
 easily implemented in code). If the design must be improved, it can be refactored4 at
 a later time.
 Feedback is derived from three sources: the implemented software itself, the
 customer, and other software team members. By designing and implementing an
 effective testing strategy (Chapters 17 through 20), the software (via test results) pro
vides the agile team with feedback. XP makes use of the unit test as its primary test
ing tactic. As each class is developed, the team develops a unit test to exercise each
 operation according to its specified functionality. As an increment is delivered to a
 customer, the user stories or use cases (Chapter 5) that are implemented by the
 increment are used as a basis for acceptance tests. The degree to which the software
 implements the output, function, and behavior of the use case is a form of feedback.
 Finally, as new requirements are derived as part of iterative planning, the team pro
vides the customer with rapid feedback regarding cost and schedule impact.
 Beck [Bec04a] argues that strict adherence to certain XP practices demands
 courage. A better word might be discipline. For example, there is often significant
 pressure to design for future requirements. Most software teams succumb, arguing
 that “designing for tomorrow” will save time and effort in the long run. An agile XP
 team must have the discipline (courage) to design for today, recognizing that future
 requirements may change dramatically, thereby demanding substantial rework of
 the design and implemented code.
 By following each of these values, the agile team inculcates respect among it
 members, between other stakeholders and team members, and indirectly, for the
 software itself. As they achieve successful delivery of software increments, the team
 develops growing respect for the XP process.
 3.4.2 The XP Process
 Extreme Programming uses an object-oriented approach (Appendix 2) as its pre
ferred development paradigm and encompasses a set of rules and practices that
 occur within the context of four framework activities: planning, design, coding, and
 testing. Figure 3.2 illustrates the XP process and notes some of the key ideas and
 tasks that are associated with each framework activity. Key XP activities are sum
marized in the paragraphs that follow.
 Planning. The planning activity (also called the planning game) begins with
 listening—a requirements gathering activity that enables the technical members of
 the XP team to understand the business context for the software and to get a broad
 4 Refactoring allows a software engineer to improve the internal structure of a design (or source
 code) without changing its external functionality or behavior. In essence, refactoring can be used
 to improve the efficiency, readability, or performance of a design or the code that implements a
 design.
74
 PART ONE THE SOFTWARE PROCESS
 FIGURE 3.2
 The Extreme
 Programming
 process
 ?
 What is an
 XP “story”?
 WebRef
 A worthwhile XP
 “planning game” can
 be found at:
 c2.com/cgi/
 wiki?planningGame.
 simple design
 CRC cards
 user stories
 values
 acceptance test criteria
 iteration plan
 Release
 spike solutions
 prototypes
 refactoring
 design
 pair programming
 planning
 software increment
 project velocity computed
 unit test
 continuous integration
 acceptance testing
 test
 coding
 feel for required output and major features and functionality. Listening leads to the
 creation of a set of “stories” (also called user stories) that describe required output,
 features, and functionality for software to be built. Each story (similar to use cases
 described in Chapter 5) is written by the customer and is placed on an index card.
 The customer assigns a value (i.e., a priority) to the story based on the overall busi
ness value of the feature or function.5 Members of the XP team then assess each
 story and assign a cost—measured in development weeks—to it. If the story is esti
mated to require more than three development weeks, the customer is asked to split
 the story into smaller stories and the assignment of value and cost occurs again. It
 is important to note that new stories can be written at any time.
 Customers and developers work together to decide how to group stories into the
 next release (the next software increment) to be developed by the XP team. Once a
 basic commitment (agreement on stories to be included, delivery date, and other
 project matters) is made for a release, the XP team orders the stories that will be de
veloped in one of three ways: (1) all stories will be implemented immediately (within
 a few weeks), (2) the stories with highest value will be moved up in the schedule and
 implemented first, or (3) the riskiest stories will be moved up in the schedule and
 implemented first.
 After the first project release (also called a software increment) has been deliv
ered, the XP team computes project velocity. Stated simply, project velocity is the
 5 The value of a story may also be dependent on the presence of another story.
75
 CHAPTER 3 AGILE DEVELOPMENT
 Project velocity is a
 subtle measure of
 team productivity.
 XP deemphasizes the
 importance of design.
 Not everyone agrees.
 In fact, there are times
 when design should be
 emphasized.
 WebRef
 Refactoring techniques
 and tools can be
 found at:
 www.refactoring
 .com.
 number of customer stories implemented during the first release. Project velocity can
 then be used to (1) help estimate delivery dates and schedule for subsequent releases
 and (2) determine whether an overcommitment has been made for all stories across
 the entire development project. If an overcommitment occurs, the content of releases
 is modified or end delivery dates are changed.
 As development work proceeds, the customer can add stories, change the value
 of an existing story, split stories, or eliminate them. The XP team then reconsiders all
 remaining releases and modifies its plans accordingly.
 Design. XP design rigorously follows the KIS (keep it simple) principle. A simple
 design is always preferred over a more complex representation. In addition, the de
sign provides implementation guidance for a story as it is written—nothing less,
 nothing more. The design of extra functionality (because the developer assumes it
 will be required later) is discouraged.6
 XP encourages the use of CRC cards (Chapter 7) as an effective mechanism for
 thinking about the software in an object-oriented context. CRC (class-responsibility
collaborator) cards identify and organize the object-oriented classes7 that are rele
vant to the current software increment. The XP team conducts the design exercise
 using a process similar to the one described in Chapter 8. The CRC cards are the only
 design work product produced as part of the XP process.
 If a difficult design problem is encountered as part of the design of a story, XP rec
ommends the immediate creation of an operational prototype of that portion of the
 design. Called a spike solution, the design prototype is implemented and evaluated.
 The intent is to lower risk when true implementation starts and to validate the orig
inal estimates for the story containing the design problem.
 In the preceding section, we noted that XP encourages refactoring—a construction
 technique that is also a method for design optimization. Fowler [Fow00] describes
 refactoring in the following manner:
 Refactoring is the process of changing a software system in such a way that it does not
 alter the external behavior of the code yet improves the internal structure. It is a disci
plined way to clean up code [and modify/simplify the internal design] that minimizes the
 chances of introducing bugs. In essence, when you refactor you are improving the design
 of the code after it has been written.
 Because XP design uses virtually no notation and produces few, if any, work prod
ucts other than CRC cards and spike solutions, design is viewed as a transient arti
fact that can and should be continually modified as construction proceeds. The intent
 of refactoring is to control these modifications by suggesting small design changes
 6 These design guidelines should be followed in every software engineering method, although there
 are times when sophisticated design notation and terminology may get in the way of simplicity.
 7 Object-oriented classes are discussed in Appendix 2, in Chapter 8, and throughout Part 2 of this
 book.
76
 PART ONE THE SOFTWARE PROCESS
 Refactoring improves
 the internal structure of
 a design (or source
 code) without
 changing its external
 functionality or
 behavior.
 WebRef
 Useful information on
 XP can be obtained 
at www
 .xprogramming.
 com.
 ?
 What is 
pair
 programming?
 Many software teams
 are populated by indi
vidualists. You’ll have
 to work to change that
 culture if pair program
ming is to work effec
tively.
 ?
 XP?
 How are unit
 tests used in
 that “can radically improve the design” [Fow00]. It should be noted, however, that
 the effort required for refactoring can grow dramatically as the size of an application
 grows.
 A central notion in XP is that design occurs both before and after coding com
mences. Refactoring means that design occurs continuously as the system is con
structed. In fact, the construction activity itself will provide the XP team with
 guidance on how to improve the design.
 Coding. After stories are developed and preliminary design work is done, the team
 does not move to code, but rather develops a series of unit tests that will exercise
 each of the stories that is to be included in the current release (software increment).8
 Once the unit test9 has been created, the developer is better able to focus on what
 must be implemented to pass the test. Nothing extraneous is added (KIS). Once the
 code is complete, it can be unit-tested immediately, thereby providing instantaneous
 feedback to the developers.
 A key concept during the coding activity (and one of the most talked about aspects
 of XP) is pair programming. XP recommends that two people work together at one
 computer workstation to create code for a story. This provides a mechanism for real
time problem solving (two heads are often better than one) and real-time quality as
surance (the code is reviewed as it is created). It also keeps the developers focused
 on the problem at hand. In practice, each person takes on a slightly different role. For
 example, one person might think about the coding details of a particular portion of
 the design while the other ensures that coding standards (a required part of XP) are
 being followed or that the code for the story will satisfy the unit test that has been
 developed to validate the code against the story.
 As pair programmers complete their work, the code they develop is integrated
 with the work of others. In some cases this is performed on a daily basis by an inte
gration team. In other cases, the pair programmers have integration responsibility.
 This “continuous integration” strategy helps to avoid compatibility and interfacing
 problems and provides a “smoke testing” environment (Chapter 17) that helps to
 uncover errors early.
 Testing. I have already noted that the creation of unit tests before coding com
mences is a key element of the XP approach. The unit tests that are created should
 be implemented using a framework that enables them to be automated (hence, they
 can be executed easily and repeatedly). This encourages a regression testing strat
egy (Chapter 17) whenever code is modified (which is often, given the XP refactor
ing philosophy).
 8 This approach is analogous to knowing the exam questions before you begin to study. It makes
 studying much easier by focusing attention only on the questions that will be asked.
 9 Unit testing, discussed in detail in Chapter 17, focuses on an individual software component, exer
cising the component’s interface, data structures, and functionality in an effort to uncover errors
 that are local to the component.
77
 CHAPTER 3 AGILE DEVELOPMENT
 XP acceptance tests
 are derived from user
 stories.
 ?
 What new
 practices are
 appended to XP
 to create IXP?
 uote:
 “Ability is what
 you’re capable of
 doing. Motivation
 determines what
 you do. Attitude
 determines how
 well you do it.”
 Lou Holtz
 As the individual unit tests are organized into a “universal testing suite” [Wel99],
 integration and validation testing of the system can occur on a daily basis. This pro
vides the XP team with a continual indication of progress and also can raise warn
ing flags early if things go awry. Wells [Wel99] states: “Fixing small problems every
 few hours takes less time than fixing huge problems just before the deadline.”
 XP acceptance tests, also called customer tests, are specified by the customer and
 focus on overall system features and functionality that are visible and reviewable by
 the customer. Acceptance tests are derived from user stories that have been imple
mented as part of a software release.
 3.4.3 Industrial XP
 Joshua Kerievsky [Ker05] describes Industrial Extreme Programming (IXP) in the fol
lowing manner: “IXP is an organic evolution of XP. It is imbued with XP’s minimal
ist, customer-centric, test-driven spirit. IXP differs most from the original XP in its
 greater inclusion of management, its expanded role for customers, and its upgraded
 technical practices.” IXP incorporates six new practices that are designed to help
 ensure that an XP project works successfully for significant projects within a large
 organization.
 Readiness assessment. Prior to the initiation of an IXP project, the organ
ization should conduct a readiness assessment. The assessment ascertains
 whether (1) an appropriate development environment exists to support IXP,
 (2) the team will be populated by the proper set of stakeholders, (3) the or
ganization has a distinct quality program and supports continuous improve
ment, (4) the organizational culture will support the new values of an agile
 team, and (5) the broader project community will be populated appropriately.
 Project community. Classic XP suggests that the right people be used to
 populate the agile team to ensure success. The implication is that people on
 the team must be well-trained, adaptable and skilled, and have the proper
 temperament to contribute to a self-organizing team. When XP is to be
 applied for a significant project in a large organization, the concept of the
 “team” should morph into that of a community. A community may have a
 technologist and customers who are central to the success of a project as
 well as many other stakeholders (e.g., legal staff, quality auditors, manufac
turing or sales types) who “are often at the periphery of an IXP project yet
 they may play important roles on the project” [Ker05]. In IXP, the community
 members and their roles should be explicitly defined and mechanisms for
 communication and coordination between community members should be
 established.
 Project chartering. The IXP team assesses the project itself to determine
 whether an appropriate business justification for the project exists and
 whether the project will further the overall goals and objectives of the
78
 PART ONE THE SOFTWARE PROCESS
 organization. Chartering also examines the context of the project to deter
mine how it complements, extends, or replaces existing systems or
 processes.
 Test-driven management. An IXP project requires measurable criteria for
 assessing the state of the project and the progress that has been made to
 date. Test-driven management establishes a series of measurable “destina
tions” [Ker05] and then defines mechanisms for determining whether or not
 these destinations have been reached.
 Retrospectives. An IXP team conducts a specialized technical review
 (Chapter 15) after a software increment is delivered. Called a retrospective,
 the review examines “issues, events, and lessons-learned” [Ker05] across a
 software increment and/or the entire software release. The intent is to
 improve the IXP process.
 Continuous learning. Because learning is a vital part of continuous
 process improvement, members of the XP team are encouraged (and possi
bly, incented) to learn new methods and techniques that can lead to a higher
quality product.
 In addition to the six new practices discussed, IXP modifies a number of existing
 XP practices. Story-driven development (SDD) insists that stories for acceptance tests
 be written before a single line of code is generated. Domain-driven design (DDD) is
 an improvement on the “system metaphor” concept used in XP. DDD [Eva03] sug
gests the evolutionary creation of a domain model that “accurately represents how
 domain experts think about their subject” [Ker05]. Pairing extends the XP pair
programming concept to include managers and other stakeholders. The intent is to
 improve knowledge sharing among XP team members who may not be directly in
volved in technical development. Iterative usability discourages front-loaded inter
face design in favor of usability design that evolves as software increments are
 delivered and users’ interaction with the software is studied.
 IXP makes smaller modifications to other XP practices and redefines certain roles
 and responsibilities to make them more amenable to significant projects for large
 organizations. For further discussion of IXP, visit http://industrialxp.org.
 3.4.4 The XP Debate
 All new process models and methods spur worthwhile discussion and in some in
stances heated debate. Extreme Programming has done both. In an interesting book
 that examines the efficacy of XP, Stephens and Rosenberg [Ste03] argue that many
 XP practices are worthwhile, but others have been overhyped, and a few are prob
lematic. The authors suggest that the codependent nature of XP practices are both
 its strength and its weakness. Because many organizations adopt only a subset of XP
 practices, they weaken the efficacy of the entire process. Proponents counter that
 XP is continuously evolving and that many of the issues raised by critics have been
79
 CHAPTER 3 AGILE DEVELOPMENT
 addressed as XP practice matures. Among the issues that continue to trouble some
 critics of XP are:10
 ?
 What are
 some of the
 issues that lead to
 an XP debate?
 • Requirements volatility. Because the customer is an active member of the XP
 team, changes to requirements are requested informally. As a consequence,
 the scope of the project can change and earlier work may have to be
 modified to accommodate current needs. Proponents argue that this happens
 regardless of the process that is applied and that XP provides mechanisms for
 controlling scope creep.
 • Conflicting customer needs. Many projects have multiple customers, each with
 his own set of needs. In XP, the team itself is tasked with assimilating the
 needs of different customers, a job that may be beyond their scope of
 authority.
 • Requirements are expressed informally. User stories and acceptance tests are
 the only explicit manifestation of requirements in XP. Critics argue that a
 more formal model or specification is often needed to ensure that omissions,
 inconsistencies, and errors are uncovered before the system is built. Propo
nents counter that the changing nature of requirements makes such models
 and specification obsolete almost as soon as they are developed.
 • Lack of formal design. XP deemphasizes the need for architectural design and
 in many instances, suggests that design of all kinds should be relatively
 informal. Critics argue that when complex systems are built, design must be
 emphasized to ensure that the overall structure of the software will exhibit
 quality and maintainability. XP proponents suggest that the incremental
 nature of the XP process limits complexity (simplicity is a core value) and
 therefore reduces the need for extensive design.
 You should note that every software process has flaws and that many software or
ganizations have used XP successfully. The key is to recognize where a process may
 have weaknesses and to adapt it to the specific needs of your organization.
 SAFEHOME
 Considering Agile Software Development
 The scene: Doug Miller’s office.
 The Players: Doug Miller, software engineering
 manager; Jamie Lazar, software team member; Vinod
 Raman, software team member.
 The conversation:
 (A knock on the door, Jamie and Vinod enter Doug’s office)
 Jamie: Doug, you got a minute?
 10 For a detailed look at some thoughtful criticism that has been leveled at XP, visit
 www.softwarereality.com/ExtremeProgramming.jsp.
3.5 OTHERAGILEPROCESSMODELS
 The history of software engineering is littered with dozens of obsolete process
 descriptions and methodologies, modeling methods and notations, tools, and
 technology. Each flared in notoriety and was then eclipsed by something new and
 (purportedly) better. With the introduction of a wide array of agile process models—
 each contending for acceptance within the software development community—the
 agile movement is following the same historical path.11
 As I noted in the last section, the most widely used of all agile process models
 isExtreme Programming (XP). But many other agile process models have been
 proposed and are in use across the industry. Among the most common are:
 •Adaptive Software Development (ASD)
 •Scrum
 •Dynamic Systems Development Method (DSDM)
 80 PART ONE THE SOFTWARE PROCESS
 Doug: Sure Jamie, what’s up?
 Jamie:We’ve been thinking about our process
 discussion yesterday . . . you know, what process we’re
 going to choose for this new SafeHomeproject.
 Doug:And?
 Vinod: I was talking to a friend at another company,
 and he was telling me about Extreme Programming. It’s
 an agile process model . . . heard of it?
 Doug: Yeah, some good, some bad.
 Jamie:Well, it sounds pretty good to us. Lets you
 develop software really fast, uses something called pair
 programming to do real-time quality checks . . . it’s pretty
 cool, I think.
 Doug: It does have a lot of really good ideas. I like the
 pair-programming concept, for instance, and the idea
 that stakeholders should be part of the team.
 Jamie:Huh? You mean that marketing will work on the
 project team with us?
 Doug (nodding): They’re a stakeholder, aren’t they?
 Jamie: Jeez . . . they’ll be requesting changes every five
 minutes.
 Vinod:Not necessarily. My friend said that there are
 ways to “embrace” changes during an XP project.
 Doug: So you guys think we should use XP?
 Jamie: It’s definitely worth considering.
 Doug: I agree. And even if we choose an incremental
 model as our approach, there’s no reason why we can’t
 incorporate much of what XP has to offer.
 Vinod:Doug, before you said “some good, some bad.”
 What was the “bad”?
 Doug: The thing I don’t like is the way XP downplays
 analysis and design . . . sort of says that writing code is
 where the action is . . . 
(The team members look at one another and smile.)
 Doug: So you agree with the XP approach?
 Jamie (speaking for both):Writing code is what
 we do, Boss!
 Doug (laughing): True, but I’d like to see you spend a
 little less time coding and then recoding and a little more
 time analyzing what has to be done and designing a
 solution that works.
 Vinod:Maybe we can have it both ways, agility with a
 little discipline.
 Doug: I think we can, Vinod. In fact, I’m sure of it.
 uote:
 “Our profession
 goes through
 methodologies like
 a 14-year-old goes
 through clothing.”
 Stephen
 Hawrysh and
 JimRuprecht
 11This is not a bad thing. Before one or more models or methods are accepted as a de facto standard,
 all must contend for the hearts and minds of software engineers. The “winners” evolve into best
 practice, while the “losers” either disappear or merge with the winning models.
81
 CHAPTER 3 AGILE DEVELOPMENT
 • Crystal
 • Feature Drive Development (FDD)
 • Lean Software Development (LSD)
 • Agile Modeling (AM)
 • Agile Unified Process (AUP)
 In the sections that follow, I present a very brief overview of each of these agile
 process models. It is important to note that all agile process models conform (to a
 greater or lesser degree) to the Manifesto for Agile Software Development and the prin
ciples noted in Section 3.3.1. For additional detail, refer to the references noted in
 each subsection or for a survey, examine the “agile software development” entry
 in Wikipedia.12
 3.5.1 Adaptive Software Development (ASD)
 WebRef
 Useful resources for
 ASD can be found at
 www.adaptivesd
 .com.
 Adaptive Software Development (ASD) has been proposed by Jim Highsmith [Hig00] as
 a technique for building complex software and systems. The philosophical under
pinnings of ASD focus on human collaboration and team self-organization.
 Highsmith argues that an agile, adaptive development approach based on collab
oration is “as much a source of order in our complex interactions as discipline and
 engineering.” He defines an ASD “life cycle” (Figure 3.3) that incorporates three
 phases, speculation, collaboration, and learning.
 FIGURE 3.3
 Adaptive
 software
 development
 adaptive cycle planning
 mission statement
 project constraints
 basic requirements
 time-boxed release plan
 Release
 Requirements gathering
 JAD
 mini-specs
 speculation
 software increment
 adjustments for subsequent cycles
 collaboration
 components implemented/tested
 focus groups for feedback
 formal technical reviews
 learning
 postmortems
 12 See http://en.wikipedia.org/wiki/Agile_software_development#Agile_methods.
82
 PART ONE THE SOFTWARE PROCESS
 Effective collaboration
 with your customer will
 only occur if you
 jettison any “us and
 them” attitudes.
 ASD emphasizes
 learning as a key
 element in achieving 
a “self-organizing”
 team.
 WebRef
 Useful Scrum
 information and
 resources can be found
 at www
 .controlchaos.com.
 During speculation, the project is initiated and adaptive cycle planning is con
ducted. Adaptive cycle planning uses project initiation information—the customer’s
 mission statement, project constraints (e.g., delivery dates or user descriptions), and
 basic requirements—to define the set of release cycles (software increments) that
 will be required for the project.
 No matter how complete and farsighted the cycle plan, it will invariably change.
 Based on information obtained at the completion of the first cycle, the plan is re
viewed and adjusted so that planned work better fits the reality in which an ASD
 team is working.
 Motivated people use collaboration in a way that multiplies their talent and cre
ative output beyond their absolute numbers. This approach is a recurring theme in
 all agile methods. But collaboration is not easy. It encompasses communication and
 teamwork, but it also emphasizes individualism, because individual creativity plays
 an important role in collaborative thinking. It is, above all, a matter of trust. People
 working together must trust one another to (1) criticize without animosity, (2) assist
 without resentment, (3) work as hard as or harder than they do, (4) have the skill set
 to contribute to the work at hand, and (5) communicate problems or concerns in a
 way that leads to effective action.
 As members of an ASD team begin to develop the components that are part of an
 adaptive cycle, the emphasis is on “learning” as much as it is on progress toward
 a completed cycle. In fact, Highsmith [Hig00] argues that software developers often
 overestimate their own understanding (of the technology, the process, and the proj
ect) and that learning will help them to improve their level of real understanding.
 ASD teams learn in three ways: focus groups (Chapter 5), technical reviews (Chap
ter 14), and project postmortems.
 The ASD philosophy has merit regardless of the process model that is used. ASD’s
 overall emphasis on the dynamics of self-organizing teams, interpersonal collabo
ration, and individual and team learning yield software project teams that have a
 much higher likelihood of success.
 3.5.2 Scrum
 Scrum (the name is derived from an activity that occurs during a rugby match13) is
 an agile software development method that was conceived by Jeff Sutherland and his
 development team in the early 1990s. In recent years, further development on the
 Scrum methods has been performed by Schwaber and Beedle [Sch01a].
 Scrum principles are consistent with the agile manifesto and are used to guide
 development activities within a process that incorporates the following framework
 activities: requirements, analysis, design, evolution, and delivery. Within each
 13 A group of players forms around the ball and the teammates work together (sometimes violently!)
 to move the ball downfield.
every 24
 hours
 30 days
 Scrum: 15 minute daily meeting.
 Team members respond to basics:
 1) What did you do since last Scrum
 meeting?
 2) Do you have any obstacles?
 3) What will you do before next
 meeting?
 Sprint Backlog:
 Feature(s)
 assigned
 to sprint
 Product Backlog:
 Prioritized product features desired by the customer
 Backlog
 items
 expanded
 by team
 New functionality
 is demonstrated
 at end of sprint
 framework activity, work tasks occur within a process pattern (discussed in the fol
lowing paragraph) called a sprint.The work conducted within a sprint (the number
 of sprints required for each framework activity will vary depending on product com
plexity and size) is adapted to the problem at hand and is defined and often modified
 in real time by the Scrum team. The overall flow of the Scrum process is illustrated
 in Figure 3.4.
 Scrum emphasizes the use of a set of software process patterns [Noy02] that have
 proven effective for projects with tight timelines, changing requirements, and business
 criticality. Each of these process patterns defines a set of development actions:
 Backlog—a prioritized list of project requirements or features that provide busi
ness value for the customer. Items can be added to the backlog at any time (this is
 how changes are introduced). The product manager assesses the backlog and
 updates priorities as required.
 Sprints—consist of work units that are required to achieve a requirement de
fined in the backlog that must be fit into a predefined time-box14(typically 30 days).
 CHAPTER 3 AGILE DEVELOPMENT 83
 14A time-boxis a project management term (see Part 4 of this book) that indicates a period of time
 that has been allocated to accomplish some task.
 FIGURE3.4
 Scrum process
 flow
 Scrum incorporates a
 set of process patterns
 that emphasize project
 priorities,
 compartmentalized
 work units,
 communication, and
 frequent customer
 feedback.
84
 PART ONE THE SOFTWARE PROCESS
 Changes (e.g., backlog work items) are not introduced during the sprint. Hence, the
 sprint allows team members to work in a short-term, but stable environment.
 Scrum meetings—are short (typically 15 minutes) meetings held daily by the Scrum
 team. Three key questions are asked and answered by all team members [Noy02]:
 • What did you do since the last team meeting?
 • What obstacles are you encountering?
 • What do you plan to accomplish by the next team meeting?
 A team leader, called a Scrum master, leads the meeting and assesses the responses
 from each person. The Scrum meeting helps the team to uncover potential problems
 as early as possible. Also, these daily meetings lead to “knowledge socialization”
 [Bee99] and thereby promote a self-organizing team structure.
 Demos—deliver the software increment to the customer so that functionality that
 has been implemented can be demonstrated and evaluated by the customer. It is im
portant to note that the demo may not contain all planned functionality, but rather
 those functions that can be delivered within the time-box that was established.
 Beedle and his colleagues [Bee99] present a comprehensive discussion of these pat
terns in which they state: “Scrum assumes up-front the existence of chaos. . . . ” The
 Scrum process patterns enable a software team to work successfully in a world
 where the elimination of uncertainty is impossible.
 3.5.3 Dynamic Systems Development Method (DSDM)
 WebRef
 Useful resources for
 DSSD can be found at
 www.dsdm.org.
 The Dynamic Systems Development Method (DSDM) [Sta97] is an agile software devel
opment approach that “provides a framework for building and maintaining systems
 which meet tight time constraints through the use of incremental prototyping in a con
trolled project environment” [CCS02]. The DSDM philosophy is borrowed from a mod
ified version of the Pareto principle—80 percent of an application can be delivered in
 20 percent of the time it would take to deliver the complete (100 percent) application.
 DSDM is an iterative software process in which each iteration follows the 80 per
cent rule. That is, only enough work is required for each increment to facilitate
 movement to the next increment. The remaining detail can be completed later when
 more business requirements are known or changes have been requested and
 accommodated.
 The DSDM Consortium (www.dsdm.org) is a worldwide group of member com
panies that collectively take on the role of “keeper” of the method. The consortium
 has defined an agile process model, called the DSDM life cycle that defines three dif
ferent iterative cycles, preceded by two additional life cycle activities:
 Feasibility study—establishes the basic business requirements and constraints
 associated with the application to be built and then assesses whether the applica
tion is a viable candidate for the DSDM process.
85
 CHAPTER 3 AGILE DEVELOPMENT
 DSDM is a process
 framework that can
 adopt the tactics of
 another agile approach
 such as XP.
 Crystal is a family of
 process models with
 the same “genetic
 code” but different
 methods for adapting
 to project
 characteristics.
 Business study—establishes the functional and information requirements that
 will allow the application to provide business value; also, defines the basic
 application architecture and identifies the maintainability requirements for the
 application.
 Functional model iteration—produces a set of incremental prototypes that
 demonstrate functionality for the customer. (Note: All DSDM prototypes are in
tended to evolve into the deliverable application.) The intent during this iterative
 cycle is to gather additional requirements by eliciting feedback from users as they
 exercise the prototype.
 Design and build iteration—revisits prototypes built during functional model
 iteration to ensure that each has been engineered in a manner that will enable it to
 provide operational business value for end users. In some cases, functional model
 iteration and design and build iteration occur concurrently.
 Implementation—places the latest software increment (an “operationalized” pro
totype) into the operational environment. It should be noted that (1) the increment
 may not be 100 percent complete or (2) changes may be requested as the incre
ment is put into place. In either case, DSDM development work continues by
 returning to the functional model iteration activity.
 DSDM can be combined with XP (Section 3.4) to provide a combination approach
 that defines a solid process model (the DSDM life cycle) with the nuts and bolts prac
tices (XP) that are required to build software increments. In addition, the ASD con
cepts of collaboration and self-organizing teams can be adapted to a combined
 process model.
 3.5.4 Crystal
 Alistair Cockburn [Coc05] and Jim Highsmith [Hig02b] created the Crystal family of
 agile methods15 in order to achieve a software development approach that puts a
 premium on “maneuverability” during what Cockburn characterizes as “a resource
limited, cooperative game of invention and communication, with a primary goal of
 delivering useful, working software and a secondary goal of setting up for the next
 game” [Coc02].
 To achieve maneuverability, Cockburn and Highsmith have defined a set of
 methodologies, each with core elements that are common to all, and roles, process
 patterns, work products, and practice that are unique to each. The Crystal family is
 actually a set of example agile processes that have been proven effective for differ
ent types of projects. The intent is to allow agile teams to select the member of the
 crystal family that is most appropriate for their project and environment.
 15 The name “crystal” is derived from the characteristics of geological crystals, each with its own
 color, shape, and hardness.
86
 PART ONE THE SOFTWARE PROCESS
 3.5.5 Feature Driven Development (FDD)
 WebRef
 A wide variety of
 articles and
 presentations on FDD
 can be found at:
 www.featuredrive
 ndevelopment
 .com/.
 Feature Driven Development (FDD) was originally conceived by Peter Coad and his
 colleagues [Coa99] as a practical process model for object-oriented software engi
neering. Stephen Palmer and John Felsing [Pal02] have extended and improved
 Coad’s work, describing an adaptive, agile process that can be applied to moderately
 sized and larger software projects.
 Like other agile approaches, FDD adopts a philosophy that (1) emphasizes col
laboration among people on an FDD team; (2) manages problem and project
 complexity using feature-based decomposition followed by the integration of
 software increments, and (3) communication of technical detail using verbal,
 graphical, and text-based means. FDD emphasizes software quality assurance
 activities by encouraging an incremental development strategy, the use of design
 and code inspections, the application of software quality assurance audits (Chap
ter 16), the collection of metrics, and the use of patterns (for analysis, design, and
 construction).
 In the context of FDD, a feature “is a client-valued function that can be imple
mented in two weeks or less” [Coa99]. The emphasis on the definition of features
 provides the following benefits:
 • Because features are small blocks of deliverable functionality, users can
 describe them more easily; understand how they relate to one another more
 readily; and better review them for ambiguity, error, or omissions.
 • Features can be organized into a hierarchical business-related grouping.
 • Since a feature is the FDD deliverable software increment, the team develops
 operational features every two weeks.
 • Because features are small, their design and code representations are easier
 to inspect effectively.
 • Project planning, scheduling, and tracking are driven by the feature
 hierarchy, rather than an arbitrarily adopted software engineering 
task set.
 Coad and his colleagues [Coa99] suggest the following template for defining a
 feature:
 <action> the <result> <by for of to> a(n) <object>
 where an <object> is “a person, place, or thing (including roles, moments in time or
 intervals of time, or catalog-entry-like descriptions).” Examples of features for an 
e-commerce application might be:
 Add the product to shopping cart
 Display the technical-specifications of the product
 Store the shipping-information for the customer
87
 CHAPTER 3 AGILE DEVELOPMENT
 FIGURE 3.5
 Feature Driven
 Development
 [Coa99] (with
 permission)
 Develop
 an
 Overall
 Model
 Build a
 Features
 List
 Plan
 By
 Feature
 Design
 By
 Feature
 (more shape
 than content)
 A list of features
 grouped into sets
 and subject areas
 A development plan
 Class owners
 Feature Set Owners
 A design
 package
 (sequences)
 Build
 By
 Feature
 Completed
 client-value
 function
 A feature set groups related features into business-related categories and is defined
 [Coa99] as:
 <action><-ing> a(n) <object>
 For example: Making a product sale is a feature set that would encompass the fea
tures noted earlier and others.
 The FDD approach defines five “collaborating” [Coa99] framework activities (in
 FDD these are called “processes”) as shown in Figure 3.5.
 FDD provides greater emphasis on project management guidelines and tech
niques than many other agile methods. As projects grow in size and complexity,
 ad hoc project management is often inadequate. It is essential for developers, their
 managers, and other stakeholders to understand project status—what accomplish
ments have been made and problems have been encountered. If deadline pressure
 is significant, it is critical to determine if software increments (features) are properly
 scheduled. To accomplish this, FDD defines six milestones during the design and
 implementation of a feature: “design walkthrough, design, design inspection, code,
 code inspection, promote to build” [Coa99].
 3.5.6 Lean Software Development (LSD)
 Lean Software Development (LSD) has adapted the principles of lean manufacturing
 to the world of software engineering. The lean principles that inspire the LSD process
 can be summarized ([Pop03], [Pop06a]) as eliminate waste, build quality in, create
 knowledge, defer commitment, deliver fast, respect people, and optimize the whole.
 Each of these principles can be adapted to the software process. For example,
 eliminate waste within the context of an agile software project can be interpreted
 to mean [Das05]: (1) adding no extraneous features or functions, (2) assessing the
 cost and schedule impact of any newly requested requirement, (3) removing any
 superfluous process steps, (4) establishing mechanisms to improve the way team
 members find information, (5) ensuring the testing finds as many errors as possible,
88
 PART ONE THE SOFTWARE PROCESS
 (6) reducing the time required to request and get a decision that affects the software
 or the process that is applied to create it, and (7) streamlining the manner in which
 information is transmitted to all stakeholders involved in the process.
 For a detailed discussion of LSD and pragmatic guidelines for implementing the
 process, you should examine [Pop06a] and [Pop06b].
 3.5.7 Agile Modeling (AM)
 WebRef
 Comprehensive
 information on agile
 modeling can be found
 at: www
 .agilemodeling.com.
 uote:
 “I was in the drug
 store the other day
 trying to get a cold
 medication . . . not
 easy. There’s an
 entire wall of
 products you need.
 You stand there
 going, Well, this
 one is quick acting
 but this is long
 lasting. . . . Which
 is more important,
 the present or the
 future?”
 Jerry Seinfeld
 There are many situations in which software engineers must build large, business
critical systems. The scope and complexity of such systems must be modeled so that
 (1) all constituencies can better understand what needs to be accomplished, (2) the
 problem can be partitioned effectively among the people who must solve it, and
 (3) quality can be assessed as the system is being engineered and built.
 Over the past 30 years, a wide variety of software engineering modeling methods
 and notation have been proposed for analysis and design (both architectural and
 component-level). These methods have merit, but they have proven to be difficult
 to apply and challenging to sustain (over many projects). Part of the problem is the
 “weight” of these modeling methods. By this I mean the volume of notation required,
 the degree of formalism suggested, the sheer size of the models for large projects,
 and the difficulty in maintaining the model(s) as changes occur. Yet analysis and de
sign modeling have substantial benefit for large projects—if for no other reason than
 to make these projects intellectually manageable. Is there an agile approach to soft
ware engineering modeling that might provide an alternative?
 At “The Official Agile Modeling Site,” Scott Ambler [Amb02a] describes agile mod
eling (AM) in the following manner:
 Agile Modeling (AM) is a practice-based methodology for effective modeling and documen
tation of software-based systems. Simply put, Agile Modeling (AM) is a collection of values,
 principles, and practices for modeling software that can be applied on a software develop
ment project in an effective and light-weight manner. Agile models are more effective than
 traditional models because they are just barely good, they don’t have to be perfect.
 Agile modeling adopts all of the values that are consistent with the agile manifesto.
 The agile modeling philosophy recognizes that an agile team must have the courage
 to make decisions that may cause it to reject a design and refactor. The team must
 also have the humility to recognize that technologists do not have all the answers and
 that business experts and other stakeholders should be respected and embraced.
 Although AM suggests a wide array of “core” and “supplementary” modeling prin
ciples, those that make AM unique are [Amb02a]:
 Model with a purpose. A developer who uses AM should have a specific
 goal (e.g., to communicate information to the customer or to help better un
derstand some aspect of the software) in mind before creating the model.
 Once the goal for the model is identified, the type of notation to be used and
 level of detail required will be more obvious.
89
 CHAPTER 3 AGILE DEVELOPMENT
 Use multiple models. There are many different models and notations that
 can be used to describe software. Only a small subset is essential for most
 projects. AM suggests that to provide needed insight, each model should
 present a different aspect of the system and only those models that provide
 value to their intended audience should be used.
 “Traveling light” is an
 appropriate philosophy
 for all software engi
neering work. Build
 only those models that
 provide value … no
 more, no less.
 Travel light. As software engineering work proceeds, keep only those mod
els that will provide long-term value and jettison the rest. Every work product
 that is kept must be maintained as changes occur. This represents work that
 slows the team down. Ambler [Amb02a] notes that “Every time you decide to
 keep a model you trade-off agility for the convenience of having that informa
tion available to your team in an abstract manner (hence potentially enhanc
ing communication within your team as well as with project stakeholders).”
 Content is more important than representation. Modeling should im
part information to its intended audience. A syntactically perfect model that
 imparts little useful content is not as valuable as a model with flawed nota
tion that nevertheless provides valuable content for its audience.
 Know the models and the tools you use to create them. Understand
 the strengths and weaknesses of each model and the tools that are used to
 create it.
 Adapt locally. The modeling approach should be adapted to the needs of
 the agile team.
 A major segment of the software engineering community has adopted the Unified
 Modeling Language (UML)16 as the preferred method for representing analysis and
 design models. The Unified Process (Chapter 2) has been developed to provide a
 framework for the application of UML. Scott Ambler [Amb06] has developed a sim
plified version of the UP that integrates his agile modeling philosophy.
 3.5.8 Agile Unified Process (AUP)
 The Agile Unified Process (AUP) adopts a “serial in the large” and “iterative in the
 small” [Amb06] philosophy for building computer-based systems. By adopting the
 classic UP phased activities—inception, elaboration, construction, and transition—AUP
 provides a serial overlay (i.e., a linear sequence of software engineering activities)
 that enables a team to visualize the overall process flow for a software project. How
ever, within each of the activities, the team iterates to achieve agility and to deliver
 meaningful software increments to end users as rapidly as possible. Each AUP iter
ation addresses the following activities [Amb06]: 
• Modeling. UML representations of the business and problem domains are
 created. However, to stay agile, these models should be “just barely good
 enough” [Amb06] to allow the team to proceed.
 16 A brief tutorial on UML is presented in Appendix 1.
90
 PART ONE THE SOFTWARE PROCESS
 • Implementation. Models are translated into source code.
 • Testing. Like XP, the team designs and executes a series of tests to uncover
 errors and ensure that the source code meets its requirements.
 • Deployment. Like the generic process activity discussed in Chapters 1 and 2,
 deployment in this context focuses on the delivery of a software increment
 and the acquisition of feedback from end users.
 • Configuration and project management. In the context of AUP, configuration
 management (Chapter 22) addresses change management, risk manage
ment, and the control of any persistent work products17 that are produced by
 the team. Project management tracks and controls the progress of the team
 and coordinates team activities.
 • Environment management. Environment management coordinates a process
 infrastructure that includes standards, tools, and other support technology
 available to the team.
 Although the AUP has historical and technical connections to the Unified Modeling
 Language, it is important to note that UML modeling can be using in conjunction
 with any of the agile process models described in Section 3.5.
 SOFTWARE TOOLS
 Agile Development
 Objective: The objective of agile development
 tools is to assist in one or more aspects of agile
 development with an emphasis on facilitating the rapid
 generation of operational software. These tools can also
 be used when prescriptive process models (Chapter 2) are
 applied.
 Mechanics: Tool mechanics vary. In general, agile tool
 sets encompass automated support for project planning,
 use case development and requirements gathering, rapid
 design, code generation, and testing.
 Representative Tools:18
 Note: Because agile development is a hot topic, most
 software tools vendors purport to sell tools that support 
the agile approach. The tools noted here have
 characteristics that make them particularly useful for
 agile projects.
 OnTime, developed by Axosoft (www.axosoft.com),
 provides agile process management support for
 various technical activities within the process.
 Ideogramic UML, developed by Ideogramic
 (www.ideogramic.com) is a UML tool set
 specifically developed for use within an agile 
process.
 Together Tool Set, distributed by Borland
 (www.borland.com), provides a tools suite that
 supports many technical activities within XP and other
 agile processes.
 17 A persistent work product is a model or document or test case produced by the team that will be kept
 for an indeterminate period of time. It will not be discarded once the software increment is
 delivered.
 18 Tools noted here do not represent an endorsement, but rather a sampling of tools in this category.
 In most cases, tool names are trademarked by their respective developers.
91
 CHAPTER 3 AGILE DEVELOPMENT
 3.6 A TOOL SET FOR THE AGILE PROCESS
 The “tool set” that
 supports agile
 processes focuses
 more on people issues
 than it does on
 technology issues.
 Some proponents of the agile philosophy argue that automated software tools (e.g.,
 design tools) should be viewed as a minor supplement to the team’s activities, and
 not at all pivotal to the success of the team. However, Alistair Cockburn [Coc04] sug
gests that tools can have a benefit and that “agile teams stress using tools that per
mit the rapid flow of understanding. Some of those tools are social, starting even at
 the hiring stage. Some tools are technological, helping distributed teams simulate
 being physically present. Many tools are physical, allowing people to manipulate
 them in workshops.”
 Because acquiring the right people (hiring), team collaboration, stakeholder com
munication, and indirect management are key elements in virtually all agile process
 models, Cockburn argues that “tools” that address these issues are critical success
 factors for agility. For example, a hiring “tool” might be the requirement to have a
 prospective team member spend a few hours pair programming with an existing
 member of the team. The “fit” can be assessed immediately.
 Collaborative and communication “tools” are generally low tech and incorporate
 any mechanism (“physical proximity, whiteboards, poster sheets, index cards, and
 sticky notes” [Coc04]) that provides information and coordination among agile de
velopers. Active communication is achieved via the team dynamics (e.g., pair pro
gramming), while passive communication is achieved by “information radiators”
 (e.g., a flat panel display that presents the overall status of different components of
 an increment). Project management tools deemphasize the Gantt chart and replace
 it with earned value charts or “graphs of tests created versus passed . . . other agile
 tools are used to optimize the environment in which the agile team works (e.g., more
 efficient meeting areas), improve the team culture by nurturing social interactions
 (e.g., collocated teams), physical devices (e.g., electronic whiteboards), and process
 enhancement (e.g., pair programming or time-boxing)” [Coc04].
 Are any of these things really tools? They are, if they facilitate the work performed
 by an agile team member and enhance the quality of the end product.
 3.7 SUMMARY
 In a modern economy, market conditions change rapidly, customer and end-user
 needs evolve, and new competitive threats emerge without warning. Practitioners
 must approach software engineering in a manner that allows them to remain agile—
 to define maneuverable, adaptive, lean processes that can accommodate the needs
 of modern business.
 An agile philosophy for software engineering stresses four key issues: the impor
tance of self-organizing teams that have control over the work they perform, com
munication and collaboration between team members and between practitioners
 and their customers, a recognition that change represents an opportunity, and
92
 PART ONE THE SOFTWARE PROCESS
 an emphasis on rapid delivery of software that satisfies the customer. Agile process
 models have been designed to address each of these issues.
 Extreme programming (XP) is the most widely used agile process. Organized as
 four framework activities—planning, design, coding, and testing—XP suggests a
 number of innovative and powerful techniques that allow an agile team to create
 frequent software releases that deliver features and functionality that have been de
scribed and then prioritized by stakeholders.
 Other agile process models also stress human collaboration and team self
organization, but define their own framework activities and select different points of
 emphasis. For example, ASD uses an iterative process that incorporates adaptive
 cycle planning, relatively rigorous requirement gathering methods, and an iterative
 development cycle that incorporates customer focus groups and formal technical re
views as real-time feedback mechanisms. Scrum emphasizes the use of a set of soft
ware process patterns that have proven effective for projects with tight time lines,
 changing requirements, and business criticality. Each process pattern defines a set
 of development tasks and allows the Scrum team to construct a process that is
 adapted to the needs of the project. The Dynamic Systems Development Method
 (DSDM) advocates the use of time-box scheduling and suggests that only enough
 work is required for each software increment to facilitate movement to the next
 increment. Crystal is a family of agile process models that can be adopted to the spe
cific characteristics of a project.
 Feature Driven Development (FDD) is somewhat more “formal” than other agile
 methods, but still maintains agility by focusing the project team on the development
 of features—a client-valued function that can be implemented in two weeks or less.
 Lean Software Development (LSD) has adapted the principles of lean manufacturing
 to the world of software engineering. Agile modeling (AM) suggests that modeling is
 essential for all systems, but that the complexity, type, and size of the model must be
 tuned to the software to be built. The Agile Unified Process (AUP) adopts a “serial in
 the large” and “iterative in the small” philosophy for building software.
 PROBLEMS AND POINTS TO PONDER
 3.1. Reread “The Manifesto for Agile Software Development” at the beginning of this chapter.
 Can you think of a situation in which one or more of the four “values” could get a software team
 into trouble?
 3.2. Describe agility (for software projects) in your own words.
 3.3. Why does an iterative process make it easier to manage change? Is every agile process dis
cussed in this chapter iterative? Is it possible to complete a project in just one iteration and still
 be agile? Explain your answers.
 3.4. Could each of the agile processes be described using the generic framework activities
 noted in Chapter 2? Build a table that maps the generic activities into the activities defined for
 each agile process.
 3.5. Try to come up with one more “agility principle” that would help a software engineering
 team become even more maneuverable.
93
 CHAPTER 3 AGILE DEVELOPMENT
 3.6. Select one agility principle noted in Section 3.3.1 and try to determine whether each of the
 process models presented in this chapter exhibits the principle. [Note: I have presented an
 overview of these process models only, so it may not be possible to determine whether a prin
ciple has been addressed by one or more of the models, unless you do additional research
 (which is not required for this problem).]
 3.7. Why do requirements change so much? After all, don’t people know what they want?
 3.8. Most agile process models recommend face-to-face communication. Yet today, members
 of a software team and their customers may be geographically separated from one another. Do
 you think this implies that geographical separation is something to avoid? Can you think of ways
 to overcome this problem?
 3.9. Write an XP user story that describes the “favorite places” or “bookmarks” feature avail
able on most Web browsers.
 3.10. What is a spike solution in XP?
 3.11. Describe the XP concepts of refactoring and pair programming in your own words.
 3.12. Do a bit more reading and describe what a time-box is. How does this assist an ASD team
 in delivering software increments in a short time period?
 3.13. Do the 80 percent rule in DSDM and the time-boxing approach defined for ASD achieve
 the same result?
 3.14. Using the process pattern template presented in Chapter 2, develop a process pattern for
 any one of the Scrum patterns presented in Section 3.5.2.
 3.15. Why is Crystal called a family of agile methods?
 3.16. Using the FDD feature template described in Section 3.5.5, define a feature set for a Web
 browser. Now develop a set of features for the feature set.
 3.17. Visit the Official Agile Modeling Site and make a complete list of all core and supple
mentary AM principles.
 3.18. The tool set proposed in Section 3.6 supports many of the “soft” aspects of agile meth
ods. Since communication is so important, recommend an actual tool set that might be used to
 enhance communication among stakeholders on an agile team.
 FURTHER READINGS AND INFORMATION SOURCES
 The overall philosophy and underlying principles of agile software development are considered
 in depth in many of the books referenced in the body of this chapter. In addition, books by Shaw
 and Warden (The Art of Agile Development, O’Reilly Media, Inc., 2008), Hunt (Agile Software Con
struction, Springer, 2005), and Carmichael and Haywood (Better Software Faster, Prentice-Hall,
 2002) present useful discussions of the subject. Aguanno (Managing Agile Projects, Multi
Media Publications, 2005), Highsmith (Agile Project Management: Creating Innovative Products,
 Addison-Wesley, 2004), and Larman (Agile and Iterative Development: A Manager’s Guide,
 Addison-Wesley, 2003) present a management overview and consider project management
 issues. Highsmith (Agile Software Development Ecosystems, Addison-Wesley, 2002) presents a
 survey of agile principles, processes, and practices. A worthwhile discussion of the delicate bal
ance between agility and discipline is presented by Booch and his colleagues (Balancing Agility
 and Discipline, Addison-Wesley, 2004).
 Martin (Clean Code: A Handbook of Agile Software Craftsmanship, Prentice-Hall, 2009) pres
ents the principles, patterns, and practices required to develop “clean code” in an agile software
 engineering environment. Leffingwell (Scaling Software Agility: Best Practices for Large Enter
prises, Addison-Wesley, 2007) discusses strategies for scaling up agile practices for large proj
ects. Lippert and Rook (Refactoring in Large Software Projects: Performing Complex Restructurings
 Successfully, Wiley, 2006) discuss the use of refactoring when applied in large, complex systems.
94
 PART ONE THE SOFTWARE PROCESS
 Stamelos and Sfetsos (Agile Software Development Quality Assurance, IGI Global, 2007) discuss
 SQA techniques that conform to the agile philosophy.
 Dozens of books have been written about Extreme Programming over the past decade. Beck
 (Extreme Programming Explained: Embrace Change, 2d ed., Addison-Wesley, 2004) remains the
 definitive treatment of the subject. In addition, Jeffries and his colleagues (Extreme Programming
 Installed, Addison-Wesley, 2000), Succi and Marchesi (Extreme Programming Examined,
 Addison-Wesley, 2001), Newkirk and Martin (Extreme Programming in Practice, Addison-Wesley,
 2001), and Auer and his colleagues (Extreme Programming Applied: Play to Win, Addison-Wesley,
 2001) provide a nuts-and-bolts discussion of XP along with guidance on how best to apply it.
 McBreen (Questioning Extreme Programming, Addison-Wesley, 2003) takes a critical look at XP,
 defining when and where it is appropriate. An in-depth consideration of pair programming is
 presented by McBreen (Pair Programming Illuminated, Addison-Wesley, 2003).
 ASD is addressed in depth by Highsmith [Hig00]. Schwaber (The Enterprise and Scrum,
 Microsoft Press, 2007) discusses the use of Scrum for projects that have a major business
 impact. The nuts and bolts of Scrum are discussed by Schwaber and Beedle (Agile Software
 Development with SCRUM, Prentice-Hall, 2001). Worthwhile treatments of DSDM have been
 written by the DSDM Consortium (DSDM: Business Focused Development, 2d ed., Pearson Edu
cation, 2003) and Stapleton (DSDM: The Method in Practice, Addison-Wesley, 1997). Cockburn
 (Crystal Clear, Addison-Wesley, 2005) presents an excellent overview of the Crystal family of
 processes. Palmer and Felsing [Pal02] present a detailed treatment of FDD. Carmichael and
 Haywood (Better Software Faster, Prentice-Hall, 2002) provides another useful treatment of FDD
 that includes a step-by-step journey through the mechanics of the process. Poppendieck and 
Poppendieck (Lean Development: An Agile Toolkit for Software Development Managers, Addison
Wesley, 2003) provide guidelines for managing and controlling agile projects. Ambler and
 Jeffries (Agile Modeling, Wiley, 2002) discuss AM in some depth.
 A wide variety of information sources on agile software development are available on the
 Internet. An up-to-date list of World Wide Web references that are relevant to the agile process
 can be found at the SEPA website: www.mhhe.com/engcs/compsci/pressman/
 professional/olc/ser.htm.
In 2001, Kent Beck and 16 other noted software developers, writers, and con
sultants [Bec01a] (referred to as the “Agile Alliance”) signed the “Manifesto for
 Agile Software Development.” It stated:
 We are uncovering better ways of developing software by doing it and helping others
 do it. Through this work we have come to value: 
Individuals and interactions over processes and tools
 Working software over comprehensive documentation
 Customer collaboration over contract negotiation
 Responding to change over following a plan
 That is, while there is value in the items on the right, we value the items on the 
left more.
 QUICK
 LOOK
 What is it? Agile software engi
neering combines a philosophy and
 a set of development guidelines. The
 philosophy encourages customer
 satisfaction and early incremental delivery of
 software; small, highly motivated project teams;
 informal methods; minimal software engineer
ing work products; and overall development
 simplicity. The development guidelines stress
 delivery over analysis and design (although
 these activities are not discouraged), and active
 and continuous communication between devel
opers and customers.
 Who does it? Software engineers and other
 project stakeholders (managers, customers, end
 users) work together on an agile team—a team
 that is self-organizing and in control of its own
 destiny. An agile team fosters communication
 and collaboration among all who serve on it.
 Why is it important? The modern business envi
ronment that spawns computer-based systems
 and software products is fast-paced and ever
changing. Agile software engineering repre
sents a reasonable alternative to conventional
 software engineering for certain classes of soft
ware and certain types of software projects. It
 has been demonstrated to deliver successful sys
tems quickly.
 Whatarethesteps? Agiledevelopmentmightbest
 be termed “software engineering lite.” The basic
 framework activities—communication, planning,
 modeling, construction, and deployment—
 remain. But they morph into a minimal task set
 that pushes the project team toward construction
 and delivery (some would argue that this is
 done at the expense of problem analysis and
 solution design).
 What is the work product? Both the customer
 and the software engineer have the same
 view—the only really important work product
 is an operational “software increment” that is
 delivered to the customer on the appropriate
 commitment date.
 How do I ensure that I’ve done it right? If the
 agile team agrees that the process works, and
 the team produces deliverable software
 increments that satisfy the customer, you’ve
 done it right.
 65
66
 PART ONE THE SOFTWARE PROCESS
 FDD . . . . . . . . . .86
 Industrial XP . . .77
 Lean Software
 Development . . .87
 pair 
programming . . .76
 project 
velocity . . . . . . .74
 refactoring . . . . .75
 Scrum . . . . . . . .82
 stories . . . . . . . .74
 XP process . . . . .73
 uote:
 “Agility: 1,
 everything else: 0.”
 Tom DeMarco
 A manifesto is normally associated with an emerging political movement—one
 that attacks the old guard and suggests revolutionary change (hopefully for the
 better). In some ways, that’s exactly what agile development is all about.
 Although the underlying ideas that guide agile development have been with us for
 many years, it has been less than two decades since these ideas have crystallized
 into a “movement.” In essence, agile1 methods were developed in an effort to over
come perceived and actual weaknesses in conventional software engineering. Agile
 development can provide important benefits, but it is not applicable to all projects,
 all products, all people, and all situations. It is also not antithetical to solid software
 engineering practice and can be applied as an overriding philosophy for all software
 work.
 In the modern economy, it is often difficult or impossible to predict how a
 computer-based system (e.g., a Web-based application) will evolve as time passes.
 Market conditions change rapidly, end-user needs evolve, and new competitive
 threats emerge without warning. In many situations, you won’t be able to define
 requirements fully before the project begins. You must be agile enough to respond to
 a fluid business environment.
 Fluidity implies change, and change is expensive. Particularly if it is uncontrolled
 or poorly managed. One of the most compelling characteristics of the agile approach
 is its ability to reduce the costs of change throughout the software process.
 Does this mean that a recognition of challenges posed by modern realities causes
 you to discard valuable software engineering principles, concepts, methods, and
 tools? Absolutely not! Like all engineering disciplines, software engineering contin
ues to evolve. It can be adapted easily to meet the challenges posed by a demand for
 agility.
 In a thought-provoking book on agile software development, Alistair Cockburn
 [Coc02] argues that the prescriptive process models introduced in Chapter 2 have a
 major failing: they forget the frailties of the people who build computer software. Software
 engineers are not robots. They exhibit great variation in working styles; significant dif
ferences in skill level, creativity, orderliness, consistency, and spontaneity. Some com
municate well in written form, others do not. Cockburn argues that process models
 can “deal with people’s common weaknesses with [either] discipline or tolerance” and
 that most prescriptive process models choose discipline. He states: “Because consis
tency in action is a human weakness, high discipline methodologies are fragile.”
 If process models are to work, they must provide a realistic mechanism for en
couraging the discipline that is necessary, or they must be characterized in a man
ner that shows “tolerance” for the people who do software engineering work.
 Invariably, tolerant practices are easier for software people to adopt and sustain, but
 (as Cockburn admits) they may be less productive. Like most things in life, trade-offs
 must be considered.
 1 Agile methods are sometimes referred to as light methods or lean methods.
67
 CHAPTER 3 AGILE DEVELOPMENT
 3.1 WHAT IS AGILITY?
 Just what is agility in the context of software engineering work? Ivar Jacobson
 [Jac02a] provides a useful discussion:
 Agility has become today’s buzzword when describing a modern software process. Every
one is agile. An agile team is a nimble team able to appropriately respond to changes.
 Change is what software development is very much about. Changes in the software be
ing built, changes to the team members, changes because of new technology, changes of
 all kinds that may have an impact on the product they build or the project that creates the
 product. Support for changes should be built-in everything we do in software, something
 we embrace because it is the heart and soul of software. An agile team recognizes that
 software is developed by individuals working in teams and that the skills of these people,
 their ability to collaborate is at the core for the success of the project.
 Don’t make the
 mistake of assuming
 that agility gives you
 license to hack out
 solutions. A process is
 required and discipline
 is essential.
 In Jacobson’s view, the pervasiveness of change is the primary driver for agility. Soft
ware engineers must be quick on their feet if they are to accommodate the rapid
 changes that Jacobson describes.
 But agility is more than an effective response to change. It also encompasses the
 philosophy espoused in the manifesto noted at the beginning of this chapter. It
 encourages team structures and attitudes that make communication (among team
 members, between technologists and business people, between software engineers
 and their managers) more facile. It emphasizes rapid delivery of operational soft
ware and de-emphasizes the importance of intermediate work products (not always
 a good thing); it adopts the customer as a part of the development team and works
 to eliminate the “us and them” attitude that continues to pervade many software
 projects; it recognizes that planning in an uncertain world has its limits and that a
 project plan must be flexible.
 Agility can be applied to any software process. However, to accomplish this, it is
 essential that the process be designed in a way that allows the project team to adapt
 tasks and to streamline them, conduct planning in a way that understands the fluid
ity of an agile development approach, eliminate all but the most essential work prod
ucts and keep them lean, and emphasize an incremental delivery strategy that gets
 working software to the customer as rapidly as feasible for the product type and
 operational environment.
 3.2 AGILITY AND THE COST OF CHANGE
 The conventional wisdom in software development (supported by decades of expe
rience) is that the cost of change increases nonlinearly as a project progresses
 (Figure 3.1, solid black curve). It is relatively easy to accommodate a change when a
 software team is gathering requirements (early in a project). A usage scenario might
 have to be modified, a list of functions may be extended, or a written specification
 can be edited. The costs of doing this work are minimal, and the time required will
68
 PART ONE THE SOFTWARE PROCESS
 FIGURE 3.1
 Change costs
 as a function
 of time in
 development
 uote:
 Development cost
 Cost of change
 using conventional
 software processes
 Cost of change
 using agile processes
 “Agility is dynamic,
 content specific,
 aggressively
 change embracing,
 and growth
 oriented.”
 Idealized cost of change
 using agile process
 Development schedule progress–Steven
 Goldman et al.
 An agile process
 reduces the cost of
 change because
 software is released in
 increments and change
 can be better
 controlled within an
 increment.
 not adversely affect the outcome of the project. But what if we fast-forward a num
ber of months? The team is in the middle of validation testing (something that occurs
 relatively late in the project), and an important stakeholder is requesting a major
 functional change. The change requires a modification to the architectural design of
 the software, the design and construction of three new components, modifications
 to another five components, the design of new tests, and so on. Costs escalate
 quickly, and the time and cost required to ensure that the change is made without
 unintended side effects is nontrivial.
 Proponents of agility (e.g., [Bec00], [Amb04]) argue that a well-designed agile
 process “flattens” the cost of change curve (Figure 3.1, shaded, solid curve), allowing
 a software team to accommodate changes late in a software project without dramatic
 cost and time impact. You’ve already learned that the agile process encompasses in
cremental delivery. When incremental delivery is coupled with other agile practices
 such as continuous unit testing and pair programming (discussed later in this chap
ter), the cost of making a change is attenuated. Although debate about the degree to
 which the cost curve flattens is ongoing, there is evidence [Coc01a] to suggest that a
 significant reduction in the cost of change can be achieved.
 3.3 WHAT IS ANAGILE PROCESS?
 Any agile software process is characterized in a manner that addresses a number of
 key assumptions [Fow02] about the majority of software projects: 
1. It is difficult to predict in advance which software requirements will persist
 and which will change. It is equally difficult to predict how customer
 priorities will change as the project proceeds.
69
 CHAPTER 3 AGILE DEVELOPMENT
 WebRef
 A comprehensive
 collection of articles on
 the agile process 
can be found at
 www.aanpo.org/
 articles/index.
 Although agile
 processes embrace
 change, it is still
 important to examine
 the reasons for
 change.
 Working software is
 important, but don’t
 forget that it must also
 exhibit a variety of
 quality attributes
 including reliability,
 usability, and 
maintainability.
 2. For many types of software, design and construction are interleaved. That is,
 both activities should be performed in tandem so that design models are
 proven as they are created. It is difficult to predict how much design is
 necessary before construction is used to prove the design.
 3. Analysis, design, construction, and testing are not as predictable (from a
 planning point of view) as we might like.
 Given these three assumptions, an important question arises: How do we create a
 process that can manage unpredictability? The answer, as I have already noted, lies
 in process adaptability (to rapidly changing project and technical conditions). An
 agile process, therefore, must be adaptable.
 But continual adaptation without forward progress accomplishes little. Therefore,
 an agile software process must adapt incrementally. To accomplish incremental adap
tation, an agile team requires customer feedback (so that the appropriate adaptations
 can be made). An effective catalyst for customer feedback is an operational prototype
 or a portion of an operational system. Hence, an incremental development strategy
 should be instituted. Software increments (executable prototypes or portions of an op
erational system) must be delivered in short time periods so that adaptation keeps pace
 with change (unpredictability). This iterative approach enables the customer to evalu
ate the software increment regularly, provide necessary feedback to the software team,
 and influence the process adaptations that are made to accommodate the feedback.
 3.3.1 Agility Principles
 The Agile Alliance (see [Agi03], [Fow01]) defines 12 agility principles for those who
 want to achieve agility: 
1. Our highest priority is to satisfy the customer through early and continuous
 delivery of valuable software.
 2. Welcome changing requirements, even late in development. Agile processes
 harness change for the customer’s competitive advantage.
 3. Deliver working software frequently, from a couple of weeks to a couple of
 months, with a preference to the shorter timescale.
 4. Business people and developers must work together daily throughout the
 project.
 5. Build projects around motivated individuals. Give them the environment and
 support they need, and trust them to get the job done.
 6. The most efficient and effective method of conveying information to and
 within a development team is face-to-face conversation.
 7. Working software is the primary measure of progress.
 8. Agile processes promote sustainable development. The sponsors, developers,
 and users should be able to maintain a constant pace indefinitely.
70
 PART ONE THE SOFTWARE PROCESS
 9. Continuous attention to technical excellence and good design enhances
 agility.
 10. Simplicity—the art of maximizing the amount of work not done—is 
essential.
 11. The best architectures, requirements, and designs emerge from self
organizing teams.
 12. At regular intervals, the team reflects on how to become more effective, then
 tunes and adjusts its behavior accordingly.
 Not every agile process model applies these 12 principles with equal weight, and
 some models choose to ignore (or at least downplay) the importance of one or more
 of the principles. However, the principles define an agile spirit that is maintained in
 each of the process models presented in this chapter.
 3.3.2 The Politics of Agile Development
 You don’t have to
 choose between agility
 and software engi
neering. Rather, define
 a software engineering
 approach that is agile.
 There is considerable debate (sometimes strident) about the benefits and applicabil
ity of agile software development as opposed to more conventional software engi
neering processes. Jim Highsmith [Hig02a] (facetiously) states the extremes when he
 characterizes the feeling of the pro-agility camp (“agilists”). “Traditional methodolo
gists are a bunch of stick-in-the-muds who’d rather produce flawless documentation
 than a working system that meets business needs.” As a counterpoint, he states
 (again, facetiously) the position of the traditional software engineering camp: “Light
weight, er, ‘agile’ methodologists are a bunch of glorified hackers who are going to
 be in for a heck of a surprise when they try to scale up their toys into enterprise-wide
 software.”
 Like all software technology arguments, this methodology debate risks degener
ating into a religious war. If warfare breaks out, rational thought disappears and
 beliefs rather than facts guide decision making.
 No one is against agility. The real question is: What is the best way to achieve it?
 As important, how do you build software that meets customers’ needs today and
 exhibits the quality characteristics that will enable it to be extended and scaled to
 meet customers’ needs over the long term?
 There are no absolute answers to either of these questions. Even within the agile
 school itself, there are many proposed process models (Section 3.4), each with a
 subtly different approach to the agility problem. Within each model there is a set of
 “ideas” (agilists are loath to call them “work tasks”) that represent a significant
 departure from traditional software engineering. And yet, many agile concepts are
 simply adaptations of good software engineering concepts. Bottom line: there is
 much that can be gained by considering the best of both schools and virtually
 nothing to be gained by denigrating either approach.
 If you have further interest, see [Hig01], [Hig02a], and [DeM02] for an entertain
ing summary of other important technical and political issues.
71
 CHAPTER 3 AGILE DEVELOPMENT
 uote:
 “Agile methods
 derive much of
 their agility by
 relying on the
 tacit knowledge
 embodied in the
 team, rather than
 writing the
 knowledge down
 in plans.”
 Barry Boehm
 ?
 What key
 traits must
 exist among the
 people on an
 effective software
 team?
 uote:
 “What counts as
 barely sufficient
 for one team is
 either overly
 sufficient or
 insufficient for
 another.”
 Alistair
 Cockburn
 3.3.3 Human Factors
 Proponents of agile software development take great pains to emphasize the impor
tance of “people factors.” As Cockburn and Highsmith [Coc01a] state, “Agile devel
opment focuses on the talents and skills of individuals, molding the process to
 specific people and teams.” The key point in this statement is that the process molds
 to the needs of the people and team, not the other way around.2
 If members of the software team are to drive the characteristics of the process that
 is applied to build software, a number of key traits must exist among the people on
 an agile team and the team itself:
 Competence. In an agile development (as well as software engineering)
 context, “competence” encompasses innate talent, specific software-related
 skills, and overall knowledge of the process that the team has chosen to
 apply. Skill and knowledge of process can and should be taught to all people
 who serve as agile team members.
 Common focus. Although members of the agile team may perform differ
ent tasks and bring different skills to the project, all should be focused on one
 goal—to deliver a working software increment to the customer within the
 time promised. To achieve this goal, the team will also focus on continual
 adaptations (small and large) that will make the process fit the needs of the
 team.
 Collaboration. Software engineering (regardless of process) is about as
sessing, analyzing, and using information that is communicated to the soft
ware team; creating information that will help all stakeholders understand
 the work of the team; and building information (computer software and rele
vant databases) that provides business value for the customer. To accomplish
 these tasks, team members must collaborate—with one another and all other
 stakeholders.
 Decision-making ability. Any good software team (including agile teams)
 must be allowed the freedom to control its own destiny. This implies that the
 team is given autonomy—decision-making authority for both technical and
 project issues.
 Fuzzy problem-solving ability. Software managers must recognize that
 the agile team will continually have to deal with ambiguity and will continu
ally be buffeted by change. In some cases, the team must accept the fact that
 the problem they are solving today may not be the problem that needs to be
 solved tomorrow. However, lessons learned from any problem-solving
 2 Successful software engineering organizations recognize this reality regardless of the process
 model they choose.
72
 PART ONE THE SOFTWARE PROCESS
 A self-organizing team
 is in control of the
 work it performs. The
 team makes its own
 commitments and
 defines plans to
 achieve them.
 activity (including those that solve the wrong problem) may be of benefit to
 the team later in the project.
 Mutual trust and respect. The agile team must become what DeMarco
 and Lister [DeM98] call a “jelled” team (Chapter 24). A jelled team exhibits
 the trust and respect that are necessary to make them “so strongly knit that
 the whole is greater than the sum of the parts.” [DeM98]
 Self-organization. In the context of agile development, self-organization
 implies three things: (1) the agile team organizes itself for the work to be
 done, (2) the team organizes the process to best accommodate its local envi
ronment, (3) the team organizes the work schedule to best achieve delivery
 of the software increment. Self-organization has a number of technical bene
fits, but more importantly, it serves to improve collaboration and boost team
 morale. In essence, the team serves as its own management. Ken Schwaber
 [Sch02] addresses these issues when he writes: “The team selects how much
 work it believes it can perform within the iteration, and the team commits to
 the work. Nothing demotivates a team as much as someone else making
 commitments for it. Nothing motivates a team as much as accepting the
 responsibility for fulfilling commitments that it made itself.”
 3.4 EXTREME PROGRAMMING (XP)
 In order to illustrate an agile process in a bit more detail, I’ll provide you with an
 overview of Extreme Programming (XP), the most widely used approach to agile soft
ware development. Although early work on the ideas and methods associated with
 XP occurred during the late 1980s, the seminal work on the subject has been written
 by Kent Beck [Bec04a]. More recently, a variant of XP, called Industrial XP (IXP) has
 been proposed [Ker05]. IXP refines XP and targets the agile process specifically for
 use within large organizations.
 3.4.1 XP Values
 Beck [Bec04a] defines a set of five values that establish a foundation for all work per
formed as part of XP—communication, simplicity, feedback, courage, and respect. Each
 of these values is used as a driver for specific XP activities, actions, and tasks.
 In order to achieve effective communication between software engineers and
 other stakeholders (e.g., to establish required features and functions for the soft
ware), XP emphasizes close, yet informal (verbal) collaboration between customers
 and developers, the establishment of effective metaphors3 for communicating
 important concepts, continuous feedback, and the avoidance of voluminous docu
mentation as a communication medium.
 3 In the XP context, a metaphor is “a story that everyone—customers, programmers, and managers—
 can tell about how the system works” [Bec04a].
73
 CHAPTER 3 AGILE DEVELOPMENT
 Keep it simple
 whenever you can, but
 recognize that
 continual “refactoring”
 can absorb significant
 time and resources.
 uote:
 “XP is the answer
 to the question,
 ‘How little can we
 do and still build
 great software?’“
 Anonymous
 WebRef
 An excellent overview
 of “rules” for XP can
 be found at www
 .extremeprogramm
 ing.org/rules.html.
 To achieve simplicity, XP restricts developers to design only for immediate needs,
 rather than consider future needs. The intent is to create a simple design that can be
 easily implemented in code). If the design must be improved, it can be refactored4 at
 a later time.
 Feedback is derived from three sources: the implemented software itself, the
 customer, and other software team members. By designing and implementing an
 effective testing strategy (Chapters 17 through 20), the software (via test results) pro
vides the agile team with feedback. XP makes use of the unit test as its primary test
ing tactic. As each class is developed, the team develops a unit test to exercise each
 operation according to its specified functionality. As an increment is delivered to a
 customer, the user stories or use cases (Chapter 5) that are implemented by the
 increment are used as a basis for acceptance tests. The degree to which the software
 implements the output, function, and behavior of the use case is a form of feedback.
 Finally, as new requirements are derived as part of iterative planning, the team pro
vides the customer with rapid feedback regarding cost and schedule impact.
 Beck [Bec04a] argues that strict adherence to certain XP practices demands
 courage. A better word might be discipline. For example, there is often significant
 pressure to design for future requirements. Most software teams succumb, arguing
 that “designing for tomorrow” will save time and effort in the long run. An agile XP
 team must have the discipline (courage) to design for today, recognizing that future
 requirements may change dramatically, thereby demanding substantial rework of
 the design and implemented code.
 By following each of these values, the agile team inculcates respect among it
 members, between other stakeholders and team members, and indirectly, for the
 software itself. As they achieve successful delivery of software increments, the team
 develops growing respect for the XP process.
 3.4.2 The XP Process
 Extreme Programming uses an object-oriented approach (Appendix 2) as its pre
ferred development paradigm and encompasses a set of rules and practices that
 occur within the context of four framework activities: planning, design, coding, and
 testing. Figure 3.2 illustrates the XP process and notes some of the key ideas and
 tasks that are associated with each framework activity. Key XP activities are sum
marized in the paragraphs that follow.
 Planning. The planning activity (also called the planning game) begins with
 listening—a requirements gathering activity that enables the technical members of
 the XP team to understand the business context for the software and to get a broad
 4 Refactoring allows a software engineer to improve the internal structure of a design (or source
 code) without changing its external functionality or behavior. In essence, refactoring can be used
 to improve the efficiency, readability, or performance of a design or the code that implements a
 design.
74
 PART ONE THE SOFTWARE PROCESS
 FIGURE 3.2
 The Extreme
 Programming
 process
 ?
 What is an
 XP “story”?
 WebRef
 A worthwhile XP
 “planning game” can
 be found at:
 c2.com/cgi/
 wiki?planningGame.
 simple design
 CRC cards
 user stories
 values
 acceptance test criteria
 iteration plan
 Release
 spike solutions
 prototypes
 refactoring
 design
 pair programming
 planning
 software increment
 project velocity computed
 unit test
 continuous integration
 acceptance testing
 test
 coding
 feel for required output and major features and functionality. Listening leads to the
 creation of a set of “stories” (also called user stories) that describe required output,
 features, and functionality for software to be built. Each story (similar to use cases
 described in Chapter 5) is written by the customer and is placed on an index card.
 The customer assigns a value (i.e., a priority) to the story based on the overall busi
ness value of the feature or function.5 Members of the XP team then assess each
 story and assign a cost—measured in development weeks—to it. If the story is esti
mated to require more than three development weeks, the customer is asked to split
 the story into smaller stories and the assignment of value and cost occurs again. It
 is important to note that new stories can be written at any time.
 Customers and developers work together to decide how to group stories into the
 next release (the next software increment) to be developed by the XP team. Once a
 basic commitment (agreement on stories to be included, delivery date, and other
 project matters) is made for a release, the XP team orders the stories that will be de
veloped in one of three ways: (1) all stories will be implemented immediately (within
 a few weeks), (2) the stories with highest value will be moved up in the schedule and
 implemented first, or (3) the riskiest stories will be moved up in the schedule and
 implemented first.
 After the first project release (also called a software increment) has been deliv
ered, the XP team computes project velocity. Stated simply, project velocity is the
 5 The value of a story may also be dependent on the presence of another story.
75
 CHAPTER 3 AGILE DEVELOPMENT
 Project velocity is a
 subtle measure of
 team productivity.
 XP deemphasizes the
 importance of design.
 Not everyone agrees.
 In fact, there are times
 when design should be
 emphasized.
 WebRef
 Refactoring techniques
 and tools can be
 found at:
 www.refactoring
 .com.
 number of customer stories implemented during the first release. Project velocity can
 then be used to (1) help estimate delivery dates and schedule for subsequent releases
 and (2) determine whether an overcommitment has been made for all stories across
 the entire development project. If an overcommitment occurs, the content of releases
 is modified or end delivery dates are changed.
 As development work proceeds, the customer can add stories, change the value
 of an existing story, split stories, or eliminate them. The XP team then reconsiders all
 remaining releases and modifies its plans accordingly.
 Design. XP design rigorously follows the KIS (keep it simple) principle. A simple
 design is always preferred over a more complex representation. In addition, the de
sign provides implementation guidance for a story as it is written—nothing less,
 nothing more. The design of extra functionality (because the developer assumes it
 will be required later) is discouraged.6
 XP encourages the use of CRC cards (Chapter 7) as an effective mechanism for
 thinking about the software in an object-oriented context. CRC (class-responsibility
collaborator) cards identify and organize the object-oriented classes7 that are rele
vant to the current software increment. The XP team conducts the design exercise
 using a process similar to the one described in Chapter 8. The CRC cards are the only
 design work product produced as part of the XP process.
 If a difficult design problem is encountered as part of the design of a story, XP rec
ommends the immediate creation of an operational prototype of that portion of the
 design. Called a spike solution, the design prototype is implemented and evaluated.
 The intent is to lower risk when true implementation starts and to validate the orig
inal estimates for the story containing the design problem.
 In the preceding section, we noted that XP encourages refactoring—a construction
 technique that is also a method for design optimization. Fowler [Fow00] describes
 refactoring in the following manner:
 Refactoring is the process of changing a software system in such a way that it does not
 alter the external behavior of the code yet improves the internal structure. It is a disci
plined way to clean up code [and modify/simplify the internal design] that minimizes the
 chances of introducing bugs. In essence, when you refactor you are improving the design
 of the code after it has been written.
 Because XP design uses virtually no notation and produces few, if any, work prod
ucts other than CRC cards and spike solutions, design is viewed as a transient arti
fact that can and should be continually modified as construction proceeds. The intent
 of refactoring is to control these modifications by suggesting small design changes
 6 These design guidelines should be followed in every software engineering method, although there
 are times when sophisticated design notation and terminology may get in the way of simplicity.
 7 Object-oriented classes are discussed in Appendix 2, in Chapter 8, and throughout Part 2 of this
 book.
76
 PART ONE THE SOFTWARE PROCESS
 Refactoring improves
 the internal structure of
 a design (or source
 code) without
 changing its external
 functionality or
 behavior.
 WebRef
 Useful information on
 XP can be obtained 
at www
 .xprogramming.
 com.
 ?
 What is 
pair
 programming?
 Many software teams
 are populated by indi
vidualists. You’ll have
 to work to change that
 culture if pair program
ming is to work effec
tively.
 ?
 XP?
 How are unit
 tests used in
 that “can radically improve the design” [Fow00]. It should be noted, however, that
 the effort required for refactoring can grow dramatically as the size of an application
 grows.
 A central notion in XP is that design occurs both before and after coding com
mences. Refactoring means that design occurs continuously as the system is con
structed. In fact, the construction activity itself will provide the XP team with
 guidance on how to improve the design.
 Coding. After stories are developed and preliminary design work is done, the team
 does not move to code, but rather develops a series of unit tests that will exercise
 each of the stories that is to be included in the current release (software increment).8
 Once the unit test9 has been created, the developer is better able to focus on what
 must be implemented to pass the test. Nothing extraneous is added (KIS). Once the
 code is complete, it can be unit-tested immediately, thereby providing instantaneous
 feedback to the developers.
 A key concept during the coding activity (and one of the most talked about aspects
 of XP) is pair programming. XP recommends that two people work together at one
 computer workstation to create code for a story. This provides a mechanism for real
time problem solving (two heads are often better than one) and real-time quality as
surance (the code is reviewed as it is created). It also keeps the developers focused
 on the problem at hand. In practice, each person takes on a slightly different role. For
 example, one person might think about the coding details of a particular portion of
 the design while the other ensures that coding standards (a required part of XP) are
 being followed or that the code for the story will satisfy the unit test that has been
 developed to validate the code against the story.
 As pair programmers complete their work, the code they develop is integrated
 with the work of others. In some cases this is performed on a daily basis by an inte
gration team. In other cases, the pair programmers have integration responsibility.
 This “continuous integration” strategy helps to avoid compatibility and interfacing
 problems and provides a “smoke testing” environment (Chapter 17) that helps to
 uncover errors early.
 Testing. I have already noted that the creation of unit tests before coding com
mences is a key element of the XP approach. The unit tests that are created should
 be implemented using a framework that enables them to be automated (hence, they
 can be executed easily and repeatedly). This encourages a regression testing strat
egy (Chapter 17) whenever code is modified (which is often, given the XP refactor
ing philosophy).
 8 This approach is analogous to knowing the exam questions before you begin to study. It makes
 studying much easier by focusing attention only on the questions that will be asked.
 9 Unit testing, discussed in detail in Chapter 17, focuses on an individual software component, exer
cising the component’s interface, data structures, and functionality in an effort to uncover errors
 that are local to the component.
77
 CHAPTER 3 AGILE DEVELOPMENT
 XP acceptance tests
 are derived from user
 stories.
 ?
 What new
 practices are
 appended to XP
 to create IXP?
 uote:
 “Ability is what
 you’re capable of
 doing. Motivation
 determines what
 you do. Attitude
 determines how
 well you do it.”
 Lou Holtz
 As the individual unit tests are organized into a “universal testing suite” [Wel99],
 integration and validation testing of the system can occur on a daily basis. This pro
vides the XP team with a continual indication of progress and also can raise warn
ing flags early if things go awry. Wells [Wel99] states: “Fixing small problems every
 few hours takes less time than fixing huge problems just before the deadline.”
 XP acceptance tests, also called customer tests, are specified by the customer and
 focus on overall system features and functionality that are visible and reviewable by
 the customer. Acceptance tests are derived from user stories that have been imple
mented as part of a software release.
 3.4.3 Industrial XP
 Joshua Kerievsky [Ker05] describes Industrial Extreme Programming (IXP) in the fol
lowing manner: “IXP is an organic evolution of XP. It is imbued with XP’s minimal
ist, customer-centric, test-driven spirit. IXP differs most from the original XP in its
 greater inclusion of management, its expanded role for customers, and its upgraded
 technical practices.” IXP incorporates six new practices that are designed to help
 ensure that an XP project works successfully for significant projects within a large
 organization.
 Readiness assessment. Prior to the initiation of an IXP project, the organ
ization should conduct a readiness assessment. The assessment ascertains
 whether (1) an appropriate development environment exists to support IXP,
 (2) the team will be populated by the proper set of stakeholders, (3) the or
ganization has a distinct quality program and supports continuous improve
ment, (4) the organizational culture will support the new values of an agile
 team, and (5) the broader project community will be populated appropriately.
 Project community. Classic XP suggests that the right people be used to
 populate the agile team to ensure success. The implication is that people on
 the team must be well-trained, adaptable and skilled, and have the proper
 temperament to contribute to a self-organizing team. When XP is to be
 applied for a significant project in a large organization, the concept of the
 “team” should morph into that of a community. A community may have a
 technologist and customers who are central to the success of a project as
 well as many other stakeholders (e.g., legal staff, quality auditors, manufac
turing or sales types) who “are often at the periphery of an IXP project yet
 they may play important roles on the project” [Ker05]. In IXP, the community
 members and their roles should be explicitly defined and mechanisms for
 communication and coordination between community members should be
 established.
 Project chartering. The IXP team assesses the project itself to determine
 whether an appropriate business justification for the project exists and
 whether the project will further the overall goals and objectives of the
78
 PART ONE THE SOFTWARE PROCESS
 organization. Chartering also examines the context of the project to deter
mine how it complements, extends, or replaces existing systems or
 processes.
 Test-driven management. An IXP project requires measurable criteria for
 assessing the state of the project and the progress that has been made to
 date. Test-driven management establishes a series of measurable “destina
tions” [Ker05] and then defines mechanisms for determining whether or not
 these destinations have been reached.
 Retrospectives. An IXP team conducts a specialized technical review
 (Chapter 15) after a software increment is delivered. Called a retrospective,
 the review examines “issues, events, and lessons-learned” [Ker05] across a
 software increment and/or the entire software release. The intent is to
 improve the IXP process.
 Continuous learning. Because learning is a vital part of continuous
 process improvement, members of the XP team are encouraged (and possi
bly, incented) to learn new methods and techniques that can lead to a higher
quality product.
 In addition to the six new practices discussed, IXP modifies a number of existing
 XP practices. Story-driven development (SDD) insists that stories for acceptance tests
 be written before a single line of code is generated. Domain-driven design (DDD) is
 an improvement on the “system metaphor” concept used in XP. DDD [Eva03] sug
gests the evolutionary creation of a domain model that “accurately represents how
 domain experts think about their subject” [Ker05]. Pairing extends the XP pair
programming concept to include managers and other stakeholders. The intent is to
 improve knowledge sharing among XP team members who may not be directly in
volved in technical development. Iterative usability discourages front-loaded inter
face design in favor of usability design that evolves as software increments are
 delivered and users’ interaction with the software is studied.
 IXP makes smaller modifications to other XP practices and redefines certain roles
 and responsibilities to make them more amenable to significant projects for large
 organizations. For further discussion of IXP, visit http://industrialxp.org.
 3.4.4 The XP Debate
 All new process models and methods spur worthwhile discussion and in some in
stances heated debate. Extreme Programming has done both. In an interesting book
 that examines the efficacy of XP, Stephens and Rosenberg [Ste03] argue that many
 XP practices are worthwhile, but others have been overhyped, and a few are prob
lematic. The authors suggest that the codependent nature of XP practices are both
 its strength and its weakness. Because many organizations adopt only a subset of XP
 practices, they weaken the efficacy of the entire process. Proponents counter that
 XP is continuously evolving and that many of the issues raised by critics have been
79
 CHAPTER 3 AGILE DEVELOPMENT
 addressed as XP practice matures. Among the issues that continue to trouble some
 critics of XP are:10
 ?
 What are
 some of the
 issues that lead to
 an XP debate?
 • Requirements volatility. Because the customer is an active member of the XP
 team, changes to requirements are requested informally. As a consequence,
 the scope of the project can change and earlier work may have to be
 modified to accommodate current needs. Proponents argue that this happens
 regardless of the process that is applied and that XP provides mechanisms for
 controlling scope creep.
 • Conflicting customer needs. Many projects have multiple customers, each with
 his own set of needs. In XP, the team itself is tasked with assimilating the
 needs of different customers, a job that may be beyond their scope of
 authority.
 • Requirements are expressed informally. User stories and acceptance tests are
 the only explicit manifestation of requirements in XP. Critics argue that a
 more formal model or specification is often needed to ensure that omissions,
 inconsistencies, and errors are uncovered before the system is built. Propo
nents counter that the changing nature of requirements makes such models
 and specification obsolete almost as soon as they are developed.
 • Lack of formal design. XP deemphasizes the need for architectural design and
 in many instances, suggests that design of all kinds should be relatively
 informal. Critics argue that when complex systems are built, design must be
 emphasized to ensure that the overall structure of the software will exhibit
 quality and maintainability. XP proponents suggest that the incremental
 nature of the XP process limits complexity (simplicity is a core value) and
 therefore reduces the need for extensive design.
 You should note that every software process has flaws and that many software or
ganizations have used XP successfully. The key is to recognize where a process may
 have weaknesses and to adapt it to the specific needs of your organization.
 SAFEHOME
 Considering Agile Software Development
 The scene: Doug Miller’s office.
 The Players: Doug Miller, software engineering
 manager; Jamie Lazar, software team member; Vinod
 Raman, software team member.
 The conversation:
 (A knock on the door, Jamie and Vinod enter Doug’s office)
 Jamie: Doug, you got a minute?
 10 For a detailed look at some thoughtful criticism that has been leveled at XP, visit
 www.softwarereality.com/ExtremeProgramming.jsp.
3.5 OTHERAGILEPROCESSMODELS
 The history of software engineering is littered with dozens of obsolete process
 descriptions and methodologies, modeling methods and notations, tools, and
 technology. Each flared in notoriety and was then eclipsed by something new and
 (purportedly) better. With the introduction of a wide array of agile process models—
 each contending for acceptance within the software development community—the
 agile movement is following the same historical path.11
 As I noted in the last section, the most widely used of all agile process models
 isExtreme Programming (XP). But many other agile process models have been
 proposed and are in use across the industry. Among the most common are:
 •Adaptive Software Development (ASD)
 •Scrum
 •Dynamic Systems Development Method (DSDM)
 80 PART ONE THE SOFTWARE PROCESS
 Doug: Sure Jamie, what’s up?
 Jamie:We’ve been thinking about our process
 discussion yesterday . . . you know, what process we’re
 going to choose for this new SafeHomeproject.
 Doug:And?
 Vinod: I was talking to a friend at another company,
 and he was telling me about Extreme Programming. It’s
 an agile process model . . . heard of it?
 Doug: Yeah, some good, some bad.
 Jamie:Well, it sounds pretty good to us. Lets you
 develop software really fast, uses something called pair
 programming to do real-time quality checks . . . it’s pretty
 cool, I think.
 Doug: It does have a lot of really good ideas. I like the
 pair-programming concept, for instance, and the idea
 that stakeholders should be part of the team.
 Jamie:Huh? You mean that marketing will work on the
 project team with us?
 Doug (nodding): They’re a stakeholder, aren’t they?
 Jamie: Jeez . . . they’ll be requesting changes every five
 minutes.
 Vinod:Not necessarily. My friend said that there are
 ways to “embrace” changes during an XP project.
 Doug: So you guys think we should use XP?
 Jamie: It’s definitely worth considering.
 Doug: I agree. And even if we choose an incremental
 model as our approach, there’s no reason why we can’t
 incorporate much of what XP has to offer.
 Vinod:Doug, before you said “some good, some bad.”
 What was the “bad”?
 Doug: The thing I don’t like is the way XP downplays
 analysis and design . . . sort of says that writing code is
 where the action is . . . 
(The team members look at one another and smile.)
 Doug: So you agree with the XP approach?
 Jamie (speaking for both):Writing code is what
 we do, Boss!
 Doug (laughing): True, but I’d like to see you spend a
 little less time coding and then recoding and a little more
 time analyzing what has to be done and designing a
 solution that works.
 Vinod:Maybe we can have it both ways, agility with a
 little discipline.
 Doug: I think we can, Vinod. In fact, I’m sure of it.
 uote:
 “Our profession
 goes through
 methodologies like
 a 14-year-old goes
 through clothing.”
 Stephen
 Hawrysh and
 JimRuprecht
 11This is not a bad thing. Before one or more models or methods are accepted as a de facto standard,
 all must contend for the hearts and minds of software engineers. The “winners” evolve into best
 practice, while the “losers” either disappear or merge with the winning models.
81
 CHAPTER 3 AGILE DEVELOPMENT
 • Crystal
 • Feature Drive Development (FDD)
 • Lean Software Development (LSD)
 • Agile Modeling (AM)
 • Agile Unified Process (AUP)
 In the sections that follow, I present a very brief overview of each of these agile
 process models. It is important to note that all agile process models conform (to a
 greater or lesser degree) to the Manifesto for Agile Software Development and the prin
ciples noted in Section 3.3.1. For additional detail, refer to the references noted in
 each subsection or for a survey, examine the “agile software development” entry
 in Wikipedia.12
 3.5.1 Adaptive Software Development (ASD)
 WebRef
 Useful resources for
 ASD can be found at
 www.adaptivesd
 .com.
 Adaptive Software Development (ASD) has been proposed by Jim Highsmith [Hig00] as
 a technique for building complex software and systems. The philosophical under
pinnings of ASD focus on human collaboration and team self-organization.
 Highsmith argues that an agile, adaptive development approach based on collab
oration is “as much a source of order in our complex interactions as discipline and
 engineering.” He defines an ASD “life cycle” (Figure 3.3) that incorporates three
 phases, speculation, collaboration, and learning.
 FIGURE 3.3
 Adaptive
 software
 development
 adaptive cycle planning
 mission statement
 project constraints
 basic requirements
 time-boxed release plan
 Release
 Requirements gathering
 JAD
 mini-specs
 speculation
 software increment
 adjustments for subsequent cycles
 collaboration
 components implemented/tested
 focus groups for feedback
 formal technical reviews
 learning
 postmortems
 12 See http://en.wikipedia.org/wiki/Agile_software_development#Agile_methods.
82
 PART ONE THE SOFTWARE PROCESS
 Effective collaboration
 with your customer will
 only occur if you
 jettison any “us and
 them” attitudes.
 ASD emphasizes
 learning as a key
 element in achieving 
a “self-organizing”
 team.
 WebRef
 Useful Scrum
 information and
 resources can be found
 at www
 .controlchaos.com.
 During speculation, the project is initiated and adaptive cycle planning is con
ducted. Adaptive cycle planning uses project initiation information—the customer’s
 mission statement, project constraints (e.g., delivery dates or user descriptions), and
 basic requirements—to define the set of release cycles (software increments) that
 will be required for the project.
 No matter how complete and farsighted the cycle plan, it will invariably change.
 Based on information obtained at the completion of the first cycle, the plan is re
viewed and adjusted so that planned work better fits the reality in which an ASD
 team is working.
 Motivated people use collaboration in a way that multiplies their talent and cre
ative output beyond their absolute numbers. This approach is a recurring theme in
 all agile methods. But collaboration is not easy. It encompasses communication and
 teamwork, but it also emphasizes individualism, because individual creativity plays
 an important role in collaborative thinking. It is, above all, a matter of trust. People
 working together must trust one another to (1) criticize without animosity, (2) assist
 without resentment, (3) work as hard as or harder than they do, (4) have the skill set
 to contribute to the work at hand, and (5) communicate problems or concerns in a
 way that leads to effective action.
 As members of an ASD team begin to develop the components that are part of an
 adaptive cycle, the emphasis is on “learning” as much as it is on progress toward
 a completed cycle. In fact, Highsmith [Hig00] argues that software developers often
 overestimate their own understanding (of the technology, the process, and the proj
ect) and that learning will help them to improve their level of real understanding.
 ASD teams learn in three ways: focus groups (Chapter 5), technical reviews (Chap
ter 14), and project postmortems.
 The ASD philosophy has merit regardless of the process model that is used. ASD’s
 overall emphasis on the dynamics of self-organizing teams, interpersonal collabo
ration, and individual and team learning yield software project teams that have a
 much higher likelihood of success.
 3.5.2 Scrum
 Scrum (the name is derived from an activity that occurs during a rugby match13) is
 an agile software development method that was conceived by Jeff Sutherland and his
 development team in the early 1990s. In recent years, further development on the
 Scrum methods has been performed by Schwaber and Beedle [Sch01a].
 Scrum principles are consistent with the agile manifesto and are used to guide
 development activities within a process that incorporates the following framework
 activities: requirements, analysis, design, evolution, and delivery. Within each
 13 A group of players forms around the ball and the teammates work together (sometimes violently!)
 to move the ball downfield.
every 24
 hours
 30 days
 Scrum: 15 minute daily meeting.
 Team members respond to basics:
 1) What did you do since last Scrum
 meeting?
 2) Do you have any obstacles?
 3) What will you do before next
 meeting?
 Sprint Backlog:
 Feature(s)
 assigned
 to sprint
 Product Backlog:
 Prioritized product features desired by the customer
 Backlog
 items
 expanded
 by team
 New functionality
 is demonstrated
 at end of sprint
 framework activity, work tasks occur within a process pattern (discussed in the fol
lowing paragraph) called a sprint.The work conducted within a sprint (the number
 of sprints required for each framework activity will vary depending on product com
plexity and size) is adapted to the problem at hand and is defined and often modified
 in real time by the Scrum team. The overall flow of the Scrum process is illustrated
 in Figure 3.4.
 Scrum emphasizes the use of a set of software process patterns [Noy02] that have
 proven effective for projects with tight timelines, changing requirements, and business
 criticality. Each of these process patterns defines a set of development actions:
 Backlog—a prioritized list of project requirements or features that provide busi
ness value for the customer. Items can be added to the backlog at any time (this is
 how changes are introduced). The product manager assesses the backlog and
 updates priorities as required.
 Sprints—consist of work units that are required to achieve a requirement de
fined in the backlog that must be fit into a predefined time-box14(typically 30 days).
 CHAPTER 3 AGILE DEVELOPMENT 83
 14A time-boxis a project management term (see Part 4 of this book) that indicates a period of time
 that has been allocated to accomplish some task.
 FIGURE3.4
 Scrum process
 flow
 Scrum incorporates a
 set of process patterns
 that emphasize project
 priorities,
 compartmentalized
 work units,
 communication, and
 frequent customer
 feedback.
84
 PART ONE THE SOFTWARE PROCESS
 Changes (e.g., backlog work items) are not introduced during the sprint. Hence, the
 sprint allows team members to work in a short-term, but stable environment.
 Scrum meetings—are short (typically 15 minutes) meetings held daily by the Scrum
 team. Three key questions are asked and answered by all team members [Noy02]:
 • What did you do since the last team meeting?
 • What obstacles are you encountering?
 • What do you plan to accomplish by the next team meeting?
 A team leader, called a Scrum master, leads the meeting and assesses the responses
 from each person. The Scrum meeting helps the team to uncover potential problems
 as early as possible. Also, these daily meetings lead to “knowledge socialization”
 [Bee99] and thereby promote a self-organizing team structure.
 Demos—deliver the software increment to the customer so that functionality that
 has been implemented can be demonstrated and evaluated by the customer. It is im
portant to note that the demo may not contain all planned functionality, but rather
 those functions that can be delivered within the time-box that was established.
 Beedle and his colleagues [Bee99] present a comprehensive discussion of these pat
terns in which they state: “Scrum assumes up-front the existence of chaos. . . . ” The
 Scrum process patterns enable a software team to work successfully in a world
 where the elimination of uncertainty is impossible.
 3.5.3 Dynamic Systems Development Method (DSDM)
 WebRef
 Useful resources for
 DSSD can be found at
 www.dsdm.org.
 The Dynamic Systems Development Method (DSDM) [Sta97] is an agile software devel
opment approach that “provides a framework for building and maintaining systems
 which meet tight time constraints through the use of incremental prototyping in a con
trolled project environment” [CCS02]. The DSDM philosophy is borrowed from a mod
ified version of the Pareto principle—80 percent of an application can be delivered in
 20 percent of the time it would take to deliver the complete (100 percent) application.
 DSDM is an iterative software process in which each iteration follows the 80 per
cent rule. That is, only enough work is required for each increment to facilitate
 movement to the next increment. The remaining detail can be completed later when
 more business requirements are known or changes have been requested and
 accommodated.
 The DSDM Consortium (www.dsdm.org) is a worldwide group of member com
panies that collectively take on the role of “keeper” of the method. The consortium
 has defined an agile process model, called the DSDM life cycle that defines three dif
ferent iterative cycles, preceded by two additional life cycle activities:
 Feasibility study—establishes the basic business requirements and constraints
 associated with the application to be built and then assesses whether the applica
tion is a viable candidate for the DSDM process.
85
 CHAPTER 3 AGILE DEVELOPMENT
 DSDM is a process
 framework that can
 adopt the tactics of
 another agile approach
 such as XP.
 Crystal is a family of
 process models with
 the same “genetic
 code” but different
 methods for adapting
 to project
 characteristics.
 Business study—establishes the functional and information requirements that
 will allow the application to provide business value; also, defines the basic
 application architecture and identifies the maintainability requirements for the
 application.
 Functional model iteration—produces a set of incremental prototypes that
 demonstrate functionality for the customer. (Note: All DSDM prototypes are in
tended to evolve into the deliverable application.) The intent during this iterative
 cycle is to gather additional requirements by eliciting feedback from users as they
 exercise the prototype.
 Design and build iteration—revisits prototypes built during functional model
 iteration to ensure that each has been engineered in a manner that will enable it to
 provide operational business value for end users. In some cases, functional model
 iteration and design and build iteration occur concurrently.
 Implementation—places the latest software increment (an “operationalized” pro
totype) into the operational environment. It should be noted that (1) the increment
 may not be 100 percent complete or (2) changes may be requested as the incre
ment is put into place. In either case, DSDM development work continues by
 returning to the functional model iteration activity.
 DSDM can be combined with XP (Section 3.4) to provide a combination approach
 that defines a solid process model (the DSDM life cycle) with the nuts and bolts prac
tices (XP) that are required to build software increments. In addition, the ASD con
cepts of collaboration and self-organizing teams can be adapted to a combined
 process model.
 3.5.4 Crystal
 Alistair Cockburn [Coc05] and Jim Highsmith [Hig02b] created the Crystal family of
 agile methods15 in order to achieve a software development approach that puts a
 premium on “maneuverability” during what Cockburn characterizes as “a resource
limited, cooperative game of invention and communication, with a primary goal of
 delivering useful, working software and a secondary goal of setting up for the next
 game” [Coc02].
 To achieve maneuverability, Cockburn and Highsmith have defined a set of
 methodologies, each with core elements that are common to all, and roles, process
 patterns, work products, and practice that are unique to each. The Crystal family is
 actually a set of example agile processes that have been proven effective for differ
ent types of projects. The intent is to allow agile teams to select the member of the
 crystal family that is most appropriate for their project and environment.
 15 The name “crystal” is derived from the characteristics of geological crystals, each with its own
 color, shape, and hardness.
86
 PART ONE THE SOFTWARE PROCESS
 3.5.5 Feature Driven Development (FDD)
 WebRef
 A wide variety of
 articles and
 presentations on FDD
 can be found at:
 www.featuredrive
 ndevelopment
 .com/.
 Feature Driven Development (FDD) was originally conceived by Peter Coad and his
 colleagues [Coa99] as a practical process model for object-oriented software engi
neering. Stephen Palmer and John Felsing [Pal02] have extended and improved
 Coad’s work, describing an adaptive, agile process that can be applied to moderately
 sized and larger software projects.
 Like other agile approaches, FDD adopts a philosophy that (1) emphasizes col
laboration among people on an FDD team; (2) manages problem and project
 complexity using feature-based decomposition followed by the integration of
 software increments, and (3) communication of technical detail using verbal,
 graphical, and text-based means. FDD emphasizes software quality assurance
 activities by encouraging an incremental development strategy, the use of design
 and code inspections, the application of software quality assurance audits (Chap
ter 16), the collection of metrics, and the use of patterns (for analysis, design, and
 construction).
 In the context of FDD, a feature “is a client-valued function that can be imple
mented in two weeks or less” [Coa99]. The emphasis on the definition of features
 provides the following benefits:
 • Because features are small blocks of deliverable functionality, users can
 describe them more easily; understand how they relate to one another more
 readily; and better review them for ambiguity, error, or omissions.
 • Features can be organized into a hierarchical business-related grouping.
 • Since a feature is the FDD deliverable software increment, the team develops
 operational features every two weeks.
 • Because features are small, their design and code representations are easier
 to inspect effectively.
 • Project planning, scheduling, and tracking are driven by the feature
 hierarchy, rather than an arbitrarily adopted software engineering 
task set.
 Coad and his colleagues [Coa99] suggest the following template for defining a
 feature:
 <action> the <result> <by for of to> a(n) <object>
 where an <object> is “a person, place, or thing (including roles, moments in time or
 intervals of time, or catalog-entry-like descriptions).” Examples of features for an 
e-commerce application might be:
 Add the product to shopping cart
 Display the technical-specifications of the product
 Store the shipping-information for the customer
87
 CHAPTER 3 AGILE DEVELOPMENT
 FIGURE 3.5
 Feature Driven
 Development
 [Coa99] (with
 permission)
 Develop
 an
 Overall
 Model
 Build a
 Features
 List
 Plan
 By
 Feature
 Design
 By
 Feature
 (more shape
 than content)
 A list of features
 grouped into sets
 and subject areas
 A development plan
 Class owners
 Feature Set Owners
 A design
 package
 (sequences)
 Build
 By
 Feature
 Completed
 client-value
 function
 A feature set groups related features into business-related categories and is defined
 [Coa99] as:
 <action><-ing> a(n) <object>
 For example: Making a product sale is a feature set that would encompass the fea
tures noted earlier and others.
 The FDD approach defines five “collaborating” [Coa99] framework activities (in
 FDD these are called “processes”) as shown in Figure 3.5.
 FDD provides greater emphasis on project management guidelines and tech
niques than many other agile methods. As projects grow in size and complexity,
 ad hoc project management is often inadequate. It is essential for developers, their
 managers, and other stakeholders to understand project status—what accomplish
ments have been made and problems have been encountered. If deadline pressure
 is significant, it is critical to determine if software increments (features) are properly
 scheduled. To accomplish this, FDD defines six milestones during the design and
 implementation of a feature: “design walkthrough, design, design inspection, code,
 code inspection, promote to build” [Coa99].
 3.5.6 Lean Software Development (LSD)
 Lean Software Development (LSD) has adapted the principles of lean manufacturing
 to the world of software engineering. The lean principles that inspire the LSD process
 can be summarized ([Pop03], [Pop06a]) as eliminate waste, build quality in, create
 knowledge, defer commitment, deliver fast, respect people, and optimize the whole.
 Each of these principles can be adapted to the software process. For example,
 eliminate waste within the context of an agile software project can be interpreted
 to mean [Das05]: (1) adding no extraneous features or functions, (2) assessing the
 cost and schedule impact of any newly requested requirement, (3) removing any
 superfluous process steps, (4) establishing mechanisms to improve the way team
 members find information, (5) ensuring the testing finds as many errors as possible,
88
 PART ONE THE SOFTWARE PROCESS
 (6) reducing the time required to request and get a decision that affects the software
 or the process that is applied to create it, and (7) streamlining the manner in which
 information is transmitted to all stakeholders involved in the process.
 For a detailed discussion of LSD and pragmatic guidelines for implementing the
 process, you should examine [Pop06a] and [Pop06b].
 3.5.7 Agile Modeling (AM)
 WebRef
 Comprehensive
 information on agile
 modeling can be found
 at: www
 .agilemodeling.com.
 uote:
 “I was in the drug
 store the other day
 trying to get a cold
 medication . . . not
 easy. There’s an
 entire wall of
 products you need.
 You stand there
 going, Well, this
 one is quick acting
 but this is long
 lasting. . . . Which
 is more important,
 the present or the
 future?”
 Jerry Seinfeld
 There are many situations in which software engineers must build large, business
critical systems. The scope and complexity of such systems must be modeled so that
 (1) all constituencies can better understand what needs to be accomplished, (2) the
 problem can be partitioned effectively among the people who must solve it, and
 (3) quality can be assessed as the system is being engineered and built.
 Over the past 30 years, a wide variety of software engineering modeling methods
 and notation have been proposed for analysis and design (both architectural and
 component-level). These methods have merit, but they have proven to be difficult
 to apply and challenging to sustain (over many projects). Part of the problem is the
 “weight” of these modeling methods. By this I mean the volume of notation required,
 the degree of formalism suggested, the sheer size of the models for large projects,
 and the difficulty in maintaining the model(s) as changes occur. Yet analysis and de
sign modeling have substantial benefit for large projects—if for no other reason than
 to make these projects intellectually manageable. Is there an agile approach to soft
ware engineering modeling that might provide an alternative?
 At “The Official Agile Modeling Site,” Scott Ambler [Amb02a] describes agile mod
eling (AM) in the following manner:
 Agile Modeling (AM) is a practice-based methodology for effective modeling and documen
tation of software-based systems. Simply put, Agile Modeling (AM) is a collection of values,
 principles, and practices for modeling software that can be applied on a software develop
ment project in an effective and light-weight manner. Agile models are more effective than
 traditional models because they are just barely good, they don’t have to be perfect.
 Agile modeling adopts all of the values that are consistent with the agile manifesto.
 The agile modeling philosophy recognizes that an agile team must have the courage
 to make decisions that may cause it to reject a design and refactor. The team must
 also have the humility to recognize that technologists do not have all the answers and
 that business experts and other stakeholders should be respected and embraced.
 Although AM suggests a wide array of “core” and “supplementary” modeling prin
ciples, those that make AM unique are [Amb02a]:
 Model with a purpose. A developer who uses AM should have a specific
 goal (e.g., to communicate information to the customer or to help better un
derstand some aspect of the software) in mind before creating the model.
 Once the goal for the model is identified, the type of notation to be used and
 level of detail required will be more obvious.
89
 CHAPTER 3 AGILE DEVELOPMENT
 Use multiple models. There are many different models and notations that
 can be used to describe software. Only a small subset is essential for most
 projects. AM suggests that to provide needed insight, each model should
 present a different aspect of the system and only those models that provide
 value to their intended audience should be used.
 “Traveling light” is an
 appropriate philosophy
 for all software engi
neering work. Build
 only those models that
 provide value … no
 more, no less.
 Travel light. As software engineering work proceeds, keep only those mod
els that will provide long-term value and jettison the rest. Every work product
 that is kept must be maintained as changes occur. This represents work that
 slows the team down. Ambler [Amb02a] notes that “Every time you decide to
 keep a model you trade-off agility for the convenience of having that informa
tion available to your team in an abstract manner (hence potentially enhanc
ing communication within your team as well as with project stakeholders).”
 Content is more important than representation. Modeling should im
part information to its intended audience. A syntactically perfect model that
 imparts little useful content is not as valuable as a model with flawed nota
tion that nevertheless provides valuable content for its audience.
 Know the models and the tools you use to create them. Understand
 the strengths and weaknesses of each model and the tools that are used to
 create it.
 Adapt locally. The modeling approach should be adapted to the needs of
 the agile team.
 A major segment of the software engineering community has adopted the Unified
 Modeling Language (UML)16 as the preferred method for representing analysis and
 design models. The Unified Process (Chapter 2) has been developed to provide a
 framework for the application of UML. Scott Ambler [Amb06] has developed a sim
plified version of the UP that integrates his agile modeling philosophy.
 3.5.8 Agile Unified Process (AUP)
 The Agile Unified Process (AUP) adopts a “serial in the large” and “iterative in the
 small” [Amb06] philosophy for building computer-based systems. By adopting the
 classic UP phased activities—inception, elaboration, construction, and transition—AUP
 provides a serial overlay (i.e., a linear sequence of software engineering activities)
 that enables a team to visualize the overall process flow for a software project. How
ever, within each of the activities, the team iterates to achieve agility and to deliver
 meaningful software increments to end users as rapidly as possible. Each AUP iter
ation addresses the following activities [Amb06]: 
• Modeling. UML representations of the business and problem domains are
 created. However, to stay agile, these models should be “just barely good
 enough” [Amb06] to allow the team to proceed.
 16 A brief tutorial on UML is presented in Appendix 1.
90
 PART ONE THE SOFTWARE PROCESS
 • Implementation. Models are translated into source code.
 • Testing. Like XP, the team designs and executes a series of tests to uncover
 errors and ensure that the source code meets its requirements.
 • Deployment. Like the generic process activity discussed in Chapters 1 and 2,
 deployment in this context focuses on the delivery of a software increment
 and the acquisition of feedback from end users.
 • Configuration and project management. In the context of AUP, configuration
 management (Chapter 22) addresses change management, risk manage
ment, and the control of any persistent work products17 that are produced by
 the team. Project management tracks and controls the progress of the team
 and coordinates team activities.
 • Environment management. Environment management coordinates a process
 infrastructure that includes standards, tools, and other support technology
 available to the team.
 Although the AUP has historical and technical connections to the Unified Modeling
 Language, it is important to note that UML modeling can be using in conjunction
 with any of the agile process models described in Section 3.5.
 SOFTWARE TOOLS
 Agile Development
 Objective: The objective of agile development
 tools is to assist in one or more aspects of agile
 development with an emphasis on facilitating the rapid
 generation of operational software. These tools can also
 be used when prescriptive process models (Chapter 2) are
 applied.
 Mechanics: Tool mechanics vary. In general, agile tool
 sets encompass automated support for project planning,
 use case development and requirements gathering, rapid
 design, code generation, and testing.
 Representative Tools:18
 Note: Because agile development is a hot topic, most
 software tools vendors purport to sell tools that support 
the agile approach. The tools noted here have
 characteristics that make them particularly useful for
 agile projects.
 OnTime, developed by Axosoft (www.axosoft.com),
 provides agile process management support for
 various technical activities within the process.
 Ideogramic UML, developed by Ideogramic
 (www.ideogramic.com) is a UML tool set
 specifically developed for use within an agile 
process.
 Together Tool Set, distributed by Borland
 (www.borland.com), provides a tools suite that
 supports many technical activities within XP and other
 agile processes.
 17 A persistent work product is a model or document or test case produced by the team that will be kept
 for an indeterminate period of time. It will not be discarded once the software increment is
 delivered.
 18 Tools noted here do not represent an endorsement, but rather a sampling of tools in this category.
 In most cases, tool names are trademarked by their respective developers.
91
 CHAPTER 3 AGILE DEVELOPMENT
 3.6 A TOOL SET FOR THE AGILE PROCESS
 The “tool set” that
 supports agile
 processes focuses
 more on people issues
 than it does on
 technology issues.
 Some proponents of the agile philosophy argue that automated software tools (e.g.,
 design tools) should be viewed as a minor supplement to the team’s activities, and
 not at all pivotal to the success of the team. However, Alistair Cockburn [Coc04] sug
gests that tools can have a benefit and that “agile teams stress using tools that per
mit the rapid flow of understanding. Some of those tools are social, starting even at
 the hiring stage. Some tools are technological, helping distributed teams simulate
 being physically present. Many tools are physical, allowing people to manipulate
 them in workshops.”
 Because acquiring the right people (hiring), team collaboration, stakeholder com
munication, and indirect management are key elements in virtually all agile process
 models, Cockburn argues that “tools” that address these issues are critical success
 factors for agility. For example, a hiring “tool” might be the requirement to have a
 prospective team member spend a few hours pair programming with an existing
 member of the team. The “fit” can be assessed immediately.
 Collaborative and communication “tools” are generally low tech and incorporate
 any mechanism (“physical proximity, whiteboards, poster sheets, index cards, and
 sticky notes” [Coc04]) that provides information and coordination among agile de
velopers. Active communication is achieved via the team dynamics (e.g., pair pro
gramming), while passive communication is achieved by “information radiators”
 (e.g., a flat panel display that presents the overall status of different components of
 an increment). Project management tools deemphasize the Gantt chart and replace
 it with earned value charts or “graphs of tests created versus passed . . . other agile
 tools are used to optimize the environment in which the agile team works (e.g., more
 efficient meeting areas), improve the team culture by nurturing social interactions
 (e.g., collocated teams), physical devices (e.g., electronic whiteboards), and process
 enhancement (e.g., pair programming or time-boxing)” [Coc04].
 Are any of these things really tools? They are, if they facilitate the work performed
 by an agile team member and enhance the quality of the end product.
 3.7 SUMMARY
 In a modern economy, market conditions change rapidly, customer and end-user
 needs evolve, and new competitive threats emerge without warning. Practitioners
 must approach software engineering in a manner that allows them to remain agile—
 to define maneuverable, adaptive, lean processes that can accommodate the needs
 of modern business.
 An agile philosophy for software engineering stresses four key issues: the impor
tance of self-organizing teams that have control over the work they perform, com
munication and collaboration between team members and between practitioners
 and their customers, a recognition that change represents an opportunity, and
92
 PART ONE THE SOFTWARE PROCESS
 an emphasis on rapid delivery of software that satisfies the customer. Agile process
 models have been designed to address each of these issues.
 Extreme programming (XP) is the most widely used agile process. Organized as
 four framework activities—planning, design, coding, and testing—XP suggests a
 number of innovative and powerful techniques that allow an agile team to create
 frequent software releases that deliver features and functionality that have been de
scribed and then prioritized by stakeholders.
 Other agile process models also stress human collaboration and team self
organization, but define their own framework activities and select different points of
 emphasis. For example, ASD uses an iterative process that incorporates adaptive
 cycle planning, relatively rigorous requirement gathering methods, and an iterative
 development cycle that incorporates customer focus groups and formal technical re
views as real-time feedback mechanisms. Scrum emphasizes the use of a set of soft
ware process patterns that have proven effective for projects with tight time lines,
 changing requirements, and business criticality. Each process pattern defines a set
 of development tasks and allows the Scrum team to construct a process that is
 adapted to the needs of the project. The Dynamic Systems Development Method
 (DSDM) advocates the use of time-box scheduling and suggests that only enough
 work is required for each software increment to facilitate movement to the next
 increment. Crystal is a family of agile process models that can be adopted to the spe
cific characteristics of a project.
 Feature Driven Development (FDD) is somewhat more “formal” than other agile
 methods, but still maintains agility by focusing the project team on the development
 of features—a client-valued function that can be implemented in two weeks or less.
 Lean Software Development (LSD) has adapted the principles of lean manufacturing
 to the world of software engineering. Agile modeling (AM) suggests that modeling is
 essential for all systems, but that the complexity, type, and size of the model must be
 tuned to the software to be built. The Agile Unified Process (AUP) adopts a “serial in
 the large” and “iterative in the small” philosophy for building software.
 PROBLEMS AND POINTS TO PONDER
 3.1. Reread “The Manifesto for Agile Software Development” at the beginning of this chapter.
 Can you think of a situation in which one or more of the four “values” could get a software team
 into trouble?
 3.2. Describe agility (for software projects) in your own words.
 3.3. Why does an iterative process make it easier to manage change? Is every agile process dis
cussed in this chapter iterative? Is it possible to complete a project in just one iteration and still
 be agile? Explain your answers.
 3.4. Could each of the agile processes be described using the generic framework activities
 noted in Chapter 2? Build a table that maps the generic activities into the activities defined for
 each agile process.
 3.5. Try to come up with one more “agility principle” that would help a software engineering
 team become even more maneuverable.
93
 CHAPTER 3 AGILE DEVELOPMENT
 3.6. Select one agility principle noted in Section 3.3.1 and try to determine whether each of the
 process models presented in this chapter exhibits the principle. [Note: I have presented an
 overview of these process models only, so it may not be possible to determine whether a prin
ciple has been addressed by one or more of the models, unless you do additional research
 (which is not required for this problem).]
 3.7. Why do requirements change so much? After all, don’t people know what they want?
 3.8. Most agile process models recommend face-to-face communication. Yet today, members
 of a software team and their customers may be geographically separated from one another. Do
 you think this implies that geographical separation is something to avoid? Can you think of ways
 to overcome this problem?
 3.9. Write an XP user story that describes the “favorite places” or “bookmarks” feature avail
able on most Web browsers.
 3.10. What is a spike solution in XP?
 3.11. Describe the XP concepts of refactoring and pair programming in your own words.
 3.12. Do a bit more reading and describe what a time-box is. How does this assist an ASD team
 in delivering software increments in a short time period?
 3.13. Do the 80 percent rule in DSDM and the time-boxing approach defined for ASD achieve
 the same result?
 3.14. Using the process pattern template presented in Chapter 2, develop a process pattern for
 any one of the Scrum patterns presented in Section 3.5.2.
 3.15. Why is Crystal called a family of agile methods?
 3.16. Using the FDD feature template described in Section 3.5.5, define a feature set for a Web
 browser. Now develop a set of features for the feature set.
 3.17. Visit the Official Agile Modeling Site and make a complete list of all core and supple
mentary AM principles.
 3.18. The tool set proposed in Section 3.6 supports many of the “soft” aspects of agile meth
ods. Since communication is so important, recommend an actual tool set that might be used to
 enhance communication among stakeholders on an agile team.
 FURTHER READINGS AND INFORMATION SOURCES
 The overall philosophy and underlying principles of agile software development are considered
 in depth in many of the books referenced in the body of this chapter. In addition, books by Shaw
 and Warden (The Art of Agile Development, O’Reilly Media, Inc., 2008), Hunt (Agile Software Con
struction, Springer, 2005), and Carmichael and Haywood (Better Software Faster, Prentice-Hall,
 2002) present useful discussions of the subject. Aguanno (Managing Agile Projects, Multi
Media Publications, 2005), Highsmith (Agile Project Management: Creating Innovative Products,
 Addison-Wesley, 2004), and Larman (Agile and Iterative Development: A Manager’s Guide,
 Addison-Wesley, 2003) present a management overview and consider project management
 issues. Highsmith (Agile Software Development Ecosystems, Addison-Wesley, 2002) presents a
 survey of agile principles, processes, and practices. A worthwhile discussion of the delicate bal
ance between agility and discipline is presented by Booch and his colleagues (Balancing Agility
 and Discipline, Addison-Wesley, 2004).
 Martin (Clean Code: A Handbook of Agile Software Craftsmanship, Prentice-Hall, 2009) pres
ents the principles, patterns, and practices required to develop “clean code” in an agile software
 engineering environment. Leffingwell (Scaling Software Agility: Best Practices for Large Enter
prises, Addison-Wesley, 2007) discusses strategies for scaling up agile practices for large proj
ects. Lippert and Rook (Refactoring in Large Software Projects: Performing Complex Restructurings
 Successfully, Wiley, 2006) discuss the use of refactoring when applied in large, complex systems.
94
 PART ONE THE SOFTWARE PROCESS
 Stamelos and Sfetsos (Agile Software Development Quality Assurance, IGI Global, 2007) discuss
 SQA techniques that conform to the agile philosophy.
 Dozens of books have been written about Extreme Programming over the past decade. Beck
 (Extreme Programming Explained: Embrace Change, 2d ed., Addison-Wesley, 2004) remains the
 definitive treatment of the subject. In addition, Jeffries and his colleagues (Extreme Programming
 Installed, Addison-Wesley, 2000), Succi and Marchesi (Extreme Programming Examined,
 Addison-Wesley, 2001), Newkirk and Martin (Extreme Programming in Practice, Addison-Wesley,
 2001), and Auer and his colleagues (Extreme Programming Applied: Play to Win, Addison-Wesley,
 2001) provide a nuts-and-bolts discussion of XP along with guidance on how best to apply it.
 McBreen (Questioning Extreme Programming, Addison-Wesley, 2003) takes a critical look at XP,
 defining when and where it is appropriate. An in-depth consideration of pair programming is
 presented by McBreen (Pair Programming Illuminated, Addison-Wesley, 2003).
 ASD is addressed in depth by Highsmith [Hig00]. Schwaber (The Enterprise and Scrum,
 Microsoft Press, 2007) discusses the use of Scrum for projects that have a major business
 impact. The nuts and bolts of Scrum are discussed by Schwaber and Beedle (Agile Software
 Development with SCRUM, Prentice-Hall, 2001). Worthwhile treatments of DSDM have been
 written by the DSDM Consortium (DSDM: Business Focused Development, 2d ed., Pearson Edu
cation, 2003) and Stapleton (DSDM: The Method in Practice, Addison-Wesley, 1997). Cockburn
 (Crystal Clear, Addison-Wesley, 2005) presents an excellent overview of the Crystal family of
 processes. Palmer and Felsing [Pal02] present a detailed treatment of FDD. Carmichael and
 Haywood (Better Software Faster, Prentice-Hall, 2002) provides another useful treatment of FDD
 that includes a step-by-step journey through the mechanics of the process. Poppendieck and 
Poppendieck (Lean Development: An Agile Toolkit for Software Development Managers, Addison
Wesley, 2003) provide guidelines for managing and controlling agile projects. Ambler and
 Jeffries (Agile Modeling, Wiley, 2002) discuss AM in some depth.
 A wide variety of information sources on agile software development are available on the
 Internet. An up-to-date list of World Wide Web references that are relevant to the agile process
 can be found at the SEPA website: www.mhhe.com/engcs/compsci/pressman/
 professional/olc/ser.htm.
In 2001, Kent Beck and 16 other noted software developers, writers, and con
sultants [Bec01a] (referred to as the “Agile Alliance”) signed the “Manifesto for
 Agile Software Development.” It stated:
 We are uncovering better ways of developing software by doing it and helping others
 do it. Through this work we have come to value: 
Individuals and interactions over processes and tools
 Working software over comprehensive documentation
 Customer collaboration over contract negotiation
 Responding to change over following a plan
 That is, while there is value in the items on the right, we value the items on the 
left more.
 QUICK
 LOOK
 What is it? Agile software engi
neering combines a philosophy and
 a set of development guidelines. The
 philosophy encourages customer
 satisfaction and early incremental delivery of
 software; small, highly motivated project teams;
 informal methods; minimal software engineer
ing work products; and overall development
 simplicity. The development guidelines stress
 delivery over analysis and design (although
 these activities are not discouraged), and active
 and continuous communication between devel
opers and customers.
 Who does it? Software engineers and other
 project stakeholders (managers, customers, end
 users) work together on an agile team—a team
 that is self-organizing and in control of its own
 destiny. An agile team fosters communication
 and collaboration among all who serve on it.
 Why is it important? The modern business envi
ronment that spawns computer-based systems
 and software products is fast-paced and ever
changing. Agile software engineering repre
sents a reasonable alternative to conventional
 software engineering for certain classes of soft
ware and certain types of software projects. It
 has been demonstrated to deliver successful sys
tems quickly.
 Whatarethesteps? Agiledevelopmentmightbest
 be termed “software engineering lite.” The basic
 framework activities—communication, planning,
 modeling, construction, and deployment—
 remain. But they morph into a minimal task set
 that pushes the project team toward construction
 and delivery (some would argue that this is
 done at the expense of problem analysis and
 solution design).
 What is the work product? Both the customer
 and the software engineer have the same
 view—the only really important work product
 is an operational “software increment” that is
 delivered to the customer on the appropriate
 commitment date.
 How do I ensure that I’ve done it right? If the
 agile team agrees that the process works, and
 the team produces deliverable software
 increments that satisfy the customer, you’ve
 done it right.
 65
66
 PART ONE THE SOFTWARE PROCESS
 FDD . . . . . . . . . .86
 Industrial XP . . .77
 Lean Software
 Development . . .87
 pair 
programming . . .76
 project 
velocity . . . . . . .74
 refactoring . . . . .75
 Scrum . . . . . . . .82
 stories . . . . . . . .74
 XP process . . . . .73
 uote:
 “Agility: 1,
 everything else: 0.”
 Tom DeMarco
 A manifesto is normally associated with an emerging political movement—one
 that attacks the old guard and suggests revolutionary change (hopefully for the
 better). In some ways, that’s exactly what agile development is all about.
 Although the underlying ideas that guide agile development have been with us for
 many years, it has been less than two decades since these ideas have crystallized
 into a “movement.” In essence, agile1 methods were developed in an effort to over
come perceived and actual weaknesses in conventional software engineering. Agile
 development can provide important benefits, but it is not applicable to all projects,
 all products, all people, and all situations. It is also not antithetical to solid software
 engineering practice and can be applied as an overriding philosophy for all software
 work.
 In the modern economy, it is often difficult or impossible to predict how a
 computer-based system (e.g., a Web-based application) will evolve as time passes.
 Market conditions change rapidly, end-user needs evolve, and new competitive
 threats emerge without warning. In many situations, you won’t be able to define
 requirements fully before the project begins. You must be agile enough to respond to
 a fluid business environment.
 Fluidity implies change, and change is expensive. Particularly if it is uncontrolled
 or poorly managed. One of the most compelling characteristics of the agile approach
 is its ability to reduce the costs of change throughout the software process.
 Does this mean that a recognition of challenges posed by modern realities causes
 you to discard valuable software engineering principles, concepts, methods, and
 tools? Absolutely not! Like all engineering disciplines, software engineering contin
ues to evolve. It can be adapted easily to meet the challenges posed by a demand for
 agility.
 In a thought-provoking book on agile software development, Alistair Cockburn
 [Coc02] argues that the prescriptive process models introduced in Chapter 2 have a
 major failing: they forget the frailties of the people who build computer software. Software
 engineers are not robots. They exhibit great variation in working styles; significant dif
ferences in skill level, creativity, orderliness, consistency, and spontaneity. Some com
municate well in written form, others do not. Cockburn argues that process models
 can “deal with people’s common weaknesses with [either] discipline or tolerance” and
 that most prescriptive process models choose discipline. He states: “Because consis
tency in action is a human weakness, high discipline methodologies are fragile.”
 If process models are to work, they must provide a realistic mechanism for en
couraging the discipline that is necessary, or they must be characterized in a man
ner that shows “tolerance” for the people who do software engineering work.
 Invariably, tolerant practices are easier for software people to adopt and sustain, but
 (as Cockburn admits) they may be less productive. Like most things in life, trade-offs
 must be considered.
 1 Agile methods are sometimes referred to as light methods or lean methods.
67
 CHAPTER 3 AGILE DEVELOPMENT
 3.1 WHAT IS AGILITY?
 Just what is agility in the context of software engineering work? Ivar Jacobson
 [Jac02a] provides a useful discussion:
 Agility has become today’s buzzword when describing a modern software process. Every
one is agile. An agile team is a nimble team able to appropriately respond to changes.
 Change is what software development is very much about. Changes in the software be
ing built, changes to the team members, changes because of new technology, changes of
 all kinds that may have an impact on the product they build or the project that creates the
 product. Support for changes should be built-in everything we do in software, something
 we embrace because it is the heart and soul of software. An agile team recognizes that
 software is developed by individuals working in teams and that the skills of these people,
 their ability to collaborate is at the core for the success of the project.
 Don’t make the
 mistake of assuming
 that agility gives you
 license to hack out
 solutions. A process is
 required and discipline
 is essential.
 In Jacobson’s view, the pervasiveness of change is the primary driver for agility. Soft
ware engineers must be quick on their feet if they are to accommodate the rapid
 changes that Jacobson describes.
 But agility is more than an effective response to change. It also encompasses the
 philosophy espoused in the manifesto noted at the beginning of this chapter. It
 encourages team structures and attitudes that make communication (among team
 members, between technologists and business people, between software engineers
 and their managers) more facile. It emphasizes rapid delivery of operational soft
ware and de-emphasizes the importance of intermediate work products (not always
 a good thing); it adopts the customer as a part of the development team and works
 to eliminate the “us and them” attitude that continues to pervade many software
 projects; it recognizes that planning in an uncertain world has its limits and that a
 project plan must be flexible.
 Agility can be applied to any software process. However, to accomplish this, it is
 essential that the process be designed in a way that allows the project team to adapt
 tasks and to streamline them, conduct planning in a way that understands the fluid
ity of an agile development approach, eliminate all but the most essential work prod
ucts and keep them lean, and emphasize an incremental delivery strategy that gets
 working software to the customer as rapidly as feasible for the product type and
 operational environment.
 3.2 AGILITY AND THE COST OF CHANGE
 The conventional wisdom in software development (supported by decades of expe
rience) is that the cost of change increases nonlinearly as a project progresses
 (Figure 3.1, solid black curve). It is relatively easy to accommodate a change when a
 software team is gathering requirements (early in a project). A usage scenario might
 have to be modified, a list of functions may be extended, or a written specification
 can be edited. The costs of doing this work are minimal, and the time required will
68
 PART ONE THE SOFTWARE PROCESS
 FIGURE 3.1
 Change costs
 as a function
 of time in
 development
 uote:
 Development cost
 Cost of change
 using conventional
 software processes
 Cost of change
 using agile processes
 “Agility is dynamic,
 content specific,
 aggressively
 change embracing,
 and growth
 oriented.”
 Idealized cost of change
 using agile process
 Development schedule progress–Steven
 Goldman et al.
 An agile process
 reduces the cost of
 change because
 software is released in
 increments and change
 can be better
 controlled within an
 increment.
 not adversely affect the outcome of the project. But what if we fast-forward a num
ber of months? The team is in the middle of validation testing (something that occurs
 relatively late in the project), and an important stakeholder is requesting a major
 functional change. The change requires a modification to the architectural design of
 the software, the design and construction of three new components, modifications
 to another five components, the design of new tests, and so on. Costs escalate
 quickly, and the time and cost required to ensure that the change is made without
 unintended side effects is nontrivial.
 Proponents of agility (e.g., [Bec00], [Amb04]) argue that a well-designed agile
 process “flattens” the cost of change curve (Figure 3.1, shaded, solid curve), allowing
 a software team to accommodate changes late in a software project without dramatic
 cost and time impact. You’ve already learned that the agile process encompasses in
cremental delivery. When incremental delivery is coupled with other agile practices
 such as continuous unit testing and pair programming (discussed later in this chap
ter), the cost of making a change is attenuated. Although debate about the degree to
 which the cost curve flattens is ongoing, there is evidence [Coc01a] to suggest that a
 significant reduction in the cost of change can be achieved.
 3.3 WHAT IS ANAGILE PROCESS?
 Any agile software process is characterized in a manner that addresses a number of
 key assumptions [Fow02] about the majority of software projects: 
1. It is difficult to predict in advance which software requirements will persist
 and which will change. It is equally difficult to predict how customer
 priorities will change as the project proceeds.
69
 CHAPTER 3 AGILE DEVELOPMENT
 WebRef
 A comprehensive
 collection of articles on
 the agile process 
can be found at
 www.aanpo.org/
 articles/index.
 Although agile
 processes embrace
 change, it is still
 important to examine
 the reasons for
 change.
 Working software is
 important, but don’t
 forget that it must also
 exhibit a variety of
 quality attributes
 including reliability,
 usability, and 
maintainability.
 2. For many types of software, design and construction are interleaved. That is,
 both activities should be performed in tandem so that design models are
 proven as they are created. It is difficult to predict how much design is
 necessary before construction is used to prove the design.
 3. Analysis, design, construction, and testing are not as predictable (from a
 planning point of view) as we might like.
 Given these three assumptions, an important question arises: How do we create a
 process that can manage unpredictability? The answer, as I have already noted, lies
 in process adaptability (to rapidly changing project and technical conditions). An
 agile process, therefore, must be adaptable.
 But continual adaptation without forward progress accomplishes little. Therefore,
 an agile software process must adapt incrementally. To accomplish incremental adap
tation, an agile team requires customer feedback (so that the appropriate adaptations
 can be made). An effective catalyst for customer feedback is an operational prototype
 or a portion of an operational system. Hence, an incremental development strategy
 should be instituted. Software increments (executable prototypes or portions of an op
erational system) must be delivered in short time periods so that adaptation keeps pace
 with change (unpredictability). This iterative approach enables the customer to evalu
ate the software increment regularly, provide necessary feedback to the software team,
 and influence the process adaptations that are made to accommodate the feedback.
 3.3.1 Agility Principles
 The Agile Alliance (see [Agi03], [Fow01]) defines 12 agility principles for those who
 want to achieve agility: 
1. Our highest priority is to satisfy the customer through early and continuous
 delivery of valuable software.
 2. Welcome changing requirements, even late in development. Agile processes
 harness change for the customer’s competitive advantage.
 3. Deliver working software frequently, from a couple of weeks to a couple of
 months, with a preference to the shorter timescale.
 4. Business people and developers must work together daily throughout the
 project.
 5. Build projects around motivated individuals. Give them the environment and
 support they need, and trust them to get the job done.
 6. The most efficient and effective method of conveying information to and
 within a development team is face-to-face conversation.
 7. Working software is the primary measure of progress.
 8. Agile processes promote sustainable development. The sponsors, developers,
 and users should be able to maintain a constant pace indefinitely.
70
 PART ONE THE SOFTWARE PROCESS
 9. Continuous attention to technical excellence and good design enhances
 agility.
 10. Simplicity—the art of maximizing the amount of work not done—is 
essential.
 11. The best architectures, requirements, and designs emerge from self
organizing teams.
 12. At regular intervals, the team reflects on how to become more effective, then
 tunes and adjusts its behavior accordingly.
 Not every agile process model applies these 12 principles with equal weight, and
 some models choose to ignore (or at least downplay) the importance of one or more
 of the principles. However, the principles define an agile spirit that is maintained in
 each of the process models presented in this chapter.
 3.3.2 The Politics of Agile Development
 You don’t have to
 choose between agility
 and software engi
neering. Rather, define
 a software engineering
 approach that is agile.
 There is considerable debate (sometimes strident) about the benefits and applicabil
ity of agile software development as opposed to more conventional software engi
neering processes. Jim Highsmith [Hig02a] (facetiously) states the extremes when he
 characterizes the feeling of the pro-agility camp (“agilists”). “Traditional methodolo
gists are a bunch of stick-in-the-muds who’d rather produce flawless documentation
 than a working system that meets business needs.” As a counterpoint, he states
 (again, facetiously) the position of the traditional software engineering camp: “Light
weight, er, ‘agile’ methodologists are a bunch of glorified hackers who are going to
 be in for a heck of a surprise when they try to scale up their toys into enterprise-wide
 software.”
 Like all software technology arguments, this methodology debate risks degener
ating into a religious war. If warfare breaks out, rational thought disappears and
 beliefs rather than facts guide decision making.
 No one is against agility. The real question is: What is the best way to achieve it?
 As important, how do you build software that meets customers’ needs today and
 exhibits the quality characteristics that will enable it to be extended and scaled to
 meet customers’ needs over the long term?
 There are no absolute answers to either of these questions. Even within the agile
 school itself, there are many proposed process models (Section 3.4), each with a
 subtly different approach to the agility problem. Within each model there is a set of
 “ideas” (agilists are loath to call them “work tasks”) that represent a significant
 departure from traditional software engineering. And yet, many agile concepts are
 simply adaptations of good software engineering concepts. Bottom line: there is
 much that can be gained by considering the best of both schools and virtually
 nothing to be gained by denigrating either approach.
 If you have further interest, see [Hig01], [Hig02a], and [DeM02] for an entertain
ing summary of other important technical and political issues.
71
 CHAPTER 3 AGILE DEVELOPMENT
 uote:
 “Agile methods
 derive much of
 their agility by
 relying on the
 tacit knowledge
 embodied in the
 team, rather than
 writing the
 knowledge down
 in plans.”
 Barry Boehm
 ?
 What key
 traits must
 exist among the
 people on an
 effective software
 team?
 uote:
 “What counts as
 barely sufficient
 for one team is
 either overly
 sufficient or
 insufficient for
 another.”
 Alistair
 Cockburn
 3.3.3 Human Factors
 Proponents of agile software development take great pains to emphasize the impor
tance of “people factors.” As Cockburn and Highsmith [Coc01a] state, “Agile devel
opment focuses on the talents and skills of individuals, molding the process to
 specific people and teams.” The key point in this statement is that the process molds
 to the needs of the people and team, not the other way around.2
 If members of the software team are to drive the characteristics of the process that
 is applied to build software, a number of key traits must exist among the people on
 an agile team and the team itself:
 Competence. In an agile development (as well as software engineering)
 context, “competence” encompasses innate talent, specific software-related
 skills, and overall knowledge of the process that the team has chosen to
 apply. Skill and knowledge of process can and should be taught to all people
 who serve as agile team members.
 Common focus. Although members of the agile team may perform differ
ent tasks and bring different skills to the project, all should be focused on one
 goal—to deliver a working software increment to the customer within the
 time promised. To achieve this goal, the team will also focus on continual
 adaptations (small and large) that will make the process fit the needs of the
 team.
 Collaboration. Software engineering (regardless of process) is about as
sessing, analyzing, and using information that is communicated to the soft
ware team; creating information that will help all stakeholders understand
 the work of the team; and building information (computer software and rele
vant databases) that provides business value for the customer. To accomplish
 these tasks, team members must collaborate—with one another and all other
 stakeholders.
 Decision-making ability. Any good software team (including agile teams)
 must be allowed the freedom to control its own destiny. This implies that the
 team is given autonomy—decision-making authority for both technical and
 project issues.
 Fuzzy problem-solving ability. Software managers must recognize that
 the agile team will continually have to deal with ambiguity and will continu
ally be buffeted by change. In some cases, the team must accept the fact that
 the problem they are solving today may not be the problem that needs to be
 solved tomorrow. However, lessons learned from any problem-solving
 2 Successful software engineering organizations recognize this reality regardless of the process
 model they choose.
72
 PART ONE THE SOFTWARE PROCESS
 A self-organizing team
 is in control of the
 work it performs. The
 team makes its own
 commitments and
 defines plans to
 achieve them.
 activity (including those that solve the wrong problem) may be of benefit to
 the team later in the project.
 Mutual trust and respect. The agile team must become what DeMarco
 and Lister [DeM98] call a “jelled” team (Chapter 24). A jelled team exhibits
 the trust and respect that are necessary to make them “so strongly knit that
 the whole is greater than the sum of the parts.” [DeM98]
 Self-organization. In the context of agile development, self-organization
 implies three things: (1) the agile team organizes itself for the work to be
 done, (2) the team organizes the process to best accommodate its local envi
ronment, (3) the team organizes the work schedule to best achieve delivery
 of the software increment. Self-organization has a number of technical bene
fits, but more importantly, it serves to improve collaboration and boost team
 morale. In essence, the team serves as its own management. Ken Schwaber
 [Sch02] addresses these issues when he writes: “The team selects how much
 work it believes it can perform within the iteration, and the team commits to
 the work. Nothing demotivates a team as much as someone else making
 commitments for it. Nothing motivates a team as much as accepting the
 responsibility for fulfilling commitments that it made itself.”
 3.4 EXTREME PROGRAMMING (XP)
 In order to illustrate an agile process in a bit more detail, I’ll provide you with an
 overview of Extreme Programming (XP), the most widely used approach to agile soft
ware development. Although early work on the ideas and methods associated with
 XP occurred during the late 1980s, the seminal work on the subject has been written
 by Kent Beck [Bec04a]. More recently, a variant of XP, called Industrial XP (IXP) has
 been proposed [Ker05]. IXP refines XP and targets the agile process specifically for
 use within large organizations.
 3.4.1 XP Values
 Beck [Bec04a] defines a set of five values that establish a foundation for all work per
formed as part of XP—communication, simplicity, feedback, courage, and respect. Each
 of these values is used as a driver for specific XP activities, actions, and tasks.
 In order to achieve effective communication between software engineers and
 other stakeholders (e.g., to establish required features and functions for the soft
ware), XP emphasizes close, yet informal (verbal) collaboration between customers
 and developers, the establishment of effective metaphors3 for communicating
 important concepts, continuous feedback, and the avoidance of voluminous docu
mentation as a communication medium.
 3 In the XP context, a metaphor is “a story that everyone—customers, programmers, and managers—
 can tell about how the system works” [Bec04a].
73
 CHAPTER 3 AGILE DEVELOPMENT
 Keep it simple
 whenever you can, but
 recognize that
 continual “refactoring”
 can absorb significant
 time and resources.
 uote:
 “XP is the answer
 to the question,
 ‘How little can we
 do and still build
 great software?’“
 Anonymous
 WebRef
 An excellent overview
 of “rules” for XP can
 be found at www
 .extremeprogramm
 ing.org/rules.html.
 To achieve simplicity, XP restricts developers to design only for immediate needs,
 rather than consider future needs. The intent is to create a simple design that can be
 easily implemented in code). If the design must be improved, it can be refactored4 at
 a later time.
 Feedback is derived from three sources: the implemented software itself, the
 customer, and other software team members. By designing and implementing an
 effective testing strategy (Chapters 17 through 20), the software (via test results) pro
vides the agile team with feedback. XP makes use of the unit test as its primary test
ing tactic. As each class is developed, the team develops a unit test to exercise each
 operation according to its specified functionality. As an increment is delivered to a
 customer, the user stories or use cases (Chapter 5) that are implemented by the
 increment are used as a basis for acceptance tests. The degree to which the software
 implements the output, function, and behavior of the use case is a form of feedback.
 Finally, as new requirements are derived as part of iterative planning, the team pro
vides the customer with rapid feedback regarding cost and schedule impact.
 Beck [Bec04a] argues that strict adherence to certain XP practices demands
 courage. A better word might be discipline. For example, there is often significant
 pressure to design for future requirements. Most software teams succumb, arguing
 that “designing for tomorrow” will save time and effort in the long run. An agile XP
 team must have the discipline (courage) to design for today, recognizing that future
 requirements may change dramatically, thereby demanding substantial rework of
 the design and implemented code.
 By following each of these values, the agile team inculcates respect among it
 members, between other stakeholders and team members, and indirectly, for the
 software itself. As they achieve successful delivery of software increments, the team
 develops growing respect for the XP process.
 3.4.2 The XP Process
 Extreme Programming uses an object-oriented approach (Appendix 2) as its pre
ferred development paradigm and encompasses a set of rules and practices that
 occur within the context of four framework activities: planning, design, coding, and
 testing. Figure 3.2 illustrates the XP process and notes some of the key ideas and
 tasks that are associated with each framework activity. Key XP activities are sum
marized in the paragraphs that follow.
 Planning. The planning activity (also called the planning game) begins with
 listening—a requirements gathering activity that enables the technical members of
 the XP team to understand the business context for the software and to get a broad
 4 Refactoring allows a software engineer to improve the internal structure of a design (or source
 code) without changing its external functionality or behavior. In essence, refactoring can be used
 to improve the efficiency, readability, or performance of a design or the code that implements a
 design.
74
 PART ONE THE SOFTWARE PROCESS
 FIGURE 3.2
 The Extreme
 Programming
 process
 ?
 What is an
 XP “story”?
 WebRef
 A worthwhile XP
 “planning game” can
 be found at:
 c2.com/cgi/
 wiki?planningGame.
 simple design
 CRC cards
 user stories
 values
 acceptance test criteria
 iteration plan
 Release
 spike solutions
 prototypes
 refactoring
 design
 pair programming
 planning
 software increment
 project velocity computed
 unit test
 continuous integration
 acceptance testing
 test
 coding
 feel for required output and major features and functionality. Listening leads to the
 creation of a set of “stories” (also called user stories) that describe required output,
 features, and functionality for software to be built. Each story (similar to use cases
 described in Chapter 5) is written by the customer and is placed on an index card.
 The customer assigns a value (i.e., a priority) to the story based on the overall busi
ness value of the feature or function.5 Members of the XP team then assess each
 story and assign a cost—measured in development weeks—to it. If the story is esti
mated to require more than three development weeks, the customer is asked to split
 the story into smaller stories and the assignment of value and cost occurs again. It
 is important to note that new stories can be written at any time.
 Customers and developers work together to decide how to group stories into the
 next release (the next software increment) to be developed by the XP team. Once a
 basic commitment (agreement on stories to be included, delivery date, and other
 project matters) is made for a release, the XP team orders the stories that will be de
veloped in one of three ways: (1) all stories will be implemented immediately (within
 a few weeks), (2) the stories with highest value will be moved up in the schedule and
 implemented first, or (3) the riskiest stories will be moved up in the schedule and
 implemented first.
 After the first project release (also called a software increment) has been deliv
ered, the XP team computes project velocity. Stated simply, project velocity is the
 5 The value of a story may also be dependent on the presence of another story.
75
 CHAPTER 3 AGILE DEVELOPMENT
 Project velocity is a
 subtle measure of
 team productivity.
 XP deemphasizes the
 importance of design.
 Not everyone agrees.
 In fact, there are times
 when design should be
 emphasized.
 WebRef
 Refactoring techniques
 and tools can be
 found at:
 www.refactoring
 .com.
 number of customer stories implemented during the first release. Project velocity can
 then be used to (1) help estimate delivery dates and schedule for subsequent releases
 and (2) determine whether an overcommitment has been made for all stories across
 the entire development project. If an overcommitment occurs, the content of releases
 is modified or end delivery dates are changed.
 As development work proceeds, the customer can add stories, change the value
 of an existing story, split stories, or eliminate them. The XP team then reconsiders all
 remaining releases and modifies its plans accordingly.
 Design. XP design rigorously follows the KIS (keep it simple) principle. A simple
 design is always preferred over a more complex representation. In addition, the de
sign provides implementation guidance for a story as it is written—nothing less,
 nothing more. The design of extra functionality (because the developer assumes it
 will be required later) is discouraged.6
 XP encourages the use of CRC cards (Chapter 7) as an effective mechanism for
 thinking about the software in an object-oriented context. CRC (class-responsibility
collaborator) cards identify and organize the object-oriented classes7 that are rele
vant to the current software increment. The XP team conducts the design exercise
 using a process similar to the one described in Chapter 8. The CRC cards are the only
 design work product produced as part of the XP process.
 If a difficult design problem is encountered as part of the design of a story, XP rec
ommends the immediate creation of an operational prototype of that portion of the
 design. Called a spike solution, the design prototype is implemented and evaluated.
 The intent is to lower risk when true implementation starts and to validate the orig
inal estimates for the story containing the design problem.
 In the preceding section, we noted that XP encourages refactoring—a construction
 technique that is also a method for design optimization. Fowler [Fow00] describes
 refactoring in the following manner:
 Refactoring is the process of changing a software system in such a way that it does not
 alter the external behavior of the code yet improves the internal structure. It is a disci
plined way to clean up code [and modify/simplify the internal design] that minimizes the
 chances of introducing bugs. In essence, when you refactor you are improving the design
 of the code after it has been written.
 Because XP design uses virtually no notation and produces few, if any, work prod
ucts other than CRC cards and spike solutions, design is viewed as a transient arti
fact that can and should be continually modified as construction proceeds. The intent
 of refactoring is to control these modifications by suggesting small design changes
 6 These design guidelines should be followed in every software engineering method, although there
 are times when sophisticated design notation and terminology may get in the way of simplicity.
 7 Object-oriented classes are discussed in Appendix 2, in Chapter 8, and throughout Part 2 of this
 book.
76
 PART ONE THE SOFTWARE PROCESS
 Refactoring improves
 the internal structure of
 a design (or source
 code) without
 changing its external
 functionality or
 behavior.
 WebRef
 Useful information on
 XP can be obtained 
at www
 .xprogramming.
 com.
 ?
 What is 
pair
 programming?
 Many software teams
 are populated by indi
vidualists. You’ll have
 to work to change that
 culture if pair program
ming is to work effec
tively.
 ?
 XP?
 How are unit
 tests used in
 that “can radically improve the design” [Fow00]. It should be noted, however, that
 the effort required for refactoring can grow dramatically as the size of an application
 grows.
 A central notion in XP is that design occurs both before and after coding com
mences. Refactoring means that design occurs continuously as the system is con
structed. In fact, the construction activity itself will provide the XP team with
 guidance on how to improve the design.
 Coding. After stories are developed and preliminary design work is done, the team
 does not move to code, but rather develops a series of unit tests that will exercise
 each of the stories that is to be included in the current release (software increment).8
 Once the unit test9 has been created, the developer is better able to focus on what
 must be implemented to pass the test. Nothing extraneous is added (KIS). Once the
 code is complete, it can be unit-tested immediately, thereby providing instantaneous
 feedback to the developers.
 A key concept during the coding activity (and one of the most talked about aspects
 of XP) is pair programming. XP recommends that two people work together at one
 computer workstation to create code for a story. This provides a mechanism for real
time problem solving (two heads are often better than one) and real-time quality as
surance (the code is reviewed as it is created). It also keeps the developers focused
 on the problem at hand. In practice, each person takes on a slightly different role. For
 example, one person might think about the coding details of a particular portion of
 the design while the other ensures that coding standards (a required part of XP) are
 being followed or that the code for the story will satisfy the unit test that has been
 developed to validate the code against the story.
 As pair programmers complete their work, the code they develop is integrated
 with the work of others. In some cases this is performed on a daily basis by an inte
gration team. In other cases, the pair programmers have integration responsibility.
 This “continuous integration” strategy helps to avoid compatibility and interfacing
 problems and provides a “smoke testing” environment (Chapter 17) that helps to
 uncover errors early.
 Testing. I have already noted that the creation of unit tests before coding com
mences is a key element of the XP approach. The unit tests that are created should
 be implemented using a framework that enables them to be automated (hence, they
 can be executed easily and repeatedly). This encourages a regression testing strat
egy (Chapter 17) whenever code is modified (which is often, given the XP refactor
ing philosophy).
 8 This approach is analogous to knowing the exam questions before you begin to study. It makes
 studying much easier by focusing attention only on the questions that will be asked.
 9 Unit testing, discussed in detail in Chapter 17, focuses on an individual software component, exer
cising the component’s interface, data structures, and functionality in an effort to uncover errors
 that are local to the component.
77
 CHAPTER 3 AGILE DEVELOPMENT
 XP acceptance tests
 are derived from user
 stories.
 ?
 What new
 practices are
 appended to XP
 to create IXP?
 uote:
 “Ability is what
 you’re capable of
 doing. Motivation
 determines what
 you do. Attitude
 determines how
 well you do it.”
 Lou Holtz
 As the individual unit tests are organized into a “universal testing suite” [Wel99],
 integration and validation testing of the system can occur on a daily basis. This pro
vides the XP team with a continual indication of progress and also can raise warn
ing flags early if things go awry. Wells [Wel99] states: “Fixing small problems every
 few hours takes less time than fixing huge problems just before the deadline.”
 XP acceptance tests, also called customer tests, are specified by the customer and
 focus on overall system features and functionality that are visible and reviewable by
 the customer. Acceptance tests are derived from user stories that have been imple
mented as part of a software release.
 3.4.3 Industrial XP
 Joshua Kerievsky [Ker05] describes Industrial Extreme Programming (IXP) in the fol
lowing manner: “IXP is an organic evolution of XP. It is imbued with XP’s minimal
ist, customer-centric, test-driven spirit. IXP differs most from the original XP in its
 greater inclusion of management, its expanded role for customers, and its upgraded
 technical practices.” IXP incorporates six new practices that are designed to help
 ensure that an XP project works successfully for significant projects within a large
 organization.
 Readiness assessment. Prior to the initiation of an IXP project, the organ
ization should conduct a readiness assessment. The assessment ascertains
 whether (1) an appropriate development environment exists to support IXP,
 (2) the team will be populated by the proper set of stakeholders, (3) the or
ganization has a distinct quality program and supports continuous improve
ment, (4) the organizational culture will support the new values of an agile
 team, and (5) the broader project community will be populated appropriately.
 Project community. Classic XP suggests that the right people be used to
 populate the agile team to ensure success. The implication is that people on
 the team must be well-trained, adaptable and skilled, and have the proper
 temperament to contribute to a self-organizing team. When XP is to be
 applied for a significant project in a large organization, the concept of the
 “team” should morph into that of a community. A community may have a
 technologist and customers who are central to the success of a project as
 well as many other stakeholders (e.g., legal staff, quality auditors, manufac
turing or sales types) who “are often at the periphery of an IXP project yet
 they may play important roles on the project” [Ker05]. In IXP, the community
 members and their roles should be explicitly defined and mechanisms for
 communication and coordination between community members should be
 established.
 Project chartering. The IXP team assesses the project itself to determine
 whether an appropriate business justification for the project exists and
 whether the project will further the overall goals and objectives of the
78
 PART ONE THE SOFTWARE PROCESS
 organization. Chartering also examines the context of the project to deter
mine how it complements, extends, or replaces existing systems or
 processes.
 Test-driven management. An IXP project requires measurable criteria for
 assessing the state of the project and the progress that has been made to
 date. Test-driven management establishes a series of measurable “destina
tions” [Ker05] and then defines mechanisms for determining whether or not
 these destinations have been reached.
 Retrospectives. An IXP team conducts a specialized technical review
 (Chapter 15) after a software increment is delivered. Called a retrospective,
 the review examines “issues, events, and lessons-learned” [Ker05] across a
 software increment and/or the entire software release. The intent is to
 improve the IXP process.
 Continuous learning. Because learning is a vital part of continuous
 process improvement, members of the XP team are encouraged (and possi
bly, incented) to learn new methods and techniques that can lead to a higher
quality product.
 In addition to the six new practices discussed, IXP modifies a number of existing
 XP practices. Story-driven development (SDD) insists that stories for acceptance tests
 be written before a single line of code is generated. Domain-driven design (DDD) is
 an improvement on the “system metaphor” concept used in XP. DDD [Eva03] sug
gests the evolutionary creation of a domain model that “accurately represents how
 domain experts think about their subject” [Ker05]. Pairing extends the XP pair
programming concept to include managers and other stakeholders. The intent is to
 improve knowledge sharing among XP team members who may not be directly in
volved in technical development. Iterative usability discourages front-loaded inter
face design in favor of usability design that evolves as software increments are
 delivered and users’ interaction with the software is studied.
 IXP makes smaller modifications to other XP practices and redefines certain roles
 and responsibilities to make them more amenable to significant projects for large
 organizations. For further discussion of IXP, visit http://industrialxp.org.
 3.4.4 The XP Debate
 All new process models and methods spur worthwhile discussion and in some in
stances heated debate. Extreme Programming has done both. In an interesting book
 that examines the efficacy of XP, Stephens and Rosenberg [Ste03] argue that many
 XP practices are worthwhile, but others have been overhyped, and a few are prob
lematic. The authors suggest that the codependent nature of XP practices are both
 its strength and its weakness. Because many organizations adopt only a subset of XP
 practices, they weaken the efficacy of the entire process. Proponents counter that
 XP is continuously evolving and that many of the issues raised by critics have been
79
 CHAPTER 3 AGILE DEVELOPMENT
 addressed as XP practice matures. Among the issues that continue to trouble some
 critics of XP are:10
 ?
 What are
 some of the
 issues that lead to
 an XP debate?
 • Requirements volatility. Because the customer is an active member of the XP
 team, changes to requirements are requested informally. As a consequence,
 the scope of the project can change and earlier work may have to be
 modified to accommodate current needs. Proponents argue that this happens
 regardless of the process that is applied and that XP provides mechanisms for
 controlling scope creep.
 • Conflicting customer needs. Many projects have multiple customers, each with
 his own set of needs. In XP, the team itself is tasked with assimilating the
 needs of different customers, a job that may be beyond their scope of
 authority.
 • Requirements are expressed informally. User stories and acceptance tests are
 the only explicit manifestation of requirements in XP. Critics argue that a
 more formal model or specification is often needed to ensure that omissions,
 inconsistencies, and errors are uncovered before the system is built. Propo
nents counter that the changing nature of requirements makes such models
 and specification obsolete almost as soon as they are developed.
 • Lack of formal design. XP deemphasizes the need for architectural design and
 in many instances, suggests that design of all kinds should be relatively
 informal. Critics argue that when complex systems are built, design must be
 emphasized to ensure that the overall structure of the software will exhibit
 quality and maintainability. XP proponents suggest that the incremental
 nature of the XP process limits complexity (simplicity is a core value) and
 therefore reduces the need for extensive design.
 You should note that every software process has flaws and that many software or
ganizations have used XP successfully. The key is to recognize where a process may
 have weaknesses and to adapt it to the specific needs of your organization.
 SAFEHOME
 Considering Agile Software Development
 The scene: Doug Miller’s office.
 The Players: Doug Miller, software engineering
 manager; Jamie Lazar, software team member; Vinod
 Raman, software team member.
 The conversation:
 (A knock on the door, Jamie and Vinod enter Doug’s office)
 Jamie: Doug, you got a minute?
 10 For a detailed look at some thoughtful criticism that has been leveled at XP, visit
 www.softwarereality.com/ExtremeProgramming.jsp.
3.5 OTHERAGILEPROCESSMODELS
 The history of software engineering is littered with dozens of obsolete process
 descriptions and methodologies, modeling methods and notations, tools, and
 technology. Each flared in notoriety and was then eclipsed by something new and
 (purportedly) better. With the introduction of a wide array of agile process models—
 each contending for acceptance within the software development community—the
 agile movement is following the same historical path.11
 As I noted in the last section, the most widely used of all agile process models
 isExtreme Programming (XP). But many other agile process models have been
 proposed and are in use across the industry. Among the most common are:
 •Adaptive Software Development (ASD)
 •Scrum
 •Dynamic Systems Development Method (DSDM)
 80 PART ONE THE SOFTWARE PROCESS
 Doug: Sure Jamie, what’s up?
 Jamie:We’ve been thinking about our process
 discussion yesterday . . . you know, what process we’re
 going to choose for this new SafeHomeproject.
 Doug:And?
 Vinod: I was talking to a friend at another company,
 and he was telling me about Extreme Programming. It’s
 an agile process model . . . heard of it?
 Doug: Yeah, some good, some bad.
 Jamie:Well, it sounds pretty good to us. Lets you
 develop software really fast, uses something called pair
 programming to do real-time quality checks . . . it’s pretty
 cool, I think.
 Doug: It does have a lot of really good ideas. I like the
 pair-programming concept, for instance, and the idea
 that stakeholders should be part of the team.
 Jamie:Huh? You mean that marketing will work on the
 project team with us?
 Doug (nodding): They’re a stakeholder, aren’t they?
 Jamie: Jeez . . . they’ll be requesting changes every five
 minutes.
 Vinod:Not necessarily. My friend said that there are
 ways to “embrace” changes during an XP project.
 Doug: So you guys think we should use XP?
 Jamie: It’s definitely worth considering.
 Doug: I agree. And even if we choose an incremental
 model as our approach, there’s no reason why we can’t
 incorporate much of what XP has to offer.
 Vinod:Doug, before you said “some good, some bad.”
 What was the “bad”?
 Doug: The thing I don’t like is the way XP downplays
 analysis and design . . . sort of says that writing code is
 where the action is . . . 
(The team members look at one another and smile.)
 Doug: So you agree with the XP approach?
 Jamie (speaking for both):Writing code is what
 we do, Boss!
 Doug (laughing): True, but I’d like to see you spend a
 little less time coding and then recoding and a little more
 time analyzing what has to be done and designing a
 solution that works.
 Vinod:Maybe we can have it both ways, agility with a
 little discipline.
 Doug: I think we can, Vinod. In fact, I’m sure of it.
 uote:
 “Our profession
 goes through
 methodologies like
 a 14-year-old goes
 through clothing.”
 Stephen
 Hawrysh and
 JimRuprecht
 11This is not a bad thing. Before one or more models or methods are accepted as a de facto standard,
 all must contend for the hearts and minds of software engineers. The “winners” evolve into best
 practice, while the “losers” either disappear or merge with the winning models.
81
 CHAPTER 3 AGILE DEVELOPMENT
 • Crystal
 • Feature Drive Development (FDD)
 • Lean Software Development (LSD)
 • Agile Modeling (AM)
 • Agile Unified Process (AUP)
 In the sections that follow, I present a very brief overview of each of these agile
 process models. It is important to note that all agile process models conform (to a
 greater or lesser degree) to the Manifesto for Agile Software Development and the prin
ciples noted in Section 3.3.1. For additional detail, refer to the references noted in
 each subsection or for a survey, examine the “agile software development” entry
 in Wikipedia.12
 3.5.1 Adaptive Software Development (ASD)
 WebRef
 Useful resources for
 ASD can be found at
 www.adaptivesd
 .com.
 Adaptive Software Development (ASD) has been proposed by Jim Highsmith [Hig00] as
 a technique for building complex software and systems. The philosophical under
pinnings of ASD focus on human collaboration and team self-organization.
 Highsmith argues that an agile, adaptive development approach based on collab
oration is “as much a source of order in our complex interactions as discipline and
 engineering.” He defines an ASD “life cycle” (Figure 3.3) that incorporates three
 phases, speculation, collaboration, and learning.
 FIGURE 3.3
 Adaptive
 software
 development
 adaptive cycle planning
 mission statement
 project constraints
 basic requirements
 time-boxed release plan
 Release
 Requirements gathering
 JAD
 mini-specs
 speculation
 software increment
 adjustments for subsequent cycles
 collaboration
 components implemented/tested
 focus groups for feedback
 formal technical reviews
 learning
 postmortems
 12 See http://en.wikipedia.org/wiki/Agile_software_development#Agile_methods.
82
 PART ONE THE SOFTWARE PROCESS
 Effective collaboration
 with your customer will
 only occur if you
 jettison any “us and
 them” attitudes.
 ASD emphasizes
 learning as a key
 element in achieving 
a “self-organizing”
 team.
 WebRef
 Useful Scrum
 information and
 resources can be found
 at www
 .controlchaos.com.
 During speculation, the project is initiated and adaptive cycle planning is con
ducted. Adaptive cycle planning uses project initiation information—the customer’s
 mission statement, project constraints (e.g., delivery dates or user descriptions), and
 basic requirements—to define the set of release cycles (software increments) that
 will be required for the project.
 No matter how complete and farsighted the cycle plan, it will invariably change.
 Based on information obtained at the completion of the first cycle, the plan is re
viewed and adjusted so that planned work better fits the reality in which an ASD
 team is working.
 Motivated people use collaboration in a way that multiplies their talent and cre
ative output beyond their absolute numbers. This approach is a recurring theme in
 all agile methods. But collaboration is not easy. It encompasses communication and
 teamwork, but it also emphasizes individualism, because individual creativity plays
 an important role in collaborative thinking. It is, above all, a matter of trust. People
 working together must trust one another to (1) criticize without animosity, (2) assist
 without resentment, (3) work as hard as or harder than they do, (4) have the skill set
 to contribute to the work at hand, and (5) communicate problems or concerns in a
 way that leads to effective action.
 As members of an ASD team begin to develop the components that are part of an
 adaptive cycle, the emphasis is on “learning” as much as it is on progress toward
 a completed cycle. In fact, Highsmith [Hig00] argues that software developers often
 overestimate their own understanding (of the technology, the process, and the proj
ect) and that learning will help them to improve their level of real understanding.
 ASD teams learn in three ways: focus groups (Chapter 5), technical reviews (Chap
ter 14), and project postmortems.
 The ASD philosophy has merit regardless of the process model that is used. ASD’s
 overall emphasis on the dynamics of self-organizing teams, interpersonal collabo
ration, and individual and team learning yield software project teams that have a
 much higher likelihood of success.
 3.5.2 Scrum
 Scrum (the name is derived from an activity that occurs during a rugby match13) is
 an agile software development method that was conceived by Jeff Sutherland and his
 development team in the early 1990s. In recent years, further development on the
 Scrum methods has been performed by Schwaber and Beedle [Sch01a].
 Scrum principles are consistent with the agile manifesto and are used to guide
 development activities within a process that incorporates the following framework
 activities: requirements, analysis, design, evolution, and delivery. Within each
 13 A group of players forms around the ball and the teammates work together (sometimes violently!)
 to move the ball downfield.
every 24
 hours
 30 days
 Scrum: 15 minute daily meeting.
 Team members respond to basics:
 1) What did you do since last Scrum
 meeting?
 2) Do you have any obstacles?
 3) What will you do before next
 meeting?
 Sprint Backlog:
 Feature(s)
 assigned
 to sprint
 Product Backlog:
 Prioritized product features desired by the customer
 Backlog
 items
 expanded
 by team
 New functionality
 is demonstrated
 at end of sprint
 framework activity, work tasks occur within a process pattern (discussed in the fol
lowing paragraph) called a sprint.The work conducted within a sprint (the number
 of sprints required for each framework activity will vary depending on product com
plexity and size) is adapted to the problem at hand and is defined and often modified
 in real time by the Scrum team. The overall flow of the Scrum process is illustrated
 in Figure 3.4.
 Scrum emphasizes the use of a set of software process patterns [Noy02] that have
 proven effective for projects with tight timelines, changing requirements, and business
 criticality. Each of these process patterns defines a set of development actions:
 Backlog—a prioritized list of project requirements or features that provide busi
ness value for the customer. Items can be added to the backlog at any time (this is
 how changes are introduced). The product manager assesses the backlog and
 updates priorities as required.
 Sprints—consist of work units that are required to achieve a requirement de
fined in the backlog that must be fit into a predefined time-box14(typically 30 days).
 CHAPTER 3 AGILE DEVELOPMENT 83
 14A time-boxis a project management term (see Part 4 of this book) that indicates a period of time
 that has been allocated to accomplish some task.
 FIGURE3.4
 Scrum process
 flow
 Scrum incorporates a
 set of process patterns
 that emphasize project
 priorities,
 compartmentalized
 work units,
 communication, and
 frequent customer
 feedback.
84
 PART ONE THE SOFTWARE PROCESS
 Changes (e.g., backlog work items) are not introduced during the sprint. Hence, the
 sprint allows team members to work in a short-term, but stable environment.
 Scrum meetings—are short (typically 15 minutes) meetings held daily by the Scrum
 team. Three key questions are asked and answered by all team members [Noy02]:
 • What did you do since the last team meeting?
 • What obstacles are you encountering?
 • What do you plan to accomplish by the next team meeting?
 A team leader, called a Scrum master, leads the meeting and assesses the responses
 from each person. The Scrum meeting helps the team to uncover potential problems
 as early as possible. Also, these daily meetings lead to “knowledge socialization”
 [Bee99] and thereby promote a self-organizing team structure.
 Demos—deliver the software increment to the customer so that functionality that
 has been implemented can be demonstrated and evaluated by the customer. It is im
portant to note that the demo may not contain all planned functionality, but rather
 those functions that can be delivered within the time-box that was established.
 Beedle and his colleagues [Bee99] present a comprehensive discussion of these pat
terns in which they state: “Scrum assumes up-front the existence of chaos. . . . ” The
 Scrum process patterns enable a software team to work successfully in a world
 where the elimination of uncertainty is impossible.
 3.5.3 Dynamic Systems Development Method (DSDM)
 WebRef
 Useful resources for
 DSSD can be found at
 www.dsdm.org.
 The Dynamic Systems Development Method (DSDM) [Sta97] is an agile software devel
opment approach that “provides a framework for building and maintaining systems
 which meet tight time constraints through the use of incremental prototyping in a con
trolled project environment” [CCS02]. The DSDM philosophy is borrowed from a mod
ified version of the Pareto principle—80 percent of an application can be delivered in
 20 percent of the time it would take to deliver the complete (100 percent) application.
 DSDM is an iterative software process in which each iteration follows the 80 per
cent rule. That is, only enough work is required for each increment to facilitate
 movement to the next increment. The remaining detail can be completed later when
 more business requirements are known or changes have been requested and
 accommodated.
 The DSDM Consortium (www.dsdm.org) is a worldwide group of member com
panies that collectively take on the role of “keeper” of the method. The consortium
 has defined an agile process model, called the DSDM life cycle that defines three dif
ferent iterative cycles, preceded by two additional life cycle activities:
 Feasibility study—establishes the basic business requirements and constraints
 associated with the application to be built and then assesses whether the applica
tion is a viable candidate for the DSDM process.
85
 CHAPTER 3 AGILE DEVELOPMENT
 DSDM is a process
 framework that can
 adopt the tactics of
 another agile approach
 such as XP.
 Crystal is a family of
 process models with
 the same “genetic
 code” but different
 methods for adapting
 to project
 characteristics.
 Business study—establishes the functional and information requirements that
 will allow the application to provide business value; also, defines the basic
 application architecture and identifies the maintainability requirements for the
 application.
 Functional model iteration—produces a set of incremental prototypes that
 demonstrate functionality for the customer. (Note: All DSDM prototypes are in
tended to evolve into the deliverable application.) The intent during this iterative
 cycle is to gather additional requirements by eliciting feedback from users as they
 exercise the prototype.
 Design and build iteration—revisits prototypes built during functional model
 iteration to ensure that each has been engineered in a manner that will enable it to
 provide operational business value for end users. In some cases, functional model
 iteration and design and build iteration occur concurrently.
 Implementation—places the latest software increment (an “operationalized” pro
totype) into the operational environment. It should be noted that (1) the increment
 may not be 100 percent complete or (2) changes may be requested as the incre
ment is put into place. In either case, DSDM development work continues by
 returning to the functional model iteration activity.
 DSDM can be combined with XP (Section 3.4) to provide a combination approach
 that defines a solid process model (the DSDM life cycle) with the nuts and bolts prac
tices (XP) that are required to build software increments. In addition, the ASD con
cepts of collaboration and self-organizing teams can be adapted to a combined
 process model.
 3.5.4 Crystal
 Alistair Cockburn [Coc05] and Jim Highsmith [Hig02b] created the Crystal family of
 agile methods15 in order to achieve a software development approach that puts a
 premium on “maneuverability” during what Cockburn characterizes as “a resource
limited, cooperative game of invention and communication, with a primary goal of
 delivering useful, working software and a secondary goal of setting up for the next
 game” [Coc02].
 To achieve maneuverability, Cockburn and Highsmith have defined a set of
 methodologies, each with core elements that are common to all, and roles, process
 patterns, work products, and practice that are unique to each. The Crystal family is
 actually a set of example agile processes that have been proven effective for differ
ent types of projects. The intent is to allow agile teams to select the member of the
 crystal family that is most appropriate for their project and environment.
 15 The name “crystal” is derived from the characteristics of geological crystals, each with its own
 color, shape, and hardness.
86
 PART ONE THE SOFTWARE PROCESS
 3.5.5 Feature Driven Development (FDD)
 WebRef
 A wide variety of
 articles and
 presentations on FDD
 can be found at:
 www.featuredrive
 ndevelopment
 .com/.
 Feature Driven Development (FDD) was originally conceived by Peter Coad and his
 colleagues [Coa99] as a practical process model for object-oriented software engi
neering. Stephen Palmer and John Felsing [Pal02] have extended and improved
 Coad’s work, describing an adaptive, agile process that can be applied to moderately
 sized and larger software projects.
 Like other agile approaches, FDD adopts a philosophy that (1) emphasizes col
laboration among people on an FDD team; (2) manages problem and project
 complexity using feature-based decomposition followed by the integration of
 software increments, and (3) communication of technical detail using verbal,
 graphical, and text-based means. FDD emphasizes software quality assurance
 activities by encouraging an incremental development strategy, the use of design
 and code inspections, the application of software quality assurance audits (Chap
ter 16), the collection of metrics, and the use of patterns (for analysis, design, and
 construction).
 In the context of FDD, a feature “is a client-valued function that can be imple
mented in two weeks or less” [Coa99]. The emphasis on the definition of features
 provides the following benefits:
 • Because features are small blocks of deliverable functionality, users can
 describe them more easily; understand how they relate to one another more
 readily; and better review them for ambiguity, error, or omissions.
 • Features can be organized into a hierarchical business-related grouping.
 • Since a feature is the FDD deliverable software increment, the team develops
 operational features every two weeks.
 • Because features are small, their design and code representations are easier
 to inspect effectively.
 • Project planning, scheduling, and tracking are driven by the feature
 hierarchy, rather than an arbitrarily adopted software engineering 
task set.
 Coad and his colleagues [Coa99] suggest the following template for defining a
 feature:
 <action> the <result> <by for of to> a(n) <object>
 where an <object> is “a person, place, or thing (including roles, moments in time or
 intervals of time, or catalog-entry-like descriptions).” Examples of features for an 
e-commerce application might be:
 Add the product to shopping cart
 Display the technical-specifications of the product
 Store the shipping-information for the customer
87
 CHAPTER 3 AGILE DEVELOPMENT
 FIGURE 3.5
 Feature Driven
 Development
 [Coa99] (with
 permission)
 Develop
 an
 Overall
 Model
 Build a
 Features
 List
 Plan
 By
 Feature
 Design
 By
 Feature
 (more shape
 than content)
 A list of features
 grouped into sets
 and subject areas
 A development plan
 Class owners
 Feature Set Owners
 A design
 package
 (sequences)
 Build
 By
 Feature
 Completed
 client-value
 function
 A feature set groups related features into business-related categories and is defined
 [Coa99] as:
 <action><-ing> a(n) <object>
 For example: Making a product sale is a feature set that would encompass the fea
tures noted earlier and others.
 The FDD approach defines five “collaborating” [Coa99] framework activities (in
 FDD these are called “processes”) as shown in Figure 3.5.
 FDD provides greater emphasis on project management guidelines and tech
niques than many other agile methods. As projects grow in size and complexity,
 ad hoc project management is often inadequate. It is essential for developers, their
 managers, and other stakeholders to understand project status—what accomplish
ments have been made and problems have been encountered. If deadline pressure
 is significant, it is critical to determine if software increments (features) are properly
 scheduled. To accomplish this, FDD defines six milestones during the design and
 implementation of a feature: “design walkthrough, design, design inspection, code,
 code inspection, promote to build” [Coa99].
 3.5.6 Lean Software Development (LSD)
 Lean Software Development (LSD) has adapted the principles of lean manufacturing
 to the world of software engineering. The lean principles that inspire the LSD process
 can be summarized ([Pop03], [Pop06a]) as eliminate waste, build quality in, create
 knowledge, defer commitment, deliver fast, respect people, and optimize the whole.
 Each of these principles can be adapted to the software process. For example,
 eliminate waste within the context of an agile software project can be interpreted
 to mean [Das05]: (1) adding no extraneous features or functions, (2) assessing the
 cost and schedule impact of any newly requested requirement, (3) removing any
 superfluous process steps, (4) establishing mechanisms to improve the way team
 members find information, (5) ensuring the testing finds as many errors as possible,
88
 PART ONE THE SOFTWARE PROCESS
 (6) reducing the time required to request and get a decision that affects the software
 or the process that is applied to create it, and (7) streamlining the manner in which
 information is transmitted to all stakeholders involved in the process.
 For a detailed discussion of LSD and pragmatic guidelines for implementing the
 process, you should examine [Pop06a] and [Pop06b].
 3.5.7 Agile Modeling (AM)
 WebRef
 Comprehensive
 information on agile
 modeling can be found
 at: www
 .agilemodeling.com.
 uote:
 “I was in the drug
 store the other day
 trying to get a cold
 medication . . . not
 easy. There’s an
 entire wall of
 products you need.
 You stand there
 going, Well, this
 one is quick acting
 but this is long
 lasting. . . . Which
 is more important,
 the present or the
 future?”
 Jerry Seinfeld
 There are many situations in which software engineers must build large, business
critical systems. The scope and complexity of such systems must be modeled so that
 (1) all constituencies can better understand what needs to be accomplished, (2) the
 problem can be partitioned effectively among the people who must solve it, and
 (3) quality can be assessed as the system is being engineered and built.
 Over the past 30 years, a wide variety of software engineering modeling methods
 and notation have been proposed for analysis and design (both architectural and
 component-level). These methods have merit, but they have proven to be difficult
 to apply and challenging to sustain (over many projects). Part of the problem is the
 “weight” of these modeling methods. By this I mean the volume of notation required,
 the degree of formalism suggested, the sheer size of the models for large projects,
 and the difficulty in maintaining the model(s) as changes occur. Yet analysis and de
sign modeling have substantial benefit for large projects—if for no other reason than
 to make these projects intellectually manageable. Is there an agile approach to soft
ware engineering modeling that might provide an alternative?
 At “The Official Agile Modeling Site,” Scott Ambler [Amb02a] describes agile mod
eling (AM) in the following manner:
 Agile Modeling (AM) is a practice-based methodology for effective modeling and documen
tation of software-based systems. Simply put, Agile Modeling (AM) is a collection of values,
 principles, and practices for modeling software that can be applied on a software develop
ment project in an effective and light-weight manner. Agile models are more effective than
 traditional models because they are just barely good, they don’t have to be perfect.
 Agile modeling adopts all of the values that are consistent with the agile manifesto.
 The agile modeling philosophy recognizes that an agile team must have the courage
 to make decisions that may cause it to reject a design and refactor. The team must
 also have the humility to recognize that technologists do not have all the answers and
 that business experts and other stakeholders should be respected and embraced.
 Although AM suggests a wide array of “core” and “supplementary” modeling prin
ciples, those that make AM unique are [Amb02a]:
 Model with a purpose. A developer who uses AM should have a specific
 goal (e.g., to communicate information to the customer or to help better un
derstand some aspect of the software) in mind before creating the model.
 Once the goal for the model is identified, the type of notation to be used and
 level of detail required will be more obvious.
89
 CHAPTER 3 AGILE DEVELOPMENT
 Use multiple models. There are many different models and notations that
 can be used to describe software. Only a small subset is essential for most
 projects. AM suggests that to provide needed insight, each model should
 present a different aspect of the system and only those models that provide
 value to their intended audience should be used.
 “Traveling light” is an
 appropriate philosophy
 for all software engi
neering work. Build
 only those models that
 provide value … no
 more, no less.
 Travel light. As software engineering work proceeds, keep only those mod
els that will provide long-term value and jettison the rest. Every work product
 that is kept must be maintained as changes occur. This represents work that
 slows the team down. Ambler [Amb02a] notes that “Every time you decide to
 keep a model you trade-off agility for the convenience of having that informa
tion available to your team in an abstract manner (hence potentially enhanc
ing communication within your team as well as with project stakeholders).”
 Content is more important than representation. Modeling should im
part information to its intended audience. A syntactically perfect model that
 imparts little useful content is not as valuable as a model with flawed nota
tion that nevertheless provides valuable content for its audience.
 Know the models and the tools you use to create them. Understand
 the strengths and weaknesses of each model and the tools that are used to
 create it.
 Adapt locally. The modeling approach should be adapted to the needs of
 the agile team.
 A major segment of the software engineering community has adopted the Unified
 Modeling Language (UML)16 as the preferred method for representing analysis and
 design models. The Unified Process (Chapter 2) has been developed to provide a
 framework for the application of UML. Scott Ambler [Amb06] has developed a sim
plified version of the UP that integrates his agile modeling philosophy.
 3.5.8 Agile Unified Process (AUP)
 The Agile Unified Process (AUP) adopts a “serial in the large” and “iterative in the
 small” [Amb06] philosophy for building computer-based systems. By adopting the
 classic UP phased activities—inception, elaboration, construction, and transition—AUP
 provides a serial overlay (i.e., a linear sequence of software engineering activities)
 that enables a team to visualize the overall process flow for a software project. How
ever, within each of the activities, the team iterates to achieve agility and to deliver
 meaningful software increments to end users as rapidly as possible. Each AUP iter
ation addresses the following activities [Amb06]: 
• Modeling. UML representations of the business and problem domains are
 created. However, to stay agile, these models should be “just barely good
 enough” [Amb06] to allow the team to proceed.
 16 A brief tutorial on UML is presented in Appendix 1.
90
 PART ONE THE SOFTWARE PROCESS
 • Implementation. Models are translated into source code.
 • Testing. Like XP, the team designs and executes a series of tests to uncover
 errors and ensure that the source code meets its requirements.
 • Deployment. Like the generic process activity discussed in Chapters 1 and 2,
 deployment in this context focuses on the delivery of a software increment
 and the acquisition of feedback from end users.
 • Configuration and project management. In the context of AUP, configuration
 management (Chapter 22) addresses change management, risk manage
ment, and the control of any persistent work products17 that are produced by
 the team. Project management tracks and controls the progress of the team
 and coordinates team activities.
 • Environment management. Environment management coordinates a process
 infrastructure that includes standards, tools, and other support technology
 available to the team.
 Although the AUP has historical and technical connections to the Unified Modeling
 Language, it is important to note that UML modeling can be using in conjunction
 with any of the agile process models described in Section 3.5.
 SOFTWARE TOOLS
 Agile Development
 Objective: The objective of agile development
 tools is to assist in one or more aspects of agile
 development with an emphasis on facilitating the rapid
 generation of operational software. These tools can also
 be used when prescriptive process models (Chapter 2) are
 applied.
 Mechanics: Tool mechanics vary. In general, agile tool
 sets encompass automated support for project planning,
 use case development and requirements gathering, rapid
 design, code generation, and testing.
 Representative Tools:18
 Note: Because agile development is a hot topic, most
 software tools vendors purport to sell tools that support 
the agile approach. The tools noted here have
 characteristics that make them particularly useful for
 agile projects.
 OnTime, developed by Axosoft (www.axosoft.com),
 provides agile process management support for
 various technical activities within the process.
 Ideogramic UML, developed by Ideogramic
 (www.ideogramic.com) is a UML tool set
 specifically developed for use within an agile 
process.
 Together Tool Set, distributed by Borland
 (www.borland.com), provides a tools suite that
 supports many technical activities within XP and other
 agile processes.
 17 A persistent work product is a model or document or test case produced by the team that will be kept
 for an indeterminate period of time. It will not be discarded once the software increment is
 delivered.
 18 Tools noted here do not represent an endorsement, but rather a sampling of tools in this category.
 In most cases, tool names are trademarked by their respective developers.
91
 CHAPTER 3 AGILE DEVELOPMENT
 3.6 A TOOL SET FOR THE AGILE PROCESS
 The “tool set” that
 supports agile
 processes focuses
 more on people issues
 than it does on
 technology issues.
 Some proponents of the agile philosophy argue that automated software tools (e.g.,
 design tools) should be viewed as a minor supplement to the team’s activities, and
 not at all pivotal to the success of the team. However, Alistair Cockburn [Coc04] sug
gests that tools can have a benefit and that “agile teams stress using tools that per
mit the rapid flow of understanding. Some of those tools are social, starting even at
 the hiring stage. Some tools are technological, helping distributed teams simulate
 being physically present. Many tools are physical, allowing people to manipulate
 them in workshops.”
 Because acquiring the right people (hiring), team collaboration, stakeholder com
munication, and indirect management are key elements in virtually all agile process
 models, Cockburn argues that “tools” that address these issues are critical success
 factors for agility. For example, a hiring “tool” might be the requirement to have a
 prospective team member spend a few hours pair programming with an existing
 member of the team. The “fit” can be assessed immediately.
 Collaborative and communication “tools” are generally low tech and incorporate
 any mechanism (“physical proximity, whiteboards, poster sheets, index cards, and
 sticky notes” [Coc04]) that provides information and coordination among agile de
velopers. Active communication is achieved via the team dynamics (e.g., pair pro
gramming), while passive communication is achieved by “information radiators”
 (e.g., a flat panel display that presents the overall status of different components of
 an increment). Project management tools deemphasize the Gantt chart and replace
 it with earned value charts or “graphs of tests created versus passed . . . other agile
 tools are used to optimize the environment in which the agile team works (e.g., more
 efficient meeting areas), improve the team culture by nurturing social interactions
 (e.g., collocated teams), physical devices (e.g., electronic whiteboards), and process
 enhancement (e.g., pair programming or time-boxing)” [Coc04].
 Are any of these things really tools? They are, if they facilitate the work performed
 by an agile team member and enhance the quality of the end product.
 3.7 SUMMARY
 In a modern economy, market conditions change rapidly, customer and end-user
 needs evolve, and new competitive threats emerge without warning. Practitioners
 must approach software engineering in a manner that allows them to remain agile—
 to define maneuverable, adaptive, lean processes that can accommodate the needs
 of modern business.
 An agile philosophy for software engineering stresses four key issues: the impor
tance of self-organizing teams that have control over the work they perform, com
munication and collaboration between team members and between practitioners
 and their customers, a recognition that change represents an opportunity, and
92
 PART ONE THE SOFTWARE PROCESS
 an emphasis on rapid delivery of software that satisfies the customer. Agile process
 models have been designed to address each of these issues.
 Extreme programming (XP) is the most widely used agile process. Organized as
 four framework activities—planning, design, coding, and testing—XP suggests a
 number of innovative and powerful techniques that allow an agile team to create
 frequent software releases that deliver features and functionality that have been de
scribed and then prioritized by stakeholders.
 Other agile process models also stress human collaboration and team self
organization, but define their own framework activities and select different points of
 emphasis. For example, ASD uses an iterative process that incorporates adaptive
 cycle planning, relatively rigorous requirement gathering methods, and an iterative
 development cycle that incorporates customer focus groups and formal technical re
views as real-time feedback mechanisms. Scrum emphasizes the use of a set of soft
ware process patterns that have proven effective for projects with tight time lines,
 changing requirements, and business criticality. Each process pattern defines a set
 of development tasks and allows the Scrum team to construct a process that is
 adapted to the needs of the project. The Dynamic Systems Development Method
 (DSDM) advocates the use of time-box scheduling and suggests that only enough
 work is required for each software increment to facilitate movement to the next
 increment. Crystal is a family of agile process models that can be adopted to the spe
cific characteristics of a project.
 Feature Driven Development (FDD) is somewhat more “formal” than other agile
 methods, but still maintains agility by focusing the project team on the development
 of features—a client-valued function that can be implemented in two weeks or less.
 Lean Software Development (LSD) has adapted the principles of lean manufacturing
 to the world of software engineering. Agile modeling (AM) suggests that modeling is
 essential for all systems, but that the complexity, type, and size of the model must be
 tuned to the software to be built. The Agile Unified Process (AUP) adopts a “serial in
 the large” and “iterative in the small” philosophy for building software.
 PROBLEMS AND POINTS TO PONDER
 3.1. Reread “The Manifesto for Agile Software Development” at the beginning of this chapter.
 Can you think of a situation in which one or more of the four “values” could get a software team
 into trouble?
 3.2. Describe agility (for software projects) in your own words.
 3.3. Why does an iterative process make it easier to manage change? Is every agile process dis
cussed in this chapter iterative? Is it possible to complete a project in just one iteration and still
 be agile? Explain your answers.
 3.4. Could each of the agile processes be described using the generic framework activities
 noted in Chapter 2? Build a table that maps the generic activities into the activities defined for
 each agile process.
 3.5. Try to come up with one more “agility principle” that would help a software engineering
 team become even more maneuverable.
93
 CHAPTER 3 AGILE DEVELOPMENT
 3.6. Select one agility principle noted in Section 3.3.1 and try to determine whether each of the
 process models presented in this chapter exhibits the principle. [Note: I have presented an
 overview of these process models only, so it may not be possible to determine whether a prin
ciple has been addressed by one or more of the models, unless you do additional research
 (which is not required for this problem).]
 3.7. Why do requirements change so much? After all, don’t people know what they want?
 3.8. Most agile process models recommend face-to-face communication. Yet today, members
 of a software team and their customers may be geographically separated from one another. Do
 you think this implies that geographical separation is something to avoid? Can you think of ways
 to overcome this problem?
 3.9. Write an XP user story that describes the “favorite places” or “bookmarks” feature avail
able on most Web browsers.
 3.10. What is a spike solution in XP?
 3.11. Describe the XP concepts of refactoring and pair programming in your own words.
 3.12. Do a bit more reading and describe what a time-box is. How does this assist an ASD team
 in delivering software increments in a short time period?
 3.13. Do the 80 percent rule in DSDM and the time-boxing approach defined for ASD achieve
 the same result?
 3.14. Using the process pattern template presented in Chapter 2, develop a process pattern for
 any one of the Scrum patterns presented in Section 3.5.2.
 3.15. Why is Crystal called a family of agile methods?
 3.16. Using the FDD feature template described in Section 3.5.5, define a feature set for a Web
 browser. Now develop a set of features for the feature set.
 3.17. Visit the Official Agile Modeling Site and make a complete list of all core and supple
mentary AM principles.
 3.18. The tool set proposed in Section 3.6 supports many of the “soft” aspects of agile meth
ods. Since communication is so important, recommend an actual tool set that might be used to
 enhance communication among stakeholders on an agile team.
 FURTHER READINGS AND INFORMATION SOURCES
 The overall philosophy and underlying principles of agile software development are considered
 in depth in many of the books referenced in the body of this chapter. In addition, books by Shaw
 and Warden (The Art of Agile Development, O’Reilly Media, Inc., 2008), Hunt (Agile Software Con
struction, Springer, 2005), and Carmichael and Haywood (Better Software Faster, Prentice-Hall,
 2002) present useful discussions of the subject. Aguanno (Managing Agile Projects, Multi
Media Publications, 2005), Highsmith (Agile Project Management: Creating Innovative Products,
 Addison-Wesley, 2004), and Larman (Agile and Iterative Development: A Manager’s Guide,
 Addison-Wesley, 2003) present a management overview and consider project management
 issues. Highsmith (Agile Software Development Ecosystems, Addison-Wesley, 2002) presents a
 survey of agile principles, processes, and practices. A worthwhile discussion of the delicate bal
ance between agility and discipline is presented by Booch and his colleagues (Balancing Agility
 and Discipline, Addison-Wesley, 2004).
 Martin (Clean Code: A Handbook of Agile Software Craftsmanship, Prentice-Hall, 2009) pres
ents the principles, patterns, and practices required to develop “clean code” in an agile software
 engineering environment. Leffingwell (Scaling Software Agility: Best Practices for Large Enter
prises, Addison-Wesley, 2007) discusses strategies for scaling up agile practices for large proj
ects. Lippert and Rook (Refactoring in Large Software Projects: Performing Complex Restructurings
 Successfully, Wiley, 2006) discuss the use of refactoring when applied in large, complex systems.
94
 PART ONE THE SOFTWARE PROCESS
 Stamelos and Sfetsos (Agile Software Development Quality Assurance, IGI Global, 2007) discuss
 SQA techniques that conform to the agile philosophy.
 Dozens of books have been written about Extreme Programming over the past decade. Beck
 (Extreme Programming Explained: Embrace Change, 2d ed., Addison-Wesley, 2004) remains the
 definitive treatment of the subject. In addition, Jeffries and his colleagues (Extreme Programming
 Installed, Addison-Wesley, 2000), Succi and Marchesi (Extreme Programming Examined,
 Addison-Wesley, 2001), Newkirk and Martin (Extreme Programming in Practice, Addison-Wesley,
 2001), and Auer and his colleagues (Extreme Programming Applied: Play to Win, Addison-Wesley,
 2001) provide a nuts-and-bolts discussion of XP along with guidance on how best to apply it.
 McBreen (Questioning Extreme Programming, Addison-Wesley, 2003) takes a critical look at XP,
 defining when and where it is appropriate. An in-depth consideration of pair programming is
 presented by McBreen (Pair Programming Illuminated, Addison-Wesley, 2003).
 ASD is addressed in depth by Highsmith [Hig00]. Schwaber (The Enterprise and Scrum,
 Microsoft Press, 2007) discusses the use of Scrum for projects that have a major business
 impact. The nuts and bolts of Scrum are discussed by Schwaber and Beedle (Agile Software
 Development with SCRUM, Prentice-Hall, 2001). Worthwhile treatments of DSDM have been
 written by the DSDM Consortium (DSDM: Business Focused Development, 2d ed., Pearson Edu
cation, 2003) and Stapleton (DSDM: The Method in Practice, Addison-Wesley, 1997). Cockburn
 (Crystal Clear, Addison-Wesley, 2005) presents an excellent overview of the Crystal family of
 processes. Palmer and Felsing [Pal02] present a detailed treatment of FDD. Carmichael and
 Haywood (Better Software Faster, Prentice-Hall, 2002) provides another useful treatment of FDD
 that includes a step-by-step journey through the mechanics of the process. Poppendieck and 
Poppendieck (Lean Development: An Agile Toolkit for Software Development Managers, Addison
Wesley, 2003) provide guidelines for managing and controlling agile projects. Ambler and
 Jeffries (Agile Modeling, Wiley, 2002) discuss AM in some depth.
 A wide variety of information sources on agile software development are available on the
 Internet. An up-to-date list of World Wide Web references that are relevant to the agile process
 can be found at the SEPA website: www.mhhe.com/engcs/compsci/pressman/
 professional/olc/ser.htm.
In 2001, Kent Beck and 16 other noted software developers, writers, and con
sultants [Bec01a] (referred to as the “Agile Alliance”) signed the “Manifesto for
 Agile Software Development.” It stated:
 We are uncovering better ways of developing software by doing it and helping others
 do it. Through this work we have come to value: 
Individuals and interactions over processes and tools
 Working software over comprehensive documentation
 Customer collaboration over contract negotiation
 Responding to change over following a plan
 That is, while there is value in the items on the right, we value the items on the 
left more.
 QUICK
 LOOK
 What is it? Agile software engi
neering combines a philosophy and
 a set of development guidelines. The
 philosophy encourages customer
 satisfaction and early incremental delivery of
 software; small, highly motivated project teams;
 informal methods; minimal software engineer
ing work products; and overall development
 simplicity. The development guidelines stress
 delivery over analysis and design (although
 these activities are not discouraged), and active
 and continuous communication between devel
opers and customers.
 Who does it? Software engineers and other
 project stakeholders (managers, customers, end
 users) work together on an agile team—a team
 that is self-organizing and in control of its own
 destiny. An agile team fosters communication
 and collaboration among all who serve on it.
 Why is it important? The modern business envi
ronment that spawns computer-based systems
 and software products is fast-paced and ever
changing. Agile software engineering repre
sents a reasonable alternative to conventional
 software engineering for certain classes of soft
ware and certain types of software projects. It
 has been demonstrated to deliver successful sys
tems quickly.
 Whatarethesteps? Agiledevelopmentmightbest
 be termed “software engineering lite.” The basic
 framework activities—communication, planning,
 modeling, construction, and deployment—
 remain. But they morph into a minimal task set
 that pushes the project team toward construction
 and delivery (some would argue that this is
 done at the expense of problem analysis and
 solution design).
 What is the work product? Both the customer
 and the software engineer have the same
 view—the only really important work product
 is an operational “software increment” that is
 delivered to the customer on the appropriate
 commitment date.
 How do I ensure that I’ve done it right? If the
 agile team agrees that the process works, and
 the team produces deliverable software
 increments that satisfy the customer, you’ve
 done it right.
 65
66
 PART ONE THE SOFTWARE PROCESS
 FDD . . . . . . . . . .86
 Industrial XP . . .77
 Lean Software
 Development . . .87
 pair 
programming . . .76
 project 
velocity . . . . . . .74
 refactoring . . . . .75
 Scrum . . . . . . . .82
 stories . . . . . . . .74
 XP process . . . . .73
 uote:
 “Agility: 1,
 everything else: 0.”
 Tom DeMarco
 A manifesto is normally associated with an emerging political movement—one
 that attacks the old guard and suggests revolutionary change (hopefully for the
 better). In some ways, that’s exactly what agile development is all about.
 Although the underlying ideas that guide agile development have been with us for
 many years, it has been less than two decades since these ideas have crystallized
 into a “movement.” In essence, agile1 methods were developed in an effort to over
come perceived and actual weaknesses in conventional software engineering. Agile
 development can provide important benefits, but it is not applicable to all projects,
 all products, all people, and all situations. It is also not antithetical to solid software
 engineering practice and can be applied as an overriding philosophy for all software
 work.
 In the modern economy, it is often difficult or impossible to predict how a
 computer-based system (e.g., a Web-based application) will evolve as time passes.
 Market conditions change rapidly, end-user needs evolve, and new competitive
 threats emerge without warning. In many situations, you won’t be able to define
 requirements fully before the project begins. You must be agile enough to respond to
 a fluid business environment.
 Fluidity implies change, and change is expensive. Particularly if it is uncontrolled
 or poorly managed. One of the most compelling characteristics of the agile approach
 is its ability to reduce the costs of change throughout the software process.
 Does this mean that a recognition of challenges posed by modern realities causes
 you to discard valuable software engineering principles, concepts, methods, and
 tools? Absolutely not! Like all engineering disciplines, software engineering contin
ues to evolve. It can be adapted easily to meet the challenges posed by a demand for
 agility.
 In a thought-provoking book on agile software development, Alistair Cockburn
 [Coc02] argues that the prescriptive process models introduced in Chapter 2 have a
 major failing: they forget the frailties of the people who build computer software. Software
 engineers are not robots. They exhibit great variation in working styles; significant dif
ferences in skill level, creativity, orderliness, consistency, and spontaneity. Some com
municate well in written form, others do not. Cockburn argues that process models
 can “deal with people’s common weaknesses with [either] discipline or tolerance” and
 that most prescriptive process models choose discipline. He states: “Because consis
tency in action is a human weakness, high discipline methodologies are fragile.”
 If process models are to work, they must provide a realistic mechanism for en
couraging the discipline that is necessary, or they must be characterized in a man
ner that shows “tolerance” for the people who do software engineering work.
 Invariably, tolerant practices are easier for software people to adopt and sustain, but
 (as Cockburn admits) they may be less productive. Like most things in life, trade-offs
 must be considered.
 1 Agile methods are sometimes referred to as light methods or lean methods.
67
 CHAPTER 3 AGILE DEVELOPMENT
 3.1 WHAT IS AGILITY?
 Just what is agility in the context of software engineering work? Ivar Jacobson
 [Jac02a] provides a useful discussion:
 Agility has become today’s buzzword when describing a modern software process. Every
one is agile. An agile team is a nimble team able to appropriately respond to changes.
 Change is what software development is very much about. Changes in the software be
ing built, changes to the team members, changes because of new technology, changes of
 all kinds that may have an impact on the product they build or the project that creates the
 product. Support for changes should be built-in everything we do in software, something
 we embrace because it is the heart and soul of software. An agile team recognizes that
 software is developed by individuals working in teams and that the skills of these people,
 their ability to collaborate is at the core for the success of the project.
 Don’t make the
 mistake of assuming
 that agility gives you
 license to hack out
 solutions. A process is
 required and discipline
 is essential.
 In Jacobson’s view, the pervasiveness of change is the primary driver for agility. Soft
ware engineers must be quick on their feet if they are to accommodate the rapid
 changes that Jacobson describes.
 But agility is more than an effective response to change. It also encompasses the
 philosophy espoused in the manifesto noted at the beginning of this chapter. It
 encourages team structures and attitudes that make communication (among team
 members, between technologists and business people, between software engineers
 and their managers) more facile. It emphasizes rapid delivery of operational soft
ware and de-emphasizes the importance of intermediate work products (not always
 a good thing); it adopts the customer as a part of the development team and works
 to eliminate the “us and them” attitude that continues to pervade many software
 projects; it recognizes that planning in an uncertain world has its limits and that a
 project plan must be flexible.
 Agility can be applied to any software process. However, to accomplish this, it is
 essential that the process be designed in a way that allows the project team to adapt
 tasks and to streamline them, conduct planning in a way that understands the fluid
ity of an agile development approach, eliminate all but the most essential work prod
ucts and keep them lean, and emphasize an incremental delivery strategy that gets
 working software to the customer as rapidly as feasible for the product type and
 operational environment.
 3.2 AGILITY AND THE COST OF CHANGE
 The conventional wisdom in software development (supported by decades of expe
rience) is that the cost of change increases nonlinearly as a project progresses
 (Figure 3.1, solid black curve). It is relatively easy to accommodate a change when a
 software team is gathering requirements (early in a project). A usage scenario might
 have to be modified, a list of functions may be extended, or a written specification
 can be edited. The costs of doing this work are minimal, and the time required will
68
 PART ONE THE SOFTWARE PROCESS
 FIGURE 3.1
 Change costs
 as a function
 of time in
 development
 uote:
 Development cost
 Cost of change
 using conventional
 software processes
 Cost of change
 using agile processes
 “Agility is dynamic,
 content specific,
 aggressively
 change embracing,
 and growth
 oriented.”
 Idealized cost of change
 using agile process
 Development schedule progress–Steven
 Goldman et al.
 An agile process
 reduces the cost of
 change because
 software is released in
 increments and change
 can be better
 controlled within an
 increment.
 not adversely affect the outcome of the project. But what if we fast-forward a num
ber of months? The team is in the middle of validation testing (something that occurs
 relatively late in the project), and an important stakeholder is requesting a major
 functional change. The change requires a modification to the architectural design of
 the software, the design and construction of three new components, modifications
 to another five components, the design of new tests, and so on. Costs escalate
 quickly, and the time and cost required to ensure that the change is made without
 unintended side effects is nontrivial.
 Proponents of agility (e.g., [Bec00], [Amb04]) argue that a well-designed agile
 process “flattens” the cost of change curve (Figure 3.1, shaded, solid curve), allowing
 a software team to accommodate changes late in a software project without dramatic
 cost and time impact. You’ve already learned that the agile process encompasses in
cremental delivery. When incremental delivery is coupled with other agile practices
 such as continuous unit testing and pair programming (discussed later in this chap
ter), the cost of making a change is attenuated. Although debate about the degree to
 which the cost curve flattens is ongoing, there is evidence [Coc01a] to suggest that a
 significant reduction in the cost of change can be achieved.
 3.3 WHAT IS ANAGILE PROCESS?
 Any agile software process is characterized in a manner that addresses a number of
 key assumptions [Fow02] about the majority of software projects: 
1. It is difficult to predict in advance which software requirements will persist
 and which will change. It is equally difficult to predict how customer
 priorities will change as the project proceeds.
69
 CHAPTER 3 AGILE DEVELOPMENT
 WebRef
 A comprehensive
 collection of articles on
 the agile process 
can be found at
 www.aanpo.org/
 articles/index.
 Although agile
 processes embrace
 change, it is still
 important to examine
 the reasons for
 change.
 Working software is
 important, but don’t
 forget that it must also
 exhibit a variety of
 quality attributes
 including reliability,
 usability, and 
maintainability.
 2. For many types of software, design and construction are interleaved. That is,
 both activities should be performed in tandem so that design models are
 proven as they are created. It is difficult to predict how much design is
 necessary before construction is used to prove the design.
 3. Analysis, design, construction, and testing are not as predictable (from a
 planning point of view) as we might like.
 Given these three assumptions, an important question arises: How do we create a
 process that can manage unpredictability? The answer, as I have already noted, lies
 in process adaptability (to rapidly changing project and technical conditions). An
 agile process, therefore, must be adaptable.
 But continual adaptation without forward progress accomplishes little. Therefore,
 an agile software process must adapt incrementally. To accomplish incremental adap
tation, an agile team requires customer feedback (so that the appropriate adaptations
 can be made). An effective catalyst for customer feedback is an operational prototype
 or a portion of an operational system. Hence, an incremental development strategy
 should be instituted. Software increments (executable prototypes or portions of an op
erational system) must be delivered in short time periods so that adaptation keeps pace
 with change (unpredictability). This iterative approach enables the customer to evalu
ate the software increment regularly, provide necessary feedback to the software team,
 and influence the process adaptations that are made to accommodate the feedback.
 3.3.1 Agility Principles
 The Agile Alliance (see [Agi03], [Fow01]) defines 12 agility principles for those who
 want to achieve agility: 
1. Our highest priority is to satisfy the customer through early and continuous
 delivery of valuable software.
 2. Welcome changing requirements, even late in development. Agile processes
 harness change for the customer’s competitive advantage.
 3. Deliver working software frequently, from a couple of weeks to a couple of
 months, with a preference to the shorter timescale.
 4. Business people and developers must work together daily throughout the
 project.
 5. Build projects around motivated individuals. Give them the environment and
 support they need, and trust them to get the job done.
 6. The most efficient and effective method of conveying information to and
 within a development team is face-to-face conversation.
 7. Working software is the primary measure of progress.
 8. Agile processes promote sustainable development. The sponsors, developers,
 and users should be able to maintain a constant pace indefinitely.
70
 PART ONE THE SOFTWARE PROCESS
 9. Continuous attention to technical excellence and good design enhances
 agility.
 10. Simplicity—the art of maximizing the amount of work not done—is 
essential.
 11. The best architectures, requirements, and designs emerge from self
organizing teams.
 12. At regular intervals, the team reflects on how to become more effective, then
 tunes and adjusts its behavior accordingly.
 Not every agile process model applies these 12 principles with equal weight, and
 some models choose to ignore (or at least downplay) the importance of one or more
 of the principles. However, the principles define an agile spirit that is maintained in
 each of the process models presented in this chapter.
 3.3.2 The Politics of Agile Development
 You don’t have to
 choose between agility
 and software engi
neering. Rather, define
 a software engineering
 approach that is agile.
 There is considerable debate (sometimes strident) about the benefits and applicabil
ity of agile software development as opposed to more conventional software engi
neering processes. Jim Highsmith [Hig02a] (facetiously) states the extremes when he
 characterizes the feeling of the pro-agility camp (“agilists”). “Traditional methodolo
gists are a bunch of stick-in-the-muds who’d rather produce flawless documentation
 than a working system that meets business needs.” As a counterpoint, he states
 (again, facetiously) the position of the traditional software engineering camp: “Light
weight, er, ‘agile’ methodologists are a bunch of glorified hackers who are going to
 be in for a heck of a surprise when they try to scale up their toys into enterprise-wide
 software.”
 Like all software technology arguments, this methodology debate risks degener
ating into a religious war. If warfare breaks out, rational thought disappears and
 beliefs rather than facts guide decision making.
 No one is against agility. The real question is: What is the best way to achieve it?
 As important, how do you build software that meets customers’ needs today and
 exhibits the quality characteristics that will enable it to be extended and scaled to
 meet customers’ needs over the long term?
 There are no absolute answers to either of these questions. Even within the agile
 school itself, there are many proposed process models (Section 3.4), each with a
 subtly different approach to the agility problem. Within each model there is a set of
 “ideas” (agilists are loath to call them “work tasks”) that represent a significant
 departure from traditional software engineering. And yet, many agile concepts are
 simply adaptations of good software engineering concepts. Bottom line: there is
 much that can be gained by considering the best of both schools and virtually
 nothing to be gained by denigrating either approach.
 If you have further interest, see [Hig01], [Hig02a], and [DeM02] for an entertain
ing summary of other important technical and political issues.
71
 CHAPTER 3 AGILE DEVELOPMENT
 uote:
 “Agile methods
 derive much of
 their agility by
 relying on the
 tacit knowledge
 embodied in the
 team, rather than
 writing the
 knowledge down
 in plans.”
 Barry Boehm
 ?
 What key
 traits must
 exist among the
 people on an
 effective software
 team?
 uote:
 “What counts as
 barely sufficient
 for one team is
 either overly
 sufficient or
 insufficient for
 another.”
 Alistair
 Cockburn
 3.3.3 Human Factors
 Proponents of agile software development take great pains to emphasize the impor
tance of “people factors.” As Cockburn and Highsmith [Coc01a] state, “Agile devel
opment focuses on the talents and skills of individuals, molding the process to
 specific people and teams.” The key point in this statement is that the process molds
 to the needs of the people and team, not the other way around.2
 If members of the software team are to drive the characteristics of the process that
 is applied to build software, a number of key traits must exist among the people on
 an agile team and the team itself:
 Competence. In an agile development (as well as software engineering)
 context, “competence” encompasses innate talent, specific software-related
 skills, and overall knowledge of the process that the team has chosen to
 apply. Skill and knowledge of process can and should be taught to all people
 who serve as agile team members.
 Common focus. Although members of the agile team may perform differ
ent tasks and bring different skills to the project, all should be focused on one
 goal—to deliver a working software increment to the customer within the
 time promised. To achieve this goal, the team will also focus on continual
 adaptations (small and large) that will make the process fit the needs of the
 team.
 Collaboration. Software engineering (regardless of process) is about as
sessing, analyzing, and using information that is communicated to the soft
ware team; creating information that will help all stakeholders understand
 the work of the team; and building information (computer software and rele
vant databases) that provides business value for the customer. To accomplish
 these tasks, team members must collaborate—with one another and all other
 stakeholders.
 Decision-making ability. Any good software team (including agile teams)
 must be allowed the freedom to control its own destiny. This implies that the
 team is given autonomy—decision-making authority for both technical and
 project issues.
 Fuzzy problem-solving ability. Software managers must recognize that
 the agile team will continually have to deal with ambiguity and will continu
ally be buffeted by change. In some cases, the team must accept the fact that
 the problem they are solving today may not be the problem that needs to be
 solved tomorrow. However, lessons learned from any problem-solving
 2 Successful software engineering organizations recognize this reality regardless of the process
 model they choose.
72
 PART ONE THE SOFTWARE PROCESS
 A self-organizing team
 is in control of the
 work it performs. The
 team makes its own
 commitments and
 defines plans to
 achieve them.
 activity (including those that solve the wrong problem) may be of benefit to
 the team later in the project.
 Mutual trust and respect. The agile team must become what DeMarco
 and Lister [DeM98] call a “jelled” team (Chapter 24). A jelled team exhibits
 the trust and respect that are necessary to make them “so strongly knit that
 the whole is greater than the sum of the parts.” [DeM98]
 Self-organization. In the context of agile development, self-organization
 implies three things: (1) the agile team organizes itself for the work to be
 done, (2) the team organizes the process to best accommodate its local envi
ronment, (3) the team organizes the work schedule to best achieve delivery
 of the software increment. Self-organization has a number of technical bene
fits, but more importantly, it serves to improve collaboration and boost team
 morale. In essence, the team serves as its own management. Ken Schwaber
 [Sch02] addresses these issues when he writes: “The team selects how much
 work it believes it can perform within the iteration, and the team commits to
 the work. Nothing demotivates a team as much as someone else making
 commitments for it. Nothing motivates a team as much as accepting the
 responsibility for fulfilling commitments that it made itself.”
 3.4 EXTREME PROGRAMMING (XP)
 In order to illustrate an agile process in a bit more detail, I’ll provide you with an
 overview of Extreme Programming (XP), the most widely used approach to agile soft
ware development. Although early work on the ideas and methods associated with
 XP occurred during the late 1980s, the seminal work on the subject has been written
 by Kent Beck [Bec04a]. More recently, a variant of XP, called Industrial XP (IXP) has
 been proposed [Ker05]. IXP refines XP and targets the agile process specifically for
 use within large organizations.
 3.4.1 XP Values
 Beck [Bec04a] defines a set of five values that establish a foundation for all work per
formed as part of XP—communication, simplicity, feedback, courage, and respect. Each
 of these values is used as a driver for specific XP activities, actions, and tasks.
 In order to achieve effective communication between software engineers and
 other stakeholders (e.g., to establish required features and functions for the soft
ware), XP emphasizes close, yet informal (verbal) collaboration between customers
 and developers, the establishment of effective metaphors3 for communicating
 important concepts, continuous feedback, and the avoidance of voluminous docu
mentation as a communication medium.
 3 In the XP context, a metaphor is “a story that everyone—customers, programmers, and managers—
 can tell about how the system works” [Bec04a].
73
 CHAPTER 3 AGILE DEVELOPMENT
 Keep it simple
 whenever you can, but
 recognize that
 continual “refactoring”
 can absorb significant
 time and resources.
 uote:
 “XP is the answer
 to the question,
 ‘How little can we
 do and still build
 great software?’“
 Anonymous
 WebRef
 An excellent overview
 of “rules” for XP can
 be found at www
 .extremeprogramm
 ing.org/rules.html.
 To achieve simplicity, XP restricts developers to design only for immediate needs,
 rather than consider future needs. The intent is to create a simple design that can be
 easily implemented in code). If the design must be improved, it can be refactored4 at
 a later time.
 Feedback is derived from three sources: the implemented software itself, the
 customer, and other software team members. By designing and implementing an
 effective testing strategy (Chapters 17 through 20), the software (via test results) pro
vides the agile team with feedback. XP makes use of the unit test as its primary test
ing tactic. As each class is developed, the team develops a unit test to exercise each
 operation according to its specified functionality. As an increment is delivered to a
 customer, the user stories or use cases (Chapter 5) that are implemented by the
 increment are used as a basis for acceptance tests. The degree to which the software
 implements the output, function, and behavior of the use case is a form of feedback.
 Finally, as new requirements are derived as part of iterative planning, the team pro
vides the customer with rapid feedback regarding cost and schedule impact.
 Beck [Bec04a] argues that strict adherence to certain XP practices demands
 courage. A better word might be discipline. For example, there is often significant
 pressure to design for future requirements. Most software teams succumb, arguing
 that “designing for tomorrow” will save time and effort in the long run. An agile XP
 team must have the discipline (courage) to design for today, recognizing that future
 requirements may change dramatically, thereby demanding substantial rework of
 the design and implemented code.
 By following each of these values, the agile team inculcates respect among it
 members, between other stakeholders and team members, and indirectly, for the
 software itself. As they achieve successful delivery of software increments, the team
 develops growing respect for the XP process.
 3.4.2 The XP Process
 Extreme Programming uses an object-oriented approach (Appendix 2) as its pre
ferred development paradigm and encompasses a set of rules and practices that
 occur within the context of four framework activities: planning, design, coding, and
 testing. Figure 3.2 illustrates the XP process and notes some of the key ideas and
 tasks that are associated with each framework activity. Key XP activities are sum
marized in the paragraphs that follow.
 Planning. The planning activity (also called the planning game) begins with
 listening—a requirements gathering activity that enables the technical members of
 the XP team to understand the business context for the software and to get a broad
 4 Refactoring allows a software engineer to improve the internal structure of a design (or source
 code) without changing its external functionality or behavior. In essence, refactoring can be used
 to improve the efficiency, readability, or performance of a design or the code that implements a
 design.
74
 PART ONE THE SOFTWARE PROCESS
 FIGURE 3.2
 The Extreme
 Programming
 process
 ?
 What is an
 XP “story”?
 WebRef
 A worthwhile XP
 “planning game” can
 be found at:
 c2.com/cgi/
 wiki?planningGame.
 simple design
 CRC cards
 user stories
 values
 acceptance test criteria
 iteration plan
 Release
 spike solutions
 prototypes
 refactoring
 design
 pair programming
 planning
 software increment
 project velocity computed
 unit test
 continuous integration
 acceptance testing
 test
 coding
 feel for required output and major features and functionality. Listening leads to the
 creation of a set of “stories” (also called user stories) that describe required output,
 features, and functionality for software to be built. Each story (similar to use cases
 described in Chapter 5) is written by the customer and is placed on an index card.
 The customer assigns a value (i.e., a priority) to the story based on the overall busi
ness value of the feature or function.5 Members of the XP team then assess each
 story and assign a cost—measured in development weeks—to it. If the story is esti
mated to require more than three development weeks, the customer is asked to split
 the story into smaller stories and the assignment of value and cost occurs again. It
 is important to note that new stories can be written at any time.
 Customers and developers work together to decide how to group stories into the
 next release (the next software increment) to be developed by the XP team. Once a
 basic commitment (agreement on stories to be included, delivery date, and other
 project matters) is made for a release, the XP team orders the stories that will be de
veloped in one of three ways: (1) all stories will be implemented immediately (within
 a few weeks), (2) the stories with highest value will be moved up in the schedule and
 implemented first, or (3) the riskiest stories will be moved up in the schedule and
 implemented first.
 After the first project release (also called a software increment) has been deliv
ered, the XP team computes project velocity. Stated simply, project velocity is the
 5 The value of a story may also be dependent on the presence of another story.
75
 CHAPTER 3 AGILE DEVELOPMENT
 Project velocity is a
 subtle measure of
 team productivity.
 XP deemphasizes the
 importance of design.
 Not everyone agrees.
 In fact, there are times
 when design should be
 emphasized.
 WebRef
 Refactoring techniques
 and tools can be
 found at:
 www.refactoring
 .com.
 number of customer stories implemented during the first release. Project velocity can
 then be used to (1) help estimate delivery dates and schedule for subsequent releases
 and (2) determine whether an overcommitment has been made for all stories across
 the entire development project. If an overcommitment occurs, the content of releases
 is modified or end delivery dates are changed.
 As development work proceeds, the customer can add stories, change the value
 of an existing story, split stories, or eliminate them. The XP team then reconsiders all
 remaining releases and modifies its plans accordingly.
 Design. XP design rigorously follows the KIS (keep it simple) principle. A simple
 design is always preferred over a more complex representation. In addition, the de
sign provides implementation guidance for a story as it is written—nothing less,
 nothing more. The design of extra functionality (because the developer assumes it
 will be required later) is discouraged.6
 XP encourages the use of CRC cards (Chapter 7) as an effective mechanism for
 thinking about the software in an object-oriented context. CRC (class-responsibility
collaborator) cards identify and organize the object-oriented classes7 that are rele
vant to the current software increment. The XP team conducts the design exercise
 using a process similar to the one described in Chapter 8. The CRC cards are the only
 design work product produced as part of the XP process.
 If a difficult design problem is encountered as part of the design of a story, XP rec
ommends the immediate creation of an operational prototype of that portion of the
 design. Called a spike solution, the design prototype is implemented and evaluated.
 The intent is to lower risk when true implementation starts and to validate the orig
inal estimates for the story containing the design problem.
 In the preceding section, we noted that XP encourages refactoring—a construction
 technique that is also a method for design optimization. Fowler [Fow00] describes
 refactoring in the following manner:
 Refactoring is the process of changing a software system in such a way that it does not
 alter the external behavior of the code yet improves the internal structure. It is a disci
plined way to clean up code [and modify/simplify the internal design] that minimizes the
 chances of introducing bugs. In essence, when you refactor you are improving the design
 of the code after it has been written.
 Because XP design uses virtually no notation and produces few, if any, work prod
ucts other than CRC cards and spike solutions, design is viewed as a transient arti
fact that can and should be continually modified as construction proceeds. The intent
 of refactoring is to control these modifications by suggesting small design changes
 6 These design guidelines should be followed in every software engineering method, although there
 are times when sophisticated design notation and terminology may get in the way of simplicity.
 7 Object-oriented classes are discussed in Appendix 2, in Chapter 8, and throughout Part 2 of this
 book.
76
 PART ONE THE SOFTWARE PROCESS
 Refactoring improves
 the internal structure of
 a design (or source
 code) without
 changing its external
 functionality or
 behavior.
 WebRef
 Useful information on
 XP can be obtained 
at www
 .xprogramming.
 com.
 ?
 What is 
pair
 programming?
 Many software teams
 are populated by indi
vidualists. You’ll have
 to work to change that
 culture if pair program
ming is to work effec
tively.
 ?
 XP?
 How are unit
 tests used in
 that “can radically improve the design” [Fow00]. It should be noted, however, that
 the effort required for refactoring can grow dramatically as the size of an application
 grows.
 A central notion in XP is that design occurs both before and after coding com
mences. Refactoring means that design occurs continuously as the system is con
structed. In fact, the construction activity itself will provide the XP team with
 guidance on how to improve the design.
 Coding. After stories are developed and preliminary design work is done, the team
 does not move to code, but rather develops a series of unit tests that will exercise
 each of the stories that is to be included in the current release (software increment).8
 Once the unit test9 has been created, the developer is better able to focus on what
 must be implemented to pass the test. Nothing extraneous is added (KIS). Once the
 code is complete, it can be unit-tested immediately, thereby providing instantaneous
 feedback to the developers.
 A key concept during the coding activity (and one of the most talked about aspects
 of XP) is pair programming. XP recommends that two people work together at one
 computer workstation to create code for a story. This provides a mechanism for real
time problem solving (two heads are often better than one) and real-time quality as
surance (the code is reviewed as it is created). It also keeps the developers focused
 on the problem at hand. In practice, each person takes on a slightly different role. For
 example, one person might think about the coding details of a particular portion of
 the design while the other ensures that coding standards (a required part of XP) are
 being followed or that the code for the story will satisfy the unit test that has been
 developed to validate the code against the story.
 As pair programmers complete their work, the code they develop is integrated
 with the work of others. In some cases this is performed on a daily basis by an inte
gration team. In other cases, the pair programmers have integration responsibility.
 This “continuous integration” strategy helps to avoid compatibility and interfacing
 problems and provides a “smoke testing” environment (Chapter 17) that helps to
 uncover errors early.
 Testing. I have already noted that the creation of unit tests before coding com
mences is a key element of the XP approach. The unit tests that are created should
 be implemented using a framework that enables them to be automated (hence, they
 can be executed easily and repeatedly). This encourages a regression testing strat
egy (Chapter 17) whenever code is modified (which is often, given the XP refactor
ing philosophy).
 8 This approach is analogous to knowing the exam questions before you begin to study. It makes
 studying much easier by focusing attention only on the questions that will be asked.
 9 Unit testing, discussed in detail in Chapter 17, focuses on an individual software component, exer
cising the component’s interface, data structures, and functionality in an effort to uncover errors
 that are local to the component.
77
 CHAPTER 3 AGILE DEVELOPMENT
 XP acceptance tests
 are derived from user
 stories.
 ?
 What new
 practices are
 appended to XP
 to create IXP?
 uote:
 “Ability is what
 you’re capable of
 doing. Motivation
 determines what
 you do. Attitude
 determines how
 well you do it.”
 Lou Holtz
 As the individual unit tests are organized into a “universal testing suite” [Wel99],
 integration and validation testing of the system can occur on a daily basis. This pro
vides the XP team with a continual indication of progress and also can raise warn
ing flags early if things go awry. Wells [Wel99] states: “Fixing small problems every
 few hours takes less time than fixing huge problems just before the deadline.”
 XP acceptance tests, also called customer tests, are specified by the customer and
 focus on overall system features and functionality that are visible and reviewable by
 the customer. Acceptance tests are derived from user stories that have been imple
mented as part of a software release.
 3.4.3 Industrial XP
 Joshua Kerievsky [Ker05] describes Industrial Extreme Programming (IXP) in the fol
lowing manner: “IXP is an organic evolution of XP. It is imbued with XP’s minimal
ist, customer-centric, test-driven spirit. IXP differs most from the original XP in its
 greater inclusion of management, its expanded role for customers, and its upgraded
 technical practices.” IXP incorporates six new practices that are designed to help
 ensure that an XP project works successfully for significant projects within a large
 organization.
 Readiness assessment. Prior to the initiation of an IXP project, the organ
ization should conduct a readiness assessment. The assessment ascertains
 whether (1) an appropriate development environment exists to support IXP,
 (2) the team will be populated by the proper set of stakeholders, (3) the or
ganization has a distinct quality program and supports continuous improve
ment, (4) the organizational culture will support the new values of an agile
 team, and (5) the broader project community will be populated appropriately.
 Project community. Classic XP suggests that the right people be used to
 populate the agile team to ensure success. The implication is that people on
 the team must be well-trained, adaptable and skilled, and have the proper
 temperament to contribute to a self-organizing team. When XP is to be
 applied for a significant project in a large organization, the concept of the
 “team” should morph into that of a community. A community may have a
 technologist and customers who are central to the success of a project as
 well as many other stakeholders (e.g., legal staff, quality auditors, manufac
turing or sales types) who “are often at the periphery of an IXP project yet
 they may play important roles on the project” [Ker05]. In IXP, the community
 members and their roles should be explicitly defined and mechanisms for
 communication and coordination between community members should be
 established.
 Project chartering. The IXP team assesses the project itself to determine
 whether an appropriate business justification for the project exists and
 whether the project will further the overall goals and objectives of the
78
 PART ONE THE SOFTWARE PROCESS
 organization. Chartering also examines the context of the project to deter
mine how it complements, extends, or replaces existing systems or
 processes.
 Test-driven management. An IXP project requires measurable criteria for
 assessing the state of the project and the progress that has been made to
 date. Test-driven management establishes a series of measurable “destina
tions” [Ker05] and then defines mechanisms for determining whether or not
 these destinations have been reached.
 Retrospectives. An IXP team conducts a specialized technical review
 (Chapter 15) after a software increment is delivered. Called a retrospective,
 the review examines “issues, events, and lessons-learned” [Ker05] across a
 software increment and/or the entire software release. The intent is to
 improve the IXP process.
 Continuous learning. Because learning is a vital part of continuous
 process improvement, members of the XP team are encouraged (and possi
bly, incented) to learn new methods and techniques that can lead to a higher
quality product.
 In addition to the six new practices discussed, IXP modifies a number of existing
 XP practices. Story-driven development (SDD) insists that stories for acceptance tests
 be written before a single line of code is generated. Domain-driven design (DDD) is
 an improvement on the “system metaphor” concept used in XP. DDD [Eva03] sug
gests the evolutionary creation of a domain model that “accurately represents how
 domain experts think about their subject” [Ker05]. Pairing extends the XP pair
programming concept to include managers and other stakeholders. The intent is to
 improve knowledge sharing among XP team members who may not be directly in
volved in technical development. Iterative usability discourages front-loaded inter
face design in favor of usability design that evolves as software increments are
 delivered and users’ interaction with the software is studied.
 IXP makes smaller modifications to other XP practices and redefines certain roles
 and responsibilities to make them more amenable to significant projects for large
 organizations. For further discussion of IXP, visit http://industrialxp.org.
 3.4.4 The XP Debate
 All new process models and methods spur worthwhile discussion and in some in
stances heated debate. Extreme Programming has done both. In an interesting book
 that examines the efficacy of XP, Stephens and Rosenberg [Ste03] argue that many
 XP practices are worthwhile, but others have been overhyped, and a few are prob
lematic. The authors suggest that the codependent nature of XP practices are both
 its strength and its weakness. Because many organizations adopt only a subset of XP
 practices, they weaken the efficacy of the entire process. Proponents counter that
 XP is continuously evolving and that many of the issues raised by critics have been
79
 CHAPTER 3 AGILE DEVELOPMENT
 addressed as XP practice matures. Among the issues that continue to trouble some
 critics of XP are:10
 ?
 What are
 some of the
 issues that lead to
 an XP debate?
 • Requirements volatility. Because the customer is an active member of the XP
 team, changes to requirements are requested informally. As a consequence,
 the scope of the project can change and earlier work may have to be
 modified to accommodate current needs. Proponents argue that this happens
 regardless of the process that is applied and that XP provides mechanisms for
 controlling scope creep.
 • Conflicting customer needs. Many projects have multiple customers, each with
 his own set of needs. In XP, the team itself is tasked with assimilating the
 needs of different customers, a job that may be beyond their scope of
 authority.
 • Requirements are expressed informally. User stories and acceptance tests are
 the only explicit manifestation of requirements in XP. Critics argue that a
 more formal model or specification is often needed to ensure that omissions,
 inconsistencies, and errors are uncovered before the system is built. Propo
nents counter that the changing nature of requirements makes such models
 and specification obsolete almost as soon as they are developed.
 • Lack of formal design. XP deemphasizes the need for architectural design and
 in many instances, suggests that design of all kinds should be relatively
 informal. Critics argue that when complex systems are built, design must be
 emphasized to ensure that the overall structure of the software will exhibit
 quality and maintainability. XP proponents suggest that the incremental
 nature of the XP process limits complexity (simplicity is a core value) and
 therefore reduces the need for extensive design.
 You should note that every software process has flaws and that many software or
ganizations have used XP successfully. The key is to recognize where a process may
 have weaknesses and to adapt it to the specific needs of your organization.
 SAFEHOME
 Considering Agile Software Development
 The scene: Doug Miller’s office.
 The Players: Doug Miller, software engineering
 manager; Jamie Lazar, software team member; Vinod
 Raman, software team member.
 The conversation:
 (A knock on the door, Jamie and Vinod enter Doug’s office)
 Jamie: Doug, you got a minute?
 10 For a detailed look at some thoughtful criticism that has been leveled at XP, visit
 www.softwarereality.com/ExtremeProgramming.jsp.
3.5 OTHERAGILEPROCESSMODELS
 The history of software engineering is littered with dozens of obsolete process
 descriptions and methodologies, modeling methods and notations, tools, and
 technology. Each flared in notoriety and was then eclipsed by something new and
 (purportedly) better. With the introduction of a wide array of agile process models—
 each contending for acceptance within the software development community—the
 agile movement is following the same historical path.11
 As I noted in the last section, the most widely used of all agile process models
 isExtreme Programming (XP). But many other agile process models have been
 proposed and are in use across the industry. Among the most common are:
 •Adaptive Software Development (ASD)
 •Scrum
 •Dynamic Systems Development Method (DSDM)
 80 PART ONE THE SOFTWARE PROCESS
 Doug: Sure Jamie, what’s up?
 Jamie:We’ve been thinking about our process
 discussion yesterday . . . you know, what process we’re
 going to choose for this new SafeHomeproject.
 Doug:And?
 Vinod: I was talking to a friend at another company,
 and he was telling me about Extreme Programming. It’s
 an agile process model . . . heard of it?
 Doug: Yeah, some good, some bad.
 Jamie:Well, it sounds pretty good to us. Lets you
 develop software really fast, uses something called pair
 programming to do real-time quality checks . . . it’s pretty
 cool, I think.
 Doug: It does have a lot of really good ideas. I like the
 pair-programming concept, for instance, and the idea
 that stakeholders should be part of the team.
 Jamie:Huh? You mean that marketing will work on the
 project team with us?
 Doug (nodding): They’re a stakeholder, aren’t they?
 Jamie: Jeez . . . they’ll be requesting changes every five
 minutes.
 Vinod:Not necessarily. My friend said that there are
 ways to “embrace” changes during an XP project.
 Doug: So you guys think we should use XP?
 Jamie: It’s definitely worth considering.
 Doug: I agree. And even if we choose an incremental
 model as our approach, there’s no reason why we can’t
 incorporate much of what XP has to offer.
 Vinod:Doug, before you said “some good, some bad.”
 What was the “bad”?
 Doug: The thing I don’t like is the way XP downplays
 analysis and design . . . sort of says that writing code is
 where the action is . . . 
(The team members look at one another and smile.)
 Doug: So you agree with the XP approach?
 Jamie (speaking for both):Writing code is what
 we do, Boss!
 Doug (laughing): True, but I’d like to see you spend a
 little less time coding and then recoding and a little more
 time analyzing what has to be done and designing a
 solution that works.
 Vinod:Maybe we can have it both ways, agility with a
 little discipline.
 Doug: I think we can, Vinod. In fact, I’m sure of it.
 uote:
 “Our profession
 goes through
 methodologies like
 a 14-year-old goes
 through clothing.”
 Stephen
 Hawrysh and
 JimRuprecht
 11This is not a bad thing. Before one or more models or methods are accepted as a de facto standard,
 all must contend for the hearts and minds of software engineers. The “winners” evolve into best
 practice, while the “losers” either disappear or merge with the winning models.
81
 CHAPTER 3 AGILE DEVELOPMENT
 • Crystal
 • Feature Drive Development (FDD)
 • Lean Software Development (LSD)
 • Agile Modeling (AM)
 • Agile Unified Process (AUP)
 In the sections that follow, I present a very brief overview of each of these agile
 process models. It is important to note that all agile process models conform (to a
 greater or lesser degree) to the Manifesto for Agile Software Development and the prin
ciples noted in Section 3.3.1. For additional detail, refer to the references noted in
 each subsection or for a survey, examine the “agile software development” entry
 in Wikipedia.12
 3.5.1 Adaptive Software Development (ASD)
 WebRef
 Useful resources for
 ASD can be found at
 www.adaptivesd
 .com.
 Adaptive Software Development (ASD) has been proposed by Jim Highsmith [Hig00] as
 a technique for building complex software and systems. The philosophical under
pinnings of ASD focus on human collaboration and team self-organization.
 Highsmith argues that an agile, adaptive development approach based on collab
oration is “as much a source of order in our complex interactions as discipline and
 engineering.” He defines an ASD “life cycle” (Figure 3.3) that incorporates three
 phases, speculation, collaboration, and learning.
 FIGURE 3.3
 Adaptive
 software
 development
 adaptive cycle planning
 mission statement
 project constraints
 basic requirements
 time-boxed release plan
 Release
 Requirements gathering
 JAD
 mini-specs
 speculation
 software increment
 adjustments for subsequent cycles
 collaboration
 components implemented/tested
 focus groups for feedback
 formal technical reviews
 learning
 postmortems
 12 See http://en.wikipedia.org/wiki/Agile_software_development#Agile_methods.
82
 PART ONE THE SOFTWARE PROCESS
 Effective collaboration
 with your customer will
 only occur if you
 jettison any “us and
 them” attitudes.
 ASD emphasizes
 learning as a key
 element in achieving 
a “self-organizing”
 team.
 WebRef
 Useful Scrum
 information and
 resources can be found
 at www
 .controlchaos.com.
 During speculation, the project is initiated and adaptive cycle planning is con
ducted. Adaptive cycle planning uses project initiation information—the customer’s
 mission statement, project constraints (e.g., delivery dates or user descriptions), and
 basic requirements—to define the set of release cycles (software increments) that
 will be required for the project.
 No matter how complete and farsighted the cycle plan, it will invariably change.
 Based on information obtained at the completion of the first cycle, the plan is re
viewed and adjusted so that planned work better fits the reality in which an ASD
 team is working.
 Motivated people use collaboration in a way that multiplies their talent and cre
ative output beyond their absolute numbers. This approach is a recurring theme in
 all agile methods. But collaboration is not easy. It encompasses communication and
 teamwork, but it also emphasizes individualism, because individual creativity plays
 an important role in collaborative thinking. It is, above all, a matter of trust. People
 working together must trust one another to (1) criticize without animosity, (2) assist
 without resentment, (3) work as hard as or harder than they do, (4) have the skill set
 to contribute to the work at hand, and (5) communicate problems or concerns in a
 way that leads to effective action.
 As members of an ASD team begin to develop the components that are part of an
 adaptive cycle, the emphasis is on “learning” as much as it is on progress toward
 a completed cycle. In fact, Highsmith [Hig00] argues that software developers often
 overestimate their own understanding (of the technology, the process, and the proj
ect) and that learning will help them to improve their level of real understanding.
 ASD teams learn in three ways: focus groups (Chapter 5), technical reviews (Chap
ter 14), and project postmortems.
 The ASD philosophy has merit regardless of the process model that is used. ASD’s
 overall emphasis on the dynamics of self-organizing teams, interpersonal collabo
ration, and individual and team learning yield software project teams that have a
 much higher likelihood of success.
 3.5.2 Scrum
 Scrum (the name is derived from an activity that occurs during a rugby match13) is
 an agile software development method that was conceived by Jeff Sutherland and his
 development team in the early 1990s. In recent years, further development on the
 Scrum methods has been performed by Schwaber and Beedle [Sch01a].
 Scrum principles are consistent with the agile manifesto and are used to guide
 development activities within a process that incorporates the following framework
 activities: requirements, analysis, design, evolution, and delivery. Within each
 13 A group of players forms around the ball and the teammates work together (sometimes violently!)
 to move the ball downfield.
every 24
 hours
 30 days
 Scrum: 15 minute daily meeting.
 Team members respond to basics:
 1) What did you do since last Scrum
 meeting?
 2) Do you have any obstacles?
 3) What will you do before next
 meeting?
 Sprint Backlog:
 Feature(s)
 assigned
 to sprint
 Product Backlog:
 Prioritized product features desired by the customer
 Backlog
 items
 expanded
 by team
 New functionality
 is demonstrated
 at end of sprint
 framework activity, work tasks occur within a process pattern (discussed in the fol
lowing paragraph) called a sprint.The work conducted within a sprint (the number
 of sprints required for each framework activity will vary depending on product com
plexity and size) is adapted to the problem at hand and is defined and often modified
 in real time by the Scrum team. The overall flow of the Scrum process is illustrated
 in Figure 3.4.
 Scrum emphasizes the use of a set of software process patterns [Noy02] that have
 proven effective for projects with tight timelines, changing requirements, and business
 criticality. Each of these process patterns defines a set of development actions:
 Backlog—a prioritized list of project requirements or features that provide busi
ness value for the customer. Items can be added to the backlog at any time (this is
 how changes are introduced). The product manager assesses the backlog and
 updates priorities as required.
 Sprints—consist of work units that are required to achieve a requirement de
fined in the backlog that must be fit into a predefined time-box14(typically 30 days).
 CHAPTER 3 AGILE DEVELOPMENT 83
 14A time-boxis a project management term (see Part 4 of this book) that indicates a period of time
 that has been allocated to accomplish some task.
 FIGURE3.4
 Scrum process
 flow
 Scrum incorporates a
 set of process patterns
 that emphasize project
 priorities,
 compartmentalized
 work units,
 communication, and
 frequent customer
 feedback.
84
 PART ONE THE SOFTWARE PROCESS
 Changes (e.g., backlog work items) are not introduced during the sprint. Hence, the
 sprint allows team members to work in a short-term, but stable environment.
 Scrum meetings—are short (typically 15 minutes) meetings held daily by the Scrum
 team. Three key questions are asked and answered by all team members [Noy02]:
 • What did you do since the last team meeting?
 • What obstacles are you encountering?
 • What do you plan to accomplish by the next team meeting?
 A team leader, called a Scrum master, leads the meeting and assesses the responses
 from each person. The Scrum meeting helps the team to uncover potential problems
 as early as possible. Also, these daily meetings lead to “knowledge socialization”
 [Bee99] and thereby promote a self-organizing team structure.
 Demos—deliver the software increment to the customer so that functionality that
 has been implemented can be demonstrated and evaluated by the customer. It is im
portant to note that the demo may not contain all planned functionality, but rather
 those functions that can be delivered within the time-box that was established.
 Beedle and his colleagues [Bee99] present a comprehensive discussion of these pat
terns in which they state: “Scrum assumes up-front the existence of chaos. . . . ” The
 Scrum process patterns enable a software team to work successfully in a world
 where the elimination of uncertainty is impossible.
 3.5.3 Dynamic Systems Development Method (DSDM)
 WebRef
 Useful resources for
 DSSD can be found at
 www.dsdm.org.
 The Dynamic Systems Development Method (DSDM) [Sta97] is an agile software devel
opment approach that “provides a framework for building and maintaining systems
 which meet tight time constraints through the use of incremental prototyping in a con
trolled project environment” [CCS02]. The DSDM philosophy is borrowed from a mod
ified version of the Pareto principle—80 percent of an application can be delivered in
 20 percent of the time it would take to deliver the complete (100 percent) application.
 DSDM is an iterative software process in which each iteration follows the 80 per
cent rule. That is, only enough work is required for each increment to facilitate
 movement to the next increment. The remaining detail can be completed later when
 more business requirements are known or changes have been requested and
 accommodated.
 The DSDM Consortium (www.dsdm.org) is a worldwide group of member com
panies that collectively take on the role of “keeper” of the method. The consortium
 has defined an agile process model, called the DSDM life cycle that defines three dif
ferent iterative cycles, preceded by two additional life cycle activities:
 Feasibility study—establishes the basic business requirements and constraints
 associated with the application to be built and then assesses whether the applica
tion is a viable candidate for the DSDM process.
85
 CHAPTER 3 AGILE DEVELOPMENT
 DSDM is a process
 framework that can
 adopt the tactics of
 another agile approach
 such as XP.
 Crystal is a family of
 process models with
 the same “genetic
 code” but different
 methods for adapting
 to project
 characteristics.
 Business study—establishes the functional and information requirements that
 will allow the application to provide business value; also, defines the basic
 application architecture and identifies the maintainability requirements for the
 application.
 Functional model iteration—produces a set of incremental prototypes that
 demonstrate functionality for the customer. (Note: All DSDM prototypes are in
tended to evolve into the deliverable application.) The intent during this iterative
 cycle is to gather additional requirements by eliciting feedback from users as they
 exercise the prototype.
 Design and build iteration—revisits prototypes built during functional model
 iteration to ensure that each has been engineered in a manner that will enable it to
 provide operational business value for end users. In some cases, functional model
 iteration and design and build iteration occur concurrently.
 Implementation—places the latest software increment (an “operationalized” pro
totype) into the operational environment. It should be noted that (1) the increment
 may not be 100 percent complete or (2) changes may be requested as the incre
ment is put into place. In either case, DSDM development work continues by
 returning to the functional model iteration activity.
 DSDM can be combined with XP (Section 3.4) to provide a combination approach
 that defines a solid process model (the DSDM life cycle) with the nuts and bolts prac
tices (XP) that are required to build software increments. In addition, the ASD con
cepts of collaboration and self-organizing teams can be adapted to a combined
 process model.
 3.5.4 Crystal
 Alistair Cockburn [Coc05] and Jim Highsmith [Hig02b] created the Crystal family of
 agile methods15 in order to achieve a software development approach that puts a
 premium on “maneuverability” during what Cockburn characterizes as “a resource
limited, cooperative game of invention and communication, with a primary goal of
 delivering useful, working software and a secondary goal of setting up for the next
 game” [Coc02].
 To achieve maneuverability, Cockburn and Highsmith have defined a set of
 methodologies, each with core elements that are common to all, and roles, process
 patterns, work products, and practice that are unique to each. The Crystal family is
 actually a set of example agile processes that have been proven effective for differ
ent types of projects. The intent is to allow agile teams to select the member of the
 crystal family that is most appropriate for their project and environment.
 15 The name “crystal” is derived from the characteristics of geological crystals, each with its own
 color, shape, and hardness.
86
 PART ONE THE SOFTWARE PROCESS
 3.5.5 Feature Driven Development (FDD)
 WebRef
 A wide variety of
 articles and
 presentations on FDD
 can be found at:
 www.featuredrive
 ndevelopment
 .com/.
 Feature Driven Development (FDD) was originally conceived by Peter Coad and his
 colleagues [Coa99] as a practical process model for object-oriented software engi
neering. Stephen Palmer and John Felsing [Pal02] have extended and improved
 Coad’s work, describing an adaptive, agile process that can be applied to moderately
 sized and larger software projects.
 Like other agile approaches, FDD adopts a philosophy that (1) emphasizes col
laboration among people on an FDD team; (2) manages problem and project
 complexity using feature-based decomposition followed by the integration of
 software increments, and (3) communication of technical detail using verbal,
 graphical, and text-based means. FDD emphasizes software quality assurance
 activities by encouraging an incremental development strategy, the use of design
 and code inspections, the application of software quality assurance audits (Chap
ter 16), the collection of metrics, and the use of patterns (for analysis, design, and
 construction).
 In the context of FDD, a feature “is a client-valued function that can be imple
mented in two weeks or less” [Coa99]. The emphasis on the definition of features
 provides the following benefits:
 • Because features are small blocks of deliverable functionality, users can
 describe them more easily; understand how they relate to one another more
 readily; and better review them for ambiguity, error, or omissions.
 • Features can be organized into a hierarchical business-related grouping.
 • Since a feature is the FDD deliverable software increment, the team develops
 operational features every two weeks.
 • Because features are small, their design and code representations are easier
 to inspect effectively.
 • Project planning, scheduling, and tracking are driven by the feature
 hierarchy, rather than an arbitrarily adopted software engineering 
task set.
 Coad and his colleagues [Coa99] suggest the following template for defining a
 feature:
 <action> the <result> <by for of to> a(n) <object>
 where an <object> is “a person, place, or thing (including roles, moments in time or
 intervals of time, or catalog-entry-like descriptions).” Examples of features for an 
e-commerce application might be:
 Add the product to shopping cart
 Display the technical-specifications of the product
 Store the shipping-information for the customer
87
 CHAPTER 3 AGILE DEVELOPMENT
 FIGURE 3.5
 Feature Driven
 Development
 [Coa99] (with
 permission)
 Develop
 an
 Overall
 Model
 Build a
 Features
 List
 Plan
 By
 Feature
 Design
 By
 Feature
 (more shape
 than content)
 A list of features
 grouped into sets
 and subject areas
 A development plan
 Class owners
 Feature Set Owners
 A design
 package
 (sequences)
 Build
 By
 Feature
 Completed
 client-value
 function
 A feature set groups related features into business-related categories and is defined
 [Coa99] as:
 <action><-ing> a(n) <object>
 For example: Making a product sale is a feature set that would encompass the fea
tures noted earlier and others.
 The FDD approach defines five “collaborating” [Coa99] framework activities (in
 FDD these are called “processes”) as shown in Figure 3.5.
 FDD provides greater emphasis on project management guidelines and tech
niques than many other agile methods. As projects grow in size and complexity,
 ad hoc project management is often inadequate. It is essential for developers, their
 managers, and other stakeholders to understand project status—what accomplish
ments have been made and problems have been encountered. If deadline pressure
 is significant, it is critical to determine if software increments (features) are properly
 scheduled. To accomplish this, FDD defines six milestones during the design and
 implementation of a feature: “design walkthrough, design, design inspection, code,
 code inspection, promote to build” [Coa99].
 3.5.6 Lean Software Development (LSD)
 Lean Software Development (LSD) has adapted the principles of lean manufacturing
 to the world of software engineering. The lean principles that inspire the LSD process
 can be summarized ([Pop03], [Pop06a]) as eliminate waste, build quality in, create
 knowledge, defer commitment, deliver fast, respect people, and optimize the whole.
 Each of these principles can be adapted to the software process. For example,
 eliminate waste within the context of an agile software project can be interpreted
 to mean [Das05]: (1) adding no extraneous features or functions, (2) assessing the
 cost and schedule impact of any newly requested requirement, (3) removing any
 superfluous process steps, (4) establishing mechanisms to improve the way team
 members find information, (5) ensuring the testing finds as many errors as possible,
88
 PART ONE THE SOFTWARE PROCESS
 (6) reducing the time required to request and get a decision that affects the software
 or the process that is applied to create it, and (7) streamlining the manner in which
 information is transmitted to all stakeholders involved in the process.
 For a detailed discussion of LSD and pragmatic guidelines for implementing the
 process, you should examine [Pop06a] and [Pop06b].
 3.5.7 Agile Modeling (AM)
 WebRef
 Comprehensive
 information on agile
 modeling can be found
 at: www
 .agilemodeling.com.
 uote:
 “I was in the drug
 store the other day
 trying to get a cold
 medication . . . not
 easy. There’s an
 entire wall of
 products you need.
 You stand there
 going, Well, this
 one is quick acting
 but this is long
 lasting. . . . Which
 is more important,
 the present or the
 future?”
 Jerry Seinfeld
 There are many situations in which software engineers must build large, business
critical systems. The scope and complexity of such systems must be modeled so that
 (1) all constituencies can better understand what needs to be accomplished, (2) the
 problem can be partitioned effectively among the people who must solve it, and
 (3) quality can be assessed as the system is being engineered and built.
 Over the past 30 years, a wide variety of software engineering modeling methods
 and notation have been proposed for analysis and design (both architectural and
 component-level). These methods have merit, but they have proven to be difficult
 to apply and challenging to sustain (over many projects). Part of the problem is the
 “weight” of these modeling methods. By this I mean the volume of notation required,
 the degree of formalism suggested, the sheer size of the models for large projects,
 and the difficulty in maintaining the model(s) as changes occur. Yet analysis and de
sign modeling have substantial benefit for large projects—if for no other reason than
 to make these projects intellectually manageable. Is there an agile approach to soft
ware engineering modeling that might provide an alternative?
 At “The Official Agile Modeling Site,” Scott Ambler [Amb02a] describes agile mod
eling (AM) in the following manner:
 Agile Modeling (AM) is a practice-based methodology for effective modeling and documen
tation of software-based systems. Simply put, Agile Modeling (AM) is a collection of values,
 principles, and practices for modeling software that can be applied on a software develop
ment project in an effective and light-weight manner. Agile models are more effective than
 traditional models because they are just barely good, they don’t have to be perfect.
 Agile modeling adopts all of the values that are consistent with the agile manifesto.
 The agile modeling philosophy recognizes that an agile team must have the courage
 to make decisions that may cause it to reject a design and refactor. The team must
 also have the humility to recognize that technologists do not have all the answers and
 that business experts and other stakeholders should be respected and embraced.
 Although AM suggests a wide array of “core” and “supplementary” modeling prin
ciples, those that make AM unique are [Amb02a]:
 Model with a purpose. A developer who uses AM should have a specific
 goal (e.g., to communicate information to the customer or to help better un
derstand some aspect of the software) in mind before creating the model.
 Once the goal for the model is identified, the type of notation to be used and
 level of detail required will be more obvious.
89
 CHAPTER 3 AGILE DEVELOPMENT
 Use multiple models. There are many different models and notations that
 can be used to describe software. Only a small subset is essential for most
 projects. AM suggests that to provide needed insight, each model should
 present a different aspect of the system and only those models that provide
 value to their intended audience should be used.
 “Traveling light” is an
 appropriate philosophy
 for all software engi
neering work. Build
 only those models that
 provide value … no
 more, no less.
 Travel light. As software engineering work proceeds, keep only those mod
els that will provide long-term value and jettison the rest. Every work product
 that is kept must be maintained as changes occur. This represents work that
 slows the team down. Ambler [Amb02a] notes that “Every time you decide to
 keep a model you trade-off agility for the convenience of having that informa
tion available to your team in an abstract manner (hence potentially enhanc
ing communication within your team as well as with project stakeholders).”
 Content is more important than representation. Modeling should im
part information to its intended audience. A syntactically perfect model that
 imparts little useful content is not as valuable as a model with flawed nota
tion that nevertheless provides valuable content for its audience.
 Know the models and the tools you use to create them. Understand
 the strengths and weaknesses of each model and the tools that are used to
 create it.
 Adapt locally. The modeling approach should be adapted to the needs of
 the agile team.
 A major segment of the software engineering community has adopted the Unified
 Modeling Language (UML)16 as the preferred method for representing analysis and
 design models. The Unified Process (Chapter 2) has been developed to provide a
 framework for the application of UML. Scott Ambler [Amb06] has developed a sim
plified version of the UP that integrates his agile modeling philosophy.
 3.5.8 Agile Unified Process (AUP)
 The Agile Unified Process (AUP) adopts a “serial in the large” and “iterative in the
 small” [Amb06] philosophy for building computer-based systems. By adopting the
 classic UP phased activities—inception, elaboration, construction, and transition—AUP
 provides a serial overlay (i.e., a linear sequence of software engineering activities)
 that enables a team to visualize the overall process flow for a software project. How
ever, within each of the activities, the team iterates to achieve agility and to deliver
 meaningful software increments to end users as rapidly as possible. Each AUP iter
ation addresses the following activities [Amb06]: 
• Modeling. UML representations of the business and problem domains are
 created. However, to stay agile, these models should be “just barely good
 enough” [Amb06] to allow the team to proceed.
 16 A brief tutorial on UML is presented in Appendix 1.
90
 PART ONE THE SOFTWARE PROCESS
 • Implementation. Models are translated into source code.
 • Testing. Like XP, the team designs and executes a series of tests to uncover
 errors and ensure that the source code meets its requirements.
 • Deployment. Like the generic process activity discussed in Chapters 1 and 2,
 deployment in this context focuses on the delivery of a software increment
 and the acquisition of feedback from end users.
 • Configuration and project management. In the context of AUP, configuration
 management (Chapter 22) addresses change management, risk manage
ment, and the control of any persistent work products17 that are produced by
 the team. Project management tracks and controls the progress of the team
 and coordinates team activities.
 • Environment management. Environment management coordinates a process
 infrastructure that includes standards, tools, and other support technology
 available to the team.
 Although the AUP has historical and technical connections to the Unified Modeling
 Language, it is important to note that UML modeling can be using in conjunction
 with any of the agile process models described in Section 3.5.
 SOFTWARE TOOLS
 Agile Development
 Objective: The objective of agile development
 tools is to assist in one or more aspects of agile
 development with an emphasis on facilitating the rapid
 generation of operational software. These tools can also
 be used when prescriptive process models (Chapter 2) are
 applied.
 Mechanics: Tool mechanics vary. In general, agile tool
 sets encompass automated support for project planning,
 use case development and requirements gathering, rapid
 design, code generation, and testing.
 Representative Tools:18
 Note: Because agile development is a hot topic, most
 software tools vendors purport to sell tools that support 
the agile approach. The tools noted here have
 characteristics that make them particularly useful for
 agile projects.
 OnTime, developed by Axosoft (www.axosoft.com),
 provides agile process management support for
 various technical activities within the process.
 Ideogramic UML, developed by Ideogramic
 (www.ideogramic.com) is a UML tool set
 specifically developed for use within an agile 
process.
 Together Tool Set, distributed by Borland
 (www.borland.com), provides a tools suite that
 supports many technical activities within XP and other
 agile processes.
 17 A persistent work product is a model or document or test case produced by the team that will be kept
 for an indeterminate period of time. It will not be discarded once the software increment is
 delivered.
 18 Tools noted here do not represent an endorsement, but rather a sampling of tools in this category.
 In most cases, tool names are trademarked by their respective developers.
91
 CHAPTER 3 AGILE DEVELOPMENT
 3.6 A TOOL SET FOR THE AGILE PROCESS
 The “tool set” that
 supports agile
 processes focuses
 more on people issues
 than it does on
 technology issues.
 Some proponents of the agile philosophy argue that automated software tools (e.g.,
 design tools) should be viewed as a minor supplement to the team’s activities, and
 not at all pivotal to the success of the team. However, Alistair Cockburn [Coc04] sug
gests that tools can have a benefit and that “agile teams stress using tools that per
mit the rapid flow of understanding. Some of those tools are social, starting even at
 the hiring stage. Some tools are technological, helping distributed teams simulate
 being physically present. Many tools are physical, allowing people to manipulate
 them in workshops.”
 Because acquiring the right people (hiring), team collaboration, stakeholder com
munication, and indirect management are key elements in virtually all agile process
 models, Cockburn argues that “tools” that address these issues are critical success
 factors for agility. For example, a hiring “tool” might be the requirement to have a
 prospective team member spend a few hours pair programming with an existing
 member of the team. The “fit” can be assessed immediately.
 Collaborative and communication “tools” are generally low tech and incorporate
 any mechanism (“physical proximity, whiteboards, poster sheets, index cards, and
 sticky notes” [Coc04]) that provides information and coordination among agile de
velopers. Active communication is achieved via the team dynamics (e.g., pair pro
gramming), while passive communication is achieved by “information radiators”
 (e.g., a flat panel display that presents the overall status of different components of
 an increment). Project management tools deemphasize the Gantt chart and replace
 it with earned value charts or “graphs of tests created versus passed . . . other agile
 tools are used to optimize the environment in which the agile team works (e.g., more
 efficient meeting areas), improve the team culture by nurturing social interactions
 (e.g., collocated teams), physical devices (e.g., electronic whiteboards), and process
 enhancement (e.g., pair programming or time-boxing)” [Coc04].
 Are any of these things really tools? They are, if they facilitate the work performed
 by an agile team member and enhance the quality of the end product.
 3.7 SUMMARY
 In a modern economy, market conditions change rapidly, customer and end-user
 needs evolve, and new competitive threats emerge without warning. Practitioners
 must approach software engineering in a manner that allows them to remain agile—
 to define maneuverable, adaptive, lean processes that can accommodate the needs
 of modern business.
 An agile philosophy for software engineering stresses four key issues: the impor
tance of self-organizing teams that have control over the work they perform, com
munication and collaboration between team members and between practitioners
 and their customers, a recognition that change represents an opportunity, and
92
 PART ONE THE SOFTWARE PROCESS
 an emphasis on rapid delivery of software that satisfies the customer. Agile process
 models have been designed to address each of these issues.
 Extreme programming (XP) is the most widely used agile process. Organized as
 four framework activities—planning, design, coding, and testing—XP suggests a
 number of innovative and powerful techniques that allow an agile team to create
 frequent software releases that deliver features and functionality that have been de
scribed and then prioritized by stakeholders.
 Other agile process models also stress human collaboration and team self
organization, but define their own framework activities and select different points of
 emphasis. For example, ASD uses an iterative process that incorporates adaptive
 cycle planning, relatively rigorous requirement gathering methods, and an iterative
 development cycle that incorporates customer focus groups and formal technical re
views as real-time feedback mechanisms. Scrum emphasizes the use of a set of soft
ware process patterns that have proven effective for projects with tight time lines,
 changing requirements, and business criticality. Each process pattern defines a set
 of development tasks and allows the Scrum team to construct a process that is
 adapted to the needs of the project. The Dynamic Systems Development Method
 (DSDM) advocates the use of time-box scheduling and suggests that only enough
 work is required for each software increment to facilitate movement to the next
 increment. Crystal is a family of agile process models that can be adopted to the spe
cific characteristics of a project.
 Feature Driven Development (FDD) is somewhat more “formal” than other agile
 methods, but still maintains agility by focusing the project team on the development
 of features—a client-valued function that can be implemented in two weeks or less.
 Lean Software Development (LSD) has adapted the principles of lean manufacturing
 to the world of software engineering. Agile modeling (AM) suggests that modeling is
 essential for all systems, but that the complexity, type, and size of the model must be
 tuned to the software to be built. The Agile Unified Process (AUP) adopts a “serial in
 the large” and “iterative in the small” philosophy for building software.
 PROBLEMS AND POINTS TO PONDER
 3.1. Reread “The Manifesto for Agile Software Development” at the beginning of this chapter.
 Can you think of a situation in which one or more of the four “values” could get a software team
 into trouble?
 3.2. Describe agility (for software projects) in your own words.
 3.3. Why does an iterative process make it easier to manage change? Is every agile process dis
cussed in this chapter iterative? Is it possible to complete a project in just one iteration and still
 be agile? Explain your answers.
 3.4. Could each of the agile processes be described using the generic framework activities
 noted in Chapter 2? Build a table that maps the generic activities into the activities defined for
 each agile process.
 3.5. Try to come up with one more “agility principle” that would help a software engineering
 team become even more maneuverable.
93
 CHAPTER 3 AGILE DEVELOPMENT
 3.6. Select one agility principle noted in Section 3.3.1 and try to determine whether each of the
 process models presented in this chapter exhibits the principle. [Note: I have presented an
 overview of these process models only, so it may not be possible to determine whether a prin
ciple has been addressed by one or more of the models, unless you do additional research
 (which is not required for this problem).]
 3.7. Why do requirements change so much? After all, don’t people know what they want?
 3.8. Most agile process models recommend face-to-face communication. Yet today, members
 of a software team and their customers may be geographically separated from one another. Do
 you think this implies that geographical separation is something to avoid? Can you think of ways
 to overcome this problem?
 3.9. Write an XP user story that describes the “favorite places” or “bookmarks” feature avail
able on most Web browsers.
 3.10. What is a spike solution in XP?
 3.11. Describe the XP concepts of refactoring and pair programming in your own words.
 3.12. Do a bit more reading and describe what a time-box is. How does this assist an ASD team
 in delivering software increments in a short time period?
 3.13. Do the 80 percent rule in DSDM and the time-boxing approach defined for ASD achieve
 the same result?
 3.14. Using the process pattern template presented in Chapter 2, develop a process pattern for
 any one of the Scrum patterns presented in Section 3.5.2.
 3.15. Why is Crystal called a family of agile methods?
 3.16. Using the FDD feature template described in Section 3.5.5, define a feature set for a Web
 browser. Now develop a set of features for the feature set.
 3.17. Visit the Official Agile Modeling Site and make a complete list of all core and supple
mentary AM principles.
 3.18. The tool set proposed in Section 3.6 supports many of the “soft” aspects of agile meth
ods. Since communication is so important, recommend an actual tool set that might be used to
 enhance communication among stakeholders on an agile team.
 FURTHER READINGS AND INFORMATION SOURCES
 The overall philosophy and underlying principles of agile software development are considered
 in depth in many of the books referenced in the body of this chapter. In addition, books by Shaw
 and Warden (The Art of Agile Development, O’Reilly Media, Inc., 2008), Hunt (Agile Software Con
struction, Springer, 2005), and Carmichael and Haywood (Better Software Faster, Prentice-Hall,
 2002) present useful discussions of the subject. Aguanno (Managing Agile Projects, Multi
Media Publications, 2005), Highsmith (Agile Project Management: Creating Innovative Products,
 Addison-Wesley, 2004), and Larman (Agile and Iterative Development: A Manager’s Guide,
 Addison-Wesley, 2003) present a management overview and consider project management
 issues. Highsmith (Agile Software Development Ecosystems, Addison-Wesley, 2002) presents a
 survey of agile principles, processes, and practices. A worthwhile discussion of the delicate bal
ance between agility and discipline is presented by Booch and his colleagues (Balancing Agility
 and Discipline, Addison-Wesley, 2004).
 Martin (Clean Code: A Handbook of Agile Software Craftsmanship, Prentice-Hall, 2009) pres
ents the principles, patterns, and practices required to develop “clean code” in an agile software
 engineering environment. Leffingwell (Scaling Software Agility: Best Practices for Large Enter
prises, Addison-Wesley, 2007) discusses strategies for scaling up agile practices for large proj
ects. Lippert and Rook (Refactoring in Large Software Projects: Performing Complex Restructurings
 Successfully, Wiley, 2006) discuss the use of refactoring when applied in large, complex systems.
94
 PART ONE THE SOFTWARE PROCESS
 Stamelos and Sfetsos (Agile Software Development Quality Assurance, IGI Global, 2007) discuss
 SQA techniques that conform to the agile philosophy.
 Dozens of books have been written about Extreme Programming over the past decade. Beck
 (Extreme Programming Explained: Embrace Change, 2d ed., Addison-Wesley, 2004) remains the
 definitive treatment of the subject. In addition, Jeffries and his colleagues (Extreme Programming
 Installed, Addison-Wesley, 2000), Succi and Marchesi (Extreme Programming Examined,
 Addison-Wesley, 2001), Newkirk and Martin (Extreme Programming in Practice, Addison-Wesley,
 2001), and Auer and his colleagues (Extreme Programming Applied: Play to Win, Addison-Wesley,
 2001) provide a nuts-and-bolts discussion of XP along with guidance on how best to apply it.
 McBreen (Questioning Extreme Programming, Addison-Wesley, 2003) takes a critical look at XP,
 defining when and where it is appropriate. An in-depth consideration of pair programming is
 presented by McBreen (Pair Programming Illuminated, Addison-Wesley, 2003).
 ASD is addressed in depth by Highsmith [Hig00]. Schwaber (The Enterprise and Scrum,
 Microsoft Press, 2007) discusses the use of Scrum for projects that have a major business
 impact. The nuts and bolts of Scrum are discussed by Schwaber and Beedle (Agile Software
 Development with SCRUM, Prentice-Hall, 2001). Worthwhile treatments of DSDM have been
 written by the DSDM Consortium (DSDM: Business Focused Development, 2d ed., Pearson Edu
cation, 2003) and Stapleton (DSDM: The Method in Practice, Addison-Wesley, 1997). Cockburn
 (Crystal Clear, Addison-Wesley, 2005) presents an excellent overview of the Crystal family of
 processes. Palmer and Felsing [Pal02] present a detailed treatment of FDD. Carmichael and
 Haywood (Better Software Faster, Prentice-Hall, 2002) provides another useful treatment of FDD
 that includes a step-by-step journey through the mechanics of the process. Poppendieck and 
Poppendieck (Lean Development: An Agile Toolkit for Software Development Managers, Addison
Wesley, 2003) provide guidelines for managing and controlling agile projects. Ambler and
 Jeffries (Agile Modeling, Wiley, 2002) discuss AM in some depth.
 A wide variety of information sources on agile software development are available on the
 Internet. An up-to-date list of World Wide Web references that are relevant to the agile process
 can be found at the SEPA website: www.mhhe.com/engcs/compsci/pressman/
 professional/olc/ser.htm.
In 2001, Kent Beck and 16 other noted software developers, writers, and con
sultants [Bec01a] (referred to as the “Agile Alliance”) signed the “Manifesto for
 Agile Software Development.” It stated:
 We are uncovering better ways of developing software by doing it and helping others
 do it. Through this work we have come to value: 
Individuals and interactions over processes and tools
 Working software over comprehensive documentation
 Customer collaboration over contract negotiation
 Responding to change over following a plan
 That is, while there is value in the items on the right, we value the items on the 
left more.
 QUICK
 LOOK
 What is it? Agile software engi
neering combines a philosophy and
 a set of development guidelines. The
 philosophy encourages customer
 satisfaction and early incremental delivery of
 software; small, highly motivated project teams;
 informal methods; minimal software engineer
ing work products; and overall development
 simplicity. The development guidelines stress
 delivery over analysis and design (although
 these activities are not discouraged), and active
 and continuous communication between devel
opers and customers.
 Who does it? Software engineers and other
 project stakeholders (managers, customers, end
 users) work together on an agile team—a team
 that is self-organizing and in control of its own
 destiny. An agile team fosters communication
 and collaboration among all who serve on it.
 Why is it important? The modern business envi
ronment that spawns computer-based systems
 and software products is fast-paced and ever
changing. Agile software engineering repre
sents a reasonable alternative to conventional
 software engineering for certain classes of soft
ware and certain types of software projects. It
 has been demonstrated to deliver successful sys
tems quickly.
 Whatarethesteps? Agiledevelopmentmightbest
 be termed “software engineering lite.” The basic
 framework activities—communication, planning,
 modeling, construction, and deployment—
 remain. But they morph into a minimal task set
 that pushes the project team toward construction
 and delivery (some would argue that this is
 done at the expense of problem analysis and
 solution design).
 What is the work product? Both the customer
 and the software engineer have the same
 view—the only really important work product
 is an operational “software increment” that is
 delivered to the customer on the appropriate
 commitment date.
 How do I ensure that I’ve done it right? If the
 agile team agrees that the process works, and
 the team produces deliverable software
 increments that satisfy the customer, you’ve
 done it right.
 65
66
 PART ONE THE SOFTWARE PROCESS
 FDD . . . . . . . . . .86
 Industrial XP . . .77
 Lean Software
 Development . . .87
 pair 
programming . . .76
 project 
velocity . . . . . . .74
 refactoring . . . . .75
 Scrum . . . . . . . .82
 stories . . . . . . . .74
 XP process . . . . .73
 uote:
 “Agility: 1,
 everything else: 0.”
 Tom DeMarco
 A manifesto is normally associated with an emerging political movement—one
 that attacks the old guard and suggests revolutionary change (hopefully for the
 better). In some ways, that’s exactly what agile development is all about.
 Although the underlying ideas that guide agile development have been with us for
 many years, it has been less than two decades since these ideas have crystallized
 into a “movement.” In essence, agile1 methods were developed in an effort to over
come perceived and actual weaknesses in conventional software engineering. Agile
 development can provide important benefits, but it is not applicable to all projects,
 all products, all people, and all situations. It is also not antithetical to solid software
 engineering practice and can be applied as an overriding philosophy for all software
 work.
 In the modern economy, it is often difficult or impossible to predict how a
 computer-based system (e.g., a Web-based application) will evolve as time passes.
 Market conditions change rapidly, end-user needs evolve, and new competitive
 threats emerge without warning. In many situations, you won’t be able to define
 requirements fully before the project begins. You must be agile enough to respond to
 a fluid business environment.
 Fluidity implies change, and change is expensive. Particularly if it is uncontrolled
 or poorly managed. One of the most compelling characteristics of the agile approach
 is its ability to reduce the costs of change throughout the software process.
 Does this mean that a recognition of challenges posed by modern realities causes
 you to discard valuable software engineering principles, concepts, methods, and
 tools? Absolutely not! Like all engineering disciplines, software engineering contin
ues to evolve. It can be adapted easily to meet the challenges posed by a demand for
 agility.
 In a thought-provoking book on agile software development, Alistair Cockburn
 [Coc02] argues that the prescriptive process models introduced in Chapter 2 have a
 major failing: they forget the frailties of the people who build computer software. Software
 engineers are not robots. They exhibit great variation in working styles; significant dif
ferences in skill level, creativity, orderliness, consistency, and spontaneity. Some com
municate well in written form, others do not. Cockburn argues that process models
 can “deal with people’s common weaknesses with [either] discipline or tolerance” and
 that most prescriptive process models choose discipline. He states: “Because consis
tency in action is a human weakness, high discipline methodologies are fragile.”
 If process models are to work, they must provide a realistic mechanism for en
couraging the discipline that is necessary, or they must be characterized in a man
ner that shows “tolerance” for the people who do software engineering work.
 Invariably, tolerant practices are easier for software people to adopt and sustain, but
 (as Cockburn admits) they may be less productive. Like most things in life, trade-offs
 must be considered.
 1 Agile methods are sometimes referred to as light methods or lean methods.
67
 CHAPTER 3 AGILE DEVELOPMENT
 3.1 WHAT IS AGILITY?
 Just what is agility in the context of software engineering work? Ivar Jacobson
 [Jac02a] provides a useful discussion:
 Agility has become today’s buzzword when describing a modern software process. Every
one is agile. An agile team is a nimble team able to appropriately respond to changes.
 Change is what software development is very much about. Changes in the software be
ing built, changes to the team members, changes because of new technology, changes of
 all kinds that may have an impact on the product they build or the project that creates the
 product. Support for changes should be built-in everything we do in software, something
 we embrace because it is the heart and soul of software. An agile team recognizes that
 software is developed by individuals working in teams and that the skills of these people,
 their ability to collaborate is at the core for the success of the project.
 Don’t make the
 mistake of assuming
 that agility gives you
 license to hack out
 solutions. A process is
 required and discipline
 is essential.
 In Jacobson’s view, the pervasiveness of change is the primary driver for agility. Soft
ware engineers must be quick on their feet if they are to accommodate the rapid
 changes that Jacobson describes.
 But agility is more than an effective response to change. It also encompasses the
 philosophy espoused in the manifesto noted at the beginning of this chapter. It
 encourages team structures and attitudes that make communication (among team
 members, between technologists and business people, between software engineers
 and their managers) more facile. It emphasizes rapid delivery of operational soft
ware and de-emphasizes the importance of intermediate work products (not always
 a good thing); it adopts the customer as a part of the development team and works
 to eliminate the “us and them” attitude that continues to pervade many software
 projects; it recognizes that planning in an uncertain world has its limits and that a
 project plan must be flexible.
 Agility can be applied to any software process. However, to accomplish this, it is
 essential that the process be designed in a way that allows the project team to adapt
 tasks and to streamline them, conduct planning in a way that understands the fluid
ity of an agile development approach, eliminate all but the most essential work prod
ucts and keep them lean, and emphasize an incremental delivery strategy that gets
 working software to the customer as rapidly as feasible for the product type and
 operational environment.
 3.2 AGILITY AND THE COST OF CHANGE
 The conventional wisdom in software development (supported by decades of expe
rience) is that the cost of change increases nonlinearly as a project progresses
 (Figure 3.1, solid black curve). It is relatively easy to accommodate a change when a
 software team is gathering requirements (early in a project). A usage scenario might
 have to be modified, a list of functions may be extended, or a written specification
 can be edited. The costs of doing this work are minimal, and the time required will
68
 PART ONE THE SOFTWARE PROCESS
 FIGURE 3.1
 Change costs
 as a function
 of time in
 development
 uote:
 Development cost
 Cost of change
 using conventional
 software processes
 Cost of change
 using agile processes
 “Agility is dynamic,
 content specific,
 aggressively
 change embracing,
 and growth
 oriented.”
 Idealized cost of change
 using agile process
 Development schedule progress–Steven
 Goldman et al.
 An agile process
 reduces the cost of
 change because
 software is released in
 increments and change
 can be better
 controlled within an
 increment.
 not adversely affect the outcome of the project. But what if we fast-forward a num
ber of months? The team is in the middle of validation testing (something that occurs
 relatively late in the project), and an important stakeholder is requesting a major
 functional change. The change requires a modification to the architectural design of
 the software, the design and construction of three new components, modifications
 to another five components, the design of new tests, and so on. Costs escalate
 quickly, and the time and cost required to ensure that the change is made without
 unintended side effects is nontrivial.
 Proponents of agility (e.g., [Bec00], [Amb04]) argue that a well-designed agile
 process “flattens” the cost of change curve (Figure 3.1, shaded, solid curve), allowing
 a software team to accommodate changes late in a software project without dramatic
 cost and time impact. You’ve already learned that the agile process encompasses in
cremental delivery. When incremental delivery is coupled with other agile practices
 such as continuous unit testing and pair programming (discussed later in this chap
ter), the cost of making a change is attenuated. Although debate about the degree to
 which the cost curve flattens is ongoing, there is evidence [Coc01a] to suggest that a
 significant reduction in the cost of change can be achieved.
 3.3 WHAT IS ANAGILE PROCESS?
 Any agile software process is characterized in a manner that addresses a number of
 key assumptions [Fow02] about the majority of software projects: 
1. It is difficult to predict in advance which software requirements will persist
 and which will change. It is equally difficult to predict how customer
 priorities will change as the project proceeds.
69
 CHAPTER 3 AGILE DEVELOPMENT
 WebRef
 A comprehensive
 collection of articles on
 the agile process 
can be found at
 www.aanpo.org/
 articles/index.
 Although agile
 processes embrace
 change, it is still
 important to examine
 the reasons for
 change.
 Working software is
 important, but don’t
 forget that it must also
 exhibit a variety of
 quality attributes
 including reliability,
 usability, and 
maintainability.
 2. For many types of software, design and construction are interleaved. That is,
 both activities should be performed in tandem so that design models are
 proven as they are created. It is difficult to predict how much design is
 necessary before construction is used to prove the design.
 3. Analysis, design, construction, and testing are not as predictable (from a
 planning point of view) as we might like.
 Given these three assumptions, an important question arises: How do we create a
 process that can manage unpredictability? The answer, as I have already noted, lies
 in process adaptability (to rapidly changing project and technical conditions). An
 agile process, therefore, must be adaptable.
 But continual adaptation without forward progress accomplishes little. Therefore,
 an agile software process must adapt incrementally. To accomplish incremental adap
tation, an agile team requires customer feedback (so that the appropriate adaptations
 can be made). An effective catalyst for customer feedback is an operational prototype
 or a portion of an operational system. Hence, an incremental development strategy
 should be instituted. Software increments (executable prototypes or portions of an op
erational system) must be delivered in short time periods so that adaptation keeps pace
 with change (unpredictability). This iterative approach enables the customer to evalu
ate the software increment regularly, provide necessary feedback to the software team,
 and influence the process adaptations that are made to accommodate the feedback.
 3.3.1 Agility Principles
 The Agile Alliance (see [Agi03], [Fow01]) defines 12 agility principles for those who
 want to achieve agility: 
1. Our highest priority is to satisfy the customer through early and continuous
 delivery of valuable software.
 2. Welcome changing requirements, even late in development. Agile processes
 harness change for the customer’s competitive advantage.
 3. Deliver working software frequently, from a couple of weeks to a couple of
 months, with a preference to the shorter timescale.
 4. Business people and developers must work together daily throughout the
 project.
 5. Build projects around motivated individuals. Give them the environment and
 support they need, and trust them to get the job done.
 6. The most efficient and effective method of conveying information to and
 within a development team is face-to-face conversation.
 7. Working software is the primary measure of progress.
 8. Agile processes promote sustainable development. The sponsors, developers,
 and users should be able to maintain a constant pace indefinitely.
70
 PART ONE THE SOFTWARE PROCESS
 9. Continuous attention to technical excellence and good design enhances
 agility.
 10. Simplicity—the art of maximizing the amount of work not done—is 
essential.
 11. The best architectures, requirements, and designs emerge from self
organizing teams.
 12. At regular intervals, the team reflects on how to become more effective, then
 tunes and adjusts its behavior accordingly.
 Not every agile process model applies these 12 principles with equal weight, and
 some models choose to ignore (or at least downplay) the importance of one or more
 of the principles. However, the principles define an agile spirit that is maintained in
 each of the process models presented in this chapter.
 3.3.2 The Politics of Agile Development
 You don’t have to
 choose between agility
 and software engi
neering. Rather, define
 a software engineering
 approach that is agile.
 There is considerable debate (sometimes strident) about the benefits and applicabil
ity of agile software development as opposed to more conventional software engi
neering processes. Jim Highsmith [Hig02a] (facetiously) states the extremes when he
 characterizes the feeling of the pro-agility camp (“agilists”). “Traditional methodolo
gists are a bunch of stick-in-the-muds who’d rather produce flawless documentation
 than a working system that meets business needs.” As a counterpoint, he states
 (again, facetiously) the position of the traditional software engineering camp: “Light
weight, er, ‘agile’ methodologists are a bunch of glorified hackers who are going to
 be in for a heck of a surprise when they try to scale up their toys into enterprise-wide
 software.”
 Like all software technology arguments, this methodology debate risks degener
ating into a religious war. If warfare breaks out, rational thought disappears and
 beliefs rather than facts guide decision making.
 No one is against agility. The real question is: What is the best way to achieve it?
 As important, how do you build software that meets customers’ needs today and
 exhibits the quality characteristics that will enable it to be extended and scaled to
 meet customers’ needs over the long term?
 There are no absolute answers to either of these questions. Even within the agile
 school itself, there are many proposed process models (Section 3.4), each with a
 subtly different approach to the agility problem. Within each model there is a set of
 “ideas” (agilists are loath to call them “work tasks”) that represent a significant
 departure from traditional software engineering. And yet, many agile concepts are
 simply adaptations of good software engineering concepts. Bottom line: there is
 much that can be gained by considering the best of both schools and virtually
 nothing to be gained by denigrating either approach.
 If you have further interest, see [Hig01], [Hig02a], and [DeM02] for an entertain
ing summary of other important technical and political issues.
71
 CHAPTER 3 AGILE DEVELOPMENT
 uote:
 “Agile methods
 derive much of
 their agility by
 relying on the
 tacit knowledge
 embodied in the
 team, rather than
 writing the
 knowledge down
 in plans.”
 Barry Boehm
 ?
 What key
 traits must
 exist among the
 people on an
 effective software
 team?
 uote:
 “What counts as
 barely sufficient
 for one team is
 either overly
 sufficient or
 insufficient for
 another.”
 Alistair
 Cockburn
 3.3.3 Human Factors
 Proponents of agile software development take great pains to emphasize the impor
tance of “people factors.” As Cockburn and Highsmith [Coc01a] state, “Agile devel
opment focuses on the talents and skills of individuals, molding the process to
 specific people and teams.” The key point in this statement is that the process molds
 to the needs of the people and team, not the other way around.2
 If members of the software team are to drive the characteristics of the process that
 is applied to build software, a number of key traits must exist among the people on
 an agile team and the team itself:
 Competence. In an agile development (as well as software engineering)
 context, “competence” encompasses innate talent, specific software-related
 skills, and overall knowledge of the process that the team has chosen to
 apply. Skill and knowledge of process can and should be taught to all people
 who serve as agile team members.
 Common focus. Although members of the agile team may perform differ
ent tasks and bring different skills to the project, all should be focused on one
 goal—to deliver a working software increment to the customer within the
 time promised. To achieve this goal, the team will also focus on continual
 adaptations (small and large) that will make the process fit the needs of the
 team.
 Collaboration. Software engineering (regardless of process) is about as
sessing, analyzing, and using information that is communicated to the soft
ware team; creating information that will help all stakeholders understand
 the work of the team; and building information (computer software and rele
vant databases) that provides business value for the customer. To accomplish
 these tasks, team members must collaborate—with one another and all other
 stakeholders.
 Decision-making ability. Any good software team (including agile teams)
 must be allowed the freedom to control its own destiny. This implies that the
 team is given autonomy—decision-making authority for both technical and
 project issues.
 Fuzzy problem-solving ability. Software managers must recognize that
 the agile team will continually have to deal with ambiguity and will continu
ally be buffeted by change. In some cases, the team must accept the fact that
 the problem they are solving today may not be the problem that needs to be
 solved tomorrow. However, lessons learned from any problem-solving
 2 Successful software engineering organizations recognize this reality regardless of the process
 model they choose.
72
 PART ONE THE SOFTWARE PROCESS
 A self-organizing team
 is in control of the
 work it performs. The
 team makes its own
 commitments and
 defines plans to
 achieve them.
 activity (including those that solve the wrong problem) may be of benefit to
 the team later in the project.
 Mutual trust and respect. The agile team must become what DeMarco
 and Lister [DeM98] call a “jelled” team (Chapter 24). A jelled team exhibits
 the trust and respect that are necessary to make them “so strongly knit that
 the whole is greater than the sum of the parts.” [DeM98]
 Self-organization. In the context of agile development, self-organization
 implies three things: (1) the agile team organizes itself for the work to be
 done, (2) the team organizes the process to best accommodate its local envi
ronment, (3) the team organizes the work schedule to best achieve delivery
 of the software increment. Self-organization has a number of technical bene
fits, but more importantly, it serves to improve collaboration and boost team
 morale. In essence, the team serves as its own management. Ken Schwaber
 [Sch02] addresses these issues when he writes: “The team selects how much
 work it believes it can perform within the iteration, and the team commits to
 the work. Nothing demotivates a team as much as someone else making
 commitments for it. Nothing motivates a team as much as accepting the
 responsibility for fulfilling commitments that it made itself.”
 3.4 EXTREME PROGRAMMING (XP)
 In order to illustrate an agile process in a bit more detail, I’ll provide you with an
 overview of Extreme Programming (XP), the most widely used approach to agile soft
ware development. Although early work on the ideas and methods associated with
 XP occurred during the late 1980s, the seminal work on the subject has been written
 by Kent Beck [Bec04a]. More recently, a variant of XP, called Industrial XP (IXP) has
 been proposed [Ker05]. IXP refines XP and targets the agile process specifically for
 use within large organizations.
 3.4.1 XP Values
 Beck [Bec04a] defines a set of five values that establish a foundation for all work per
formed as part of XP—communication, simplicity, feedback, courage, and respect. Each
 of these values is used as a driver for specific XP activities, actions, and tasks.
 In order to achieve effective communication between software engineers and
 other stakeholders (e.g., to establish required features and functions for the soft
ware), XP emphasizes close, yet informal (verbal) collaboration between customers
 and developers, the establishment of effective metaphors3 for communicating
 important concepts, continuous feedback, and the avoidance of voluminous docu
mentation as a communication medium.
 3 In the XP context, a metaphor is “a story that everyone—customers, programmers, and managers—
 can tell about how the system works” [Bec04a].
73
 CHAPTER 3 AGILE DEVELOPMENT
 Keep it simple
 whenever you can, but
 recognize that
 continual “refactoring”
 can absorb significant
 time and resources.
 uote:
 “XP is the answer
 to the question,
 ‘How little can we
 do and still build
 great software?’“
 Anonymous
 WebRef
 An excellent overview
 of “rules” for XP can
 be found at www
 .extremeprogramm
 ing.org/rules.html.
 To achieve simplicity, XP restricts developers to design only for immediate needs,
 rather than consider future needs. The intent is to create a simple design that can be
 easily implemented in code). If the design must be improved, it can be refactored4 at
 a later time.
 Feedback is derived from three sources: the implemented software itself, the
 customer, and other software team members. By designing and implementing an
 effective testing strategy (Chapters 17 through 20), the software (via test results) pro
vides the agile team with feedback. XP makes use of the unit test as its primary test
ing tactic. As each class is developed, the team develops a unit test to exercise each
 operation according to its specified functionality. As an increment is delivered to a
 customer, the user stories or use cases (Chapter 5) that are implemented by the
 increment are used as a basis for acceptance tests. The degree to which the software
 implements the output, function, and behavior of the use case is a form of feedback.
 Finally, as new requirements are derived as part of iterative planning, the team pro
vides the customer with rapid feedback regarding cost and schedule impact.
 Beck [Bec04a] argues that strict adherence to certain XP practices demands
 courage. A better word might be discipline. For example, there is often significant
 pressure to design for future requirements. Most software teams succumb, arguing
 that “designing for tomorrow” will save time and effort in the long run. An agile XP
 team must have the discipline (courage) to design for today, recognizing that future
 requirements may change dramatically, thereby demanding substantial rework of
 the design and implemented code.
 By following each of these values, the agile team inculcates respect among it
 members, between other stakeholders and team members, and indirectly, for the
 software itself. As they achieve successful delivery of software increments, the team
 develops growing respect for the XP process.
 3.4.2 The XP Process
 Extreme Programming uses an object-oriented approach (Appendix 2) as its pre
ferred development paradigm and encompasses a set of rules and practices that
 occur within the context of four framework activities: planning, design, coding, and
 testing. Figure 3.2 illustrates the XP process and notes some of the key ideas and
 tasks that are associated with each framework activity. Key XP activities are sum
marized in the paragraphs that follow.
 Planning. The planning activity (also called the planning game) begins with
 listening—a requirements gathering activity that enables the technical members of
 the XP team to understand the business context for the software and to get a broad
 4 Refactoring allows a software engineer to improve the internal structure of a design (or source
 code) without changing its external functionality or behavior. In essence, refactoring can be used
 to improve the efficiency, readability, or performance of a design or the code that implements a
 design.
74
 PART ONE THE SOFTWARE PROCESS
 FIGURE 3.2
 The Extreme
 Programming
 process
 ?
 What is an
 XP “story”?
 WebRef
 A worthwhile XP
 “planning game” can
 be found at:
 c2.com/cgi/
 wiki?planningGame.
 simple design
 CRC cards
 user stories
 values
 acceptance test criteria
 iteration plan
 Release
 spike solutions
 prototypes
 refactoring
 design
 pair programming
 planning
 software increment
 project velocity computed
 unit test
 continuous integration
 acceptance testing
 test
 coding
 feel for required output and major features and functionality. Listening leads to the
 creation of a set of “stories” (also called user stories) that describe required output,
 features, and functionality for software to be built. Each story (similar to use cases
 described in Chapter 5) is written by the customer and is placed on an index card.
 The customer assigns a value (i.e., a priority) to the story based on the overall busi
ness value of the feature or function.5 Members of the XP team then assess each
 story and assign a cost—measured in development weeks—to it. If the story is esti
mated to require more than three development weeks, the customer is asked to split
 the story into smaller stories and the assignment of value and cost occurs again. It
 is important to note that new stories can be written at any time.
 Customers and developers work together to decide how to group stories into the
 next release (the next software increment) to be developed by the XP team. Once a
 basic commitment (agreement on stories to be included, delivery date, and other
 project matters) is made for a release, the XP team orders the stories that will be de
veloped in one of three ways: (1) all stories will be implemented immediately (within
 a few weeks), (2) the stories with highest value will be moved up in the schedule and
 implemented first, or (3) the riskiest stories will be moved up in the schedule and
 implemented first.
 After the first project release (also called a software increment) has been deliv
ered, the XP team computes project velocity. Stated simply, project velocity is the
 5 The value of a story may also be dependent on the presence of another story.
75
 CHAPTER 3 AGILE DEVELOPMENT
 Project velocity is a
 subtle measure of
 team productivity.
 XP deemphasizes the
 importance of design.
 Not everyone agrees.
 In fact, there are times
 when design should be
 emphasized.
 WebRef
 Refactoring techniques
 and tools can be
 found at:
 www.refactoring
 .com.
 number of customer stories implemented during the first release. Project velocity can
 then be used to (1) help estimate delivery dates and schedule for subsequent releases
 and (2) determine whether an overcommitment has been made for all stories across
 the entire development project. If an overcommitment occurs, the content of releases
 is modified or end delivery dates are changed.
 As development work proceeds, the customer can add stories, change the value
 of an existing story, split stories, or eliminate them. The XP team then reconsiders all
 remaining releases and modifies its plans accordingly.
 Design. XP design rigorously follows the KIS (keep it simple) principle. A simple
 design is always preferred over a more complex representation. In addition, the de
sign provides implementation guidance for a story as it is written—nothing less,
 nothing more. The design of extra functionality (because the developer assumes it
 will be required later) is discouraged.6
 XP encourages the use of CRC cards (Chapter 7) as an effective mechanism for
 thinking about the software in an object-oriented context. CRC (class-responsibility
collaborator) cards identify and organize the object-oriented classes7 that are rele
vant to the current software increment. The XP team conducts the design exercise
 using a process similar to the one described in Chapter 8. The CRC cards are the only
 design work product produced as part of the XP process.
 If a difficult design problem is encountered as part of the design of a story, XP rec
ommends the immediate creation of an operational prototype of that portion of the
 design. Called a spike solution, the design prototype is implemented and evaluated.
 The intent is to lower risk when true implementation starts and to validate the orig
inal estimates for the story containing the design problem.
 In the preceding section, we noted that XP encourages refactoring—a construction
 technique that is also a method for design optimization. Fowler [Fow00] describes
 refactoring in the following manner:
 Refactoring is the process of changing a software system in such a way that it does not
 alter the external behavior of the code yet improves the internal structure. It is a disci
plined way to clean up code [and modify/simplify the internal design] that minimizes the
 chances of introducing bugs. In essence, when you refactor you are improving the design
 of the code after it has been written.
 Because XP design uses virtually no notation and produces few, if any, work prod
ucts other than CRC cards and spike solutions, design is viewed as a transient arti
fact that can and should be continually modified as construction proceeds. The intent
 of refactoring is to control these modifications by suggesting small design changes
 6 These design guidelines should be followed in every software engineering method, although there
 are times when sophisticated design notation and terminology may get in the way of simplicity.
 7 Object-oriented classes are discussed in Appendix 2, in Chapter 8, and throughout Part 2 of this
 book.
76
 PART ONE THE SOFTWARE PROCESS
 Refactoring improves
 the internal structure of
 a design (or source
 code) without
 changing its external
 functionality or
 behavior.
 WebRef
 Useful information on
 XP can be obtained 
at www
 .xprogramming.
 com.
 ?
 What is 
pair
 programming?
 Many software teams
 are populated by indi
vidualists. You’ll have
 to work to change that
 culture if pair program
ming is to work effec
tively.
 ?
 XP?
 How are unit
 tests used in
 that “can radically improve the design” [Fow00]. It should be noted, however, that
 the effort required for refactoring can grow dramatically as the size of an application
 grows.
 A central notion in XP is that design occurs both before and after coding com
mences. Refactoring means that design occurs continuously as the system is con
structed. In fact, the construction activity itself will provide the XP team with
 guidance on how to improve the design.
 Coding. After stories are developed and preliminary design work is done, the team
 does not move to code, but rather develops a series of unit tests that will exercise
 each of the stories that is to be included in the current release (software increment).8
 Once the unit test9 has been created, the developer is better able to focus on what
 must be implemented to pass the test. Nothing extraneous is added (KIS). Once the
 code is complete, it can be unit-tested immediately, thereby providing instantaneous
 feedback to the developers.
 A key concept during the coding activity (and one of the most talked about aspects
 of XP) is pair programming. XP recommends that two people work together at one
 computer workstation to create code for a story. This provides a mechanism for real
time problem solving (two heads are often better than one) and real-time quality as
surance (the code is reviewed as it is created). It also keeps the developers focused
 on the problem at hand. In practice, each person takes on a slightly different role. For
 example, one person might think about the coding details of a particular portion of
 the design while the other ensures that coding standards (a required part of XP) are
 being followed or that the code for the story will satisfy the unit test that has been
 developed to validate the code against the story.
 As pair programmers complete their work, the code they develop is integrated
 with the work of others. In some cases this is performed on a daily basis by an inte
gration team. In other cases, the pair programmers have integration responsibility.
 This “continuous integration” strategy helps to avoid compatibility and interfacing
 problems and provides a “smoke testing” environment (Chapter 17) that helps to
 uncover errors early.
 Testing. I have already noted that the creation of unit tests before coding com
mences is a key element of the XP approach. The unit tests that are created should
 be implemented using a framework that enables them to be automated (hence, they
 can be executed easily and repeatedly). This encourages a regression testing strat
egy (Chapter 17) whenever code is modified (which is often, given the XP refactor
ing philosophy).
 8 This approach is analogous to knowing the exam questions before you begin to study. It makes
 studying much easier by focusing attention only on the questions that will be asked.
 9 Unit testing, discussed in detail in Chapter 17, focuses on an individual software component, exer
cising the component’s interface, data structures, and functionality in an effort to uncover errors
 that are local to the component.
77
 CHAPTER 3 AGILE DEVELOPMENT
 XP acceptance tests
 are derived from user
 stories.
 ?
 What new
 practices are
 appended to XP
 to create IXP?
 uote:
 “Ability is what
 you’re capable of
 doing. Motivation
 determines what
 you do. Attitude
 determines how
 well you do it.”
 Lou Holtz
 As the individual unit tests are organized into a “universal testing suite” [Wel99],
 integration and validation testing of the system can occur on a daily basis. This pro
vides the XP team with a continual indication of progress and also can raise warn
ing flags early if things go awry. Wells [Wel99] states: “Fixing small problems every
 few hours takes less time than fixing huge problems just before the deadline.”
 XP acceptance tests, also called customer tests, are specified by the customer and
 focus on overall system features and functionality that are visible and reviewable by
 the customer. Acceptance tests are derived from user stories that have been imple
mented as part of a software release.
 3.4.3 Industrial XP
 Joshua Kerievsky [Ker05] describes Industrial Extreme Programming (IXP) in the fol
lowing manner: “IXP is an organic evolution of XP. It is imbued with XP’s minimal
ist, customer-centric, test-driven spirit. IXP differs most from the original XP in its
 greater inclusion of management, its expanded role for customers, and its upgraded
 technical practices.” IXP incorporates six new practices that are designed to help
 ensure that an XP project works successfully for significant projects within a large
 organization.
 Readiness assessment. Prior to the initiation of an IXP project, the organ
ization should conduct a readiness assessment. The assessment ascertains
 whether (1) an appropriate development environment exists to support IXP,
 (2) the team will be populated by the proper set of stakeholders, (3) the or
ganization has a distinct quality program and supports continuous improve
ment, (4) the organizational culture will support the new values of an agile
 team, and (5) the broader project community will be populated appropriately.
 Project community. Classic XP suggests that the right people be used to
 populate the agile team to ensure success. The implication is that people on
 the team must be well-trained, adaptable and skilled, and have the proper
 temperament to contribute to a self-organizing team. When XP is to be
 applied for a significant project in a large organization, the concept of the
 “team” should morph into that of a community. A community may have a
 technologist and customers who are central to the success of a project as
 well as many other stakeholders (e.g., legal staff, quality auditors, manufac
turing or sales types) who “are often at the periphery of an IXP project yet
 they may play important roles on the project” [Ker05]. In IXP, the community
 members and their roles should be explicitly defined and mechanisms for
 communication and coordination between community members should be
 established.
 Project chartering. The IXP team assesses the project itself to determine
 whether an appropriate business justification for the project exists and
 whether the project will further the overall goals and objectives of the
78
 PART ONE THE SOFTWARE PROCESS
 organization. Chartering also examines the context of the project to deter
mine how it complements, extends, or replaces existing systems or
 processes.
 Test-driven management. An IXP project requires measurable criteria for
 assessing the state of the project and the progress that has been made to
 date. Test-driven management establishes a series of measurable “destina
tions” [Ker05] and then defines mechanisms for determining whether or not
 these destinations have been reached.
 Retrospectives. An IXP team conducts a specialized technical review
 (Chapter 15) after a software increment is delivered. Called a retrospective,
 the review examines “issues, events, and lessons-learned” [Ker05] across a
 software increment and/or the entire software release. The intent is to
 improve the IXP process.
 Continuous learning. Because learning is a vital part of continuous
 process improvement, members of the XP team are encouraged (and possi
bly, incented) to learn new methods and techniques that can lead to a higher
quality product.
 In addition to the six new practices discussed, IXP modifies a number of existing
 XP practices. Story-driven development (SDD) insists that stories for acceptance tests
 be written before a single line of code is generated. Domain-driven design (DDD) is
 an improvement on the “system metaphor” concept used in XP. DDD [Eva03] sug
gests the evolutionary creation of a domain model that “accurately represents how
 domain experts think about their subject” [Ker05]. Pairing extends the XP pair
programming concept to include managers and other stakeholders. The intent is to
 improve knowledge sharing among XP team members who may not be directly in
volved in technical development. Iterative usability discourages front-loaded inter
face design in favor of usability design that evolves as software increments are
 delivered and users’ interaction with the software is studied.
 IXP makes smaller modifications to other XP practices and redefines certain roles
 and responsibilities to make them more amenable to significant projects for large
 organizations. For further discussion of IXP, visit http://industrialxp.org.
 3.4.4 The XP Debate
 All new process models and methods spur worthwhile discussion and in some in
stances heated debate. Extreme Programming has done both. In an interesting book
 that examines the efficacy of XP, Stephens and Rosenberg [Ste03] argue that many
 XP practices are worthwhile, but others have been overhyped, and a few are prob
lematic. The authors suggest that the codependent nature of XP practices are both
 its strength and its weakness. Because many organizations adopt only a subset of XP
 practices, they weaken the efficacy of the entire process. Proponents counter that
 XP is continuously evolving and that many of the issues raised by critics have been
79
 CHAPTER 3 AGILE DEVELOPMENT
 addressed as XP practice matures. Among the issues that continue to trouble some
 critics of XP are:10
 ?
 What are
 some of the
 issues that lead to
 an XP debate?
 • Requirements volatility. Because the customer is an active member of the XP
 team, changes to requirements are requested informally. As a consequence,
 the scope of the project can change and earlier work may have to be
 modified to accommodate current needs. Proponents argue that this happens
 regardless of the process that is applied and that XP provides mechanisms for
 controlling scope creep.
 • Conflicting customer needs. Many projects have multiple customers, each with
 his own set of needs. In XP, the team itself is tasked with assimilating the
 needs of different customers, a job that may be beyond their scope of
 authority.
 • Requirements are expressed informally. User stories and acceptance tests are
 the only explicit manifestation of requirements in XP. Critics argue that a
 more formal model or specification is often needed to ensure that omissions,
 inconsistencies, and errors are uncovered before the system is built. Propo
nents counter that the changing nature of requirements makes such models
 and specification obsolete almost as soon as they are developed.
 • Lack of formal design. XP deemphasizes the need for architectural design and
 in many instances, suggests that design of all kinds should be relatively
 informal. Critics argue that when complex systems are built, design must be
 emphasized to ensure that the overall structure of the software will exhibit
 quality and maintainability. XP proponents suggest that the incremental
 nature of the XP process limits complexity (simplicity is a core value) and
 therefore reduces the need for extensive design.
 You should note that every software process has flaws and that many software or
ganizations have used XP successfully. The key is to recognize where a process may
 have weaknesses and to adapt it to the specific needs of your organization.
 SAFEHOME
 Considering Agile Software Development
 The scene: Doug Miller’s office.
 The Players: Doug Miller, software engineering
 manager; Jamie Lazar, software team member; Vinod
 Raman, software team member.
 The conversation:
 (A knock on the door, Jamie and Vinod enter Doug’s office)
 Jamie: Doug, you got a minute?
 10 For a detailed look at some thoughtful criticism that has been leveled at XP, visit
 www.softwarereality.com/ExtremeProgramming.jsp.
3.5 OTHERAGILEPROCESSMODELS
 The history of software engineering is littered with dozens of obsolete process
 descriptions and methodologies, modeling methods and notations, tools, and
 technology. Each flared in notoriety and was then eclipsed by something new and
 (purportedly) better. With the introduction of a wide array of agile process models—
 each contending for acceptance within the software development community—the
 agile movement is following the same historical path.11
 As I noted in the last section, the most widely used of all agile process models
 isExtreme Programming (XP). But many other agile process models have been
 proposed and are in use across the industry. Among the most common are:
 •Adaptive Software Development (ASD)
 •Scrum
 •Dynamic Systems Development Method (DSDM)
 80 PART ONE THE SOFTWARE PROCESS
 Doug: Sure Jamie, what’s up?
 Jamie:We’ve been thinking about our process
 discussion yesterday . . . you know, what process we’re
 going to choose for this new SafeHomeproject.
 Doug:And?
 Vinod: I was talking to a friend at another company,
 and he was telling me about Extreme Programming. It’s
 an agile process model . . . heard of it?
 Doug: Yeah, some good, some bad.
 Jamie:Well, it sounds pretty good to us. Lets you
 develop software really fast, uses something called pair
 programming to do real-time quality checks . . . it’s pretty
 cool, I think.
 Doug: It does have a lot of really good ideas. I like the
 pair-programming concept, for instance, and the idea
 that stakeholders should be part of the team.
 Jamie:Huh? You mean that marketing will work on the
 project team with us?
 Doug (nodding): They’re a stakeholder, aren’t they?
 Jamie: Jeez . . . they’ll be requesting changes every five
 minutes.
 Vinod:Not necessarily. My friend said that there are
 ways to “embrace” changes during an XP project.
 Doug: So you guys think we should use XP?
 Jamie: It’s definitely worth considering.
 Doug: I agree. And even if we choose an incremental
 model as our approach, there’s no reason why we can’t
 incorporate much of what XP has to offer.
 Vinod:Doug, before you said “some good, some bad.”
 What was the “bad”?
 Doug: The thing I don’t like is the way XP downplays
 analysis and design . . . sort of says that writing code is
 where the action is . . . 
(The team members look at one another and smile.)
 Doug: So you agree with the XP approach?
 Jamie (speaking for both):Writing code is what
 we do, Boss!
 Doug (laughing): True, but I’d like to see you spend a
 little less time coding and then recoding and a little more
 time analyzing what has to be done and designing a
 solution that works.
 Vinod:Maybe we can have it both ways, agility with a
 little discipline.
 Doug: I think we can, Vinod. In fact, I’m sure of it.
 uote:
 “Our profession
 goes through
 methodologies like
 a 14-year-old goes
 through clothing.”
 Stephen
 Hawrysh and
 JimRuprecht
 11This is not a bad thing. Before one or more models or methods are accepted as a de facto standard,
 all must contend for the hearts and minds of software engineers. The “winners” evolve into best
 practice, while the “losers” either disappear or merge with the winning models.
81
 CHAPTER 3 AGILE DEVELOPMENT
 • Crystal
 • Feature Drive Development (FDD)
 • Lean Software Development (LSD)
 • Agile Modeling (AM)
 • Agile Unified Process (AUP)
 In the sections that follow, I present a very brief overview of each of these agile
 process models. It is important to note that all agile process models conform (to a
 greater or lesser degree) to the Manifesto for Agile Software Development and the prin
ciples noted in Section 3.3.1. For additional detail, refer to the references noted in
 each subsection or for a survey, examine the “agile software development” entry
 in Wikipedia.12
 3.5.1 Adaptive Software Development (ASD)
 WebRef
 Useful resources for
 ASD can be found at
 www.adaptivesd
 .com.
 Adaptive Software Development (ASD) has been proposed by Jim Highsmith [Hig00] as
 a technique for building complex software and systems. The philosophical under
pinnings of ASD focus on human collaboration and team self-organization.
 Highsmith argues that an agile, adaptive development approach based on collab
oration is “as much a source of order in our complex interactions as discipline and
 engineering.” He defines an ASD “life cycle” (Figure 3.3) that incorporates three
 phases, speculation, collaboration, and learning.
 FIGURE 3.3
 Adaptive
 software
 development
 adaptive cycle planning
 mission statement
 project constraints
 basic requirements
 time-boxed release plan
 Release
 Requirements gathering
 JAD
 mini-specs
 speculation
 software increment
 adjustments for subsequent cycles
 collaboration
 components implemented/tested
 focus groups for feedback
 formal technical reviews
 learning
 postmortems
 12 See http://en.wikipedia.org/wiki/Agile_software_development#Agile_methods.
82
 PART ONE THE SOFTWARE PROCESS
 Effective collaboration
 with your customer will
 only occur if you
 jettison any “us and
 them” attitudes.
 ASD emphasizes
 learning as a key
 element in achieving 
a “self-organizing”
 team.
 WebRef
 Useful Scrum
 information and
 resources can be found
 at www
 .controlchaos.com.
 During speculation, the project is initiated and adaptive cycle planning is con
ducted. Adaptive cycle planning uses project initiation information—the customer’s
 mission statement, project constraints (e.g., delivery dates or user descriptions), and
 basic requirements—to define the set of release cycles (software increments) that
 will be required for the project.
 No matter how complete and farsighted the cycle plan, it will invariably change.
 Based on information obtained at the completion of the first cycle, the plan is re
viewed and adjusted so that planned work better fits the reality in which an ASD
 team is working.
 Motivated people use collaboration in a way that multiplies their talent and cre
ative output beyond their absolute numbers. This approach is a recurring theme in
 all agile methods. But collaboration is not easy. It encompasses communication and
 teamwork, but it also emphasizes individualism, because individual creativity plays
 an important role in collaborative thinking. It is, above all, a matter of trust. People
 working together must trust one another to (1) criticize without animosity, (2) assist
 without resentment, (3) work as hard as or harder than they do, (4) have the skill set
 to contribute to the work at hand, and (5) communicate problems or concerns in a
 way that leads to effective action.
 As members of an ASD team begin to develop the components that are part of an
 adaptive cycle, the emphasis is on “learning” as much as it is on progress toward
 a completed cycle. In fact, Highsmith [Hig00] argues that software developers often
 overestimate their own understanding (of the technology, the process, and the proj
ect) and that learning will help them to improve their level of real understanding.
 ASD teams learn in three ways: focus groups (Chapter 5), technical reviews (Chap
ter 14), and project postmortems.
 The ASD philosophy has merit regardless of the process model that is used. ASD’s
 overall emphasis on the dynamics of self-organizing teams, interpersonal collabo
ration, and individual and team learning yield software project teams that have a
 much higher likelihood of success.
 3.5.2 Scrum
 Scrum (the name is derived from an activity that occurs during a rugby match13) is
 an agile software development method that was conceived by Jeff Sutherland and his
 development team in the early 1990s. In recent years, further development on the
 Scrum methods has been performed by Schwaber and Beedle [Sch01a].
 Scrum principles are consistent with the agile manifesto and are used to guide
 development activities within a process that incorporates the following framework
 activities: requirements, analysis, design, evolution, and delivery. Within each
 13 A group of players forms around the ball and the teammates work together (sometimes violently!)
 to move the ball downfield.
every 24
 hours
 30 days
 Scrum: 15 minute daily meeting.
 Team members respond to basics:
 1) What did you do since last Scrum
 meeting?
 2) Do you have any obstacles?
 3) What will you do before next
 meeting?
 Sprint Backlog:
 Feature(s)
 assigned
 to sprint
 Product Backlog:
 Prioritized product features desired by the customer
 Backlog
 items
 expanded
 by team
 New functionality
 is demonstrated
 at end of sprint
 framework activity, work tasks occur within a process pattern (discussed in the fol
lowing paragraph) called a sprint.The work conducted within a sprint (the number
 of sprints required for each framework activity will vary depending on product com
plexity and size) is adapted to the problem at hand and is defined and often modified
 in real time by the Scrum team. The overall flow of the Scrum process is illustrated
 in Figure 3.4.
 Scrum emphasizes the use of a set of software process patterns [Noy02] that have
 proven effective for projects with tight timelines, changing requirements, and business
 criticality. Each of these process patterns defines a set of development actions:
 Backlog—a prioritized list of project requirements or features that provide busi
ness value for the customer. Items can be added to the backlog at any time (this is
 how changes are introduced). The product manager assesses the backlog and
 updates priorities as required.
 Sprints—consist of work units that are required to achieve a requirement de
fined in the backlog that must be fit into a predefined time-box14(typically 30 days).
 CHAPTER 3 AGILE DEVELOPMENT 83
 14A time-boxis a project management term (see Part 4 of this book) that indicates a period of time
 that has been allocated to accomplish some task.
 FIGURE3.4
 Scrum process
 flow
 Scrum incorporates a
 set of process patterns
 that emphasize project
 priorities,
 compartmentalized
 work units,
 communication, and
 frequent customer
 feedback.
84
 PART ONE THE SOFTWARE PROCESS
 Changes (e.g., backlog work items) are not introduced during the sprint. Hence, the
 sprint allows team members to work in a short-term, but stable environment.
 Scrum meetings—are short (typically 15 minutes) meetings held daily by the Scrum
 team. Three key questions are asked and answered by all team members [Noy02]:
 • What did you do since the last team meeting?
 • What obstacles are you encountering?
 • What do you plan to accomplish by the next team meeting?
 A team leader, called a Scrum master, leads the meeting and assesses the responses
 from each person. The Scrum meeting helps the team to uncover potential problems
 as early as possible. Also, these daily meetings lead to “knowledge socialization”
 [Bee99] and thereby promote a self-organizing team structure.
 Demos—deliver the software increment to the customer so that functionality that
 has been implemented can be demonstrated and evaluated by the customer. It is im
portant to note that the demo may not contain all planned functionality, but rather
 those functions that can be delivered within the time-box that was established.
 Beedle and his colleagues [Bee99] present a comprehensive discussion of these pat
terns in which they state: “Scrum assumes up-front the existence of chaos. . . . ” The
 Scrum process patterns enable a software team to work successfully in a world
 where the elimination of uncertainty is impossible.
 3.5.3 Dynamic Systems Development Method (DSDM)
 WebRef
 Useful resources for
 DSSD can be found at
 www.dsdm.org.
 The Dynamic Systems Development Method (DSDM) [Sta97] is an agile software devel
opment approach that “provides a framework for building and maintaining systems
 which meet tight time constraints through the use of incremental prototyping in a con
trolled project environment” [CCS02]. The DSDM philosophy is borrowed from a mod
ified version of the Pareto principle—80 percent of an application can be delivered in
 20 percent of the time it would take to deliver the complete (100 percent) application.
 DSDM is an iterative software process in which each iteration follows the 80 per
cent rule. That is, only enough work is required for each increment to facilitate
 movement to the next increment. The remaining detail can be completed later when
 more business requirements are known or changes have been requested and
 accommodated.
 The DSDM Consortium (www.dsdm.org) is a worldwide group of member com
panies that collectively take on the role of “keeper” of the method. The consortium
 has defined an agile process model, called the DSDM life cycle that defines three dif
ferent iterative cycles, preceded by two additional life cycle activities:
 Feasibility study—establishes the basic business requirements and constraints
 associated with the application to be built and then assesses whether the applica
tion is a viable candidate for the DSDM process.
85
 CHAPTER 3 AGILE DEVELOPMENT
 DSDM is a process
 framework that can
 adopt the tactics of
 another agile approach
 such as XP.
 Crystal is a family of
 process models with
 the same “genetic
 code” but different
 methods for adapting
 to project
 characteristics.
 Business study—establishes the functional and information requirements that
 will allow the application to provide business value; also, defines the basic
 application architecture and identifies the maintainability requirements for the
 application.
 Functional model iteration—produces a set of incremental prototypes that
 demonstrate functionality for the customer. (Note: All DSDM prototypes are in
tended to evolve into the deliverable application.) The intent during this iterative
 cycle is to gather additional requirements by eliciting feedback from users as they
 exercise the prototype.
 Design and build iteration—revisits prototypes built during functional model
 iteration to ensure that each has been engineered in a manner that will enable it to
 provide operational business value for end users. In some cases, functional model
 iteration and design and build iteration occur concurrently.
 Implementation—places the latest software increment (an “operationalized” pro
totype) into the operational environment. It should be noted that (1) the increment
 may not be 100 percent complete or (2) changes may be requested as the incre
ment is put into place. In either case, DSDM development work continues by
 returning to the functional model iteration activity.
 DSDM can be combined with XP (Section 3.4) to provide a combination approach
 that defines a solid process model (the DSDM life cycle) with the nuts and bolts prac
tices (XP) that are required to build software increments. In addition, the ASD con
cepts of collaboration and self-organizing teams can be adapted to a combined
 process model.
 3.5.4 Crystal
 Alistair Cockburn [Coc05] and Jim Highsmith [Hig02b] created the Crystal family of
 agile methods15 in order to achieve a software development approach that puts a
 premium on “maneuverability” during what Cockburn characterizes as “a resource
limited, cooperative game of invention and communication, with a primary goal of
 delivering useful, working software and a secondary goal of setting up for the next
 game” [Coc02].
 To achieve maneuverability, Cockburn and Highsmith have defined a set of
 methodologies, each with core elements that are common to all, and roles, process
 patterns, work products, and practice that are unique to each. The Crystal family is
 actually a set of example agile processes that have been proven effective for differ
ent types of projects. The intent is to allow agile teams to select the member of the
 crystal family that is most appropriate for their project and environment.
 15 The name “crystal” is derived from the characteristics of geological crystals, each with its own
 color, shape, and hardness.
86
 PART ONE THE SOFTWARE PROCESS
 3.5.5 Feature Driven Development (FDD)
 WebRef
 A wide variety of
 articles and
 presentations on FDD
 can be found at:
 www.featuredrive
 ndevelopment
 .com/.
 Feature Driven Development (FDD) was originally conceived by Peter Coad and his
 colleagues [Coa99] as a practical process model for object-oriented software engi
neering. Stephen Palmer and John Felsing [Pal02] have extended and improved
 Coad’s work, describing an adaptive, agile process that can be applied to moderately
 sized and larger software projects.
 Like other agile approaches, FDD adopts a philosophy that (1) emphasizes col
laboration among people on an FDD team; (2) manages problem and project
 complexity using feature-based decomposition followed by the integration of
 software increments, and (3) communication of technical detail using verbal,
 graphical, and text-based means. FDD emphasizes software quality assurance
 activities by encouraging an incremental development strategy, the use of design
 and code inspections, the application of software quality assurance audits (Chap
ter 16), the collection of metrics, and the use of patterns (for analysis, design, and
 construction).
 In the context of FDD, a feature “is a client-valued function that can be imple
mented in two weeks or less” [Coa99]. The emphasis on the definition of features
 provides the following benefits:
 • Because features are small blocks of deliverable functionality, users can
 describe them more easily; understand how they relate to one another more
 readily; and better review them for ambiguity, error, or omissions.
 • Features can be organized into a hierarchical business-related grouping.
 • Since a feature is the FDD deliverable software increment, the team develops
 operational features every two weeks.
 • Because features are small, their design and code representations are easier
 to inspect effectively.
 • Project planning, scheduling, and tracking are driven by the feature
 hierarchy, rather than an arbitrarily adopted software engineering 
task set.
 Coad and his colleagues [Coa99] suggest the following template for defining a
 feature:
 <action> the <result> <by for of to> a(n) <object>
 where an <object> is “a person, place, or thing (including roles, moments in time or
 intervals of time, or catalog-entry-like descriptions).” Examples of features for an 
e-commerce application might be:
 Add the product to shopping cart
 Display the technical-specifications of the product
 Store the shipping-information for the customer
87
 CHAPTER 3 AGILE DEVELOPMENT
 FIGURE 3.5
 Feature Driven
 Development
 [Coa99] (with
 permission)
 Develop
 an
 Overall
 Model
 Build a
 Features
 List
 Plan
 By
 Feature
 Design
 By
 Feature
 (more shape
 than content)
 A list of features
 grouped into sets
 and subject areas
 A development plan
 Class owners
 Feature Set Owners
 A design
 package
 (sequences)
 Build
 By
 Feature
 Completed
 client-value
 function
 A feature set groups related features into business-related categories and is defined
 [Coa99] as:
 <action><-ing> a(n) <object>
 For example: Making a product sale is a feature set that would encompass the fea
tures noted earlier and others.
 The FDD approach defines five “collaborating” [Coa99] framework activities (in
 FDD these are called “processes”) as shown in Figure 3.5.
 FDD provides greater emphasis on project management guidelines and tech
niques than many other agile methods. As projects grow in size and complexity,
 ad hoc project management is often inadequate. It is essential for developers, their
 managers, and other stakeholders to understand project status—what accomplish
ments have been made and problems have been encountered. If deadline pressure
 is significant, it is critical to determine if software increments (features) are properly
 scheduled. To accomplish this, FDD defines six milestones during the design and
 implementation of a feature: “design walkthrough, design, design inspection, code,
 code inspection, promote to build” [Coa99].
 3.5.6 Lean Software Development (LSD)
 Lean Software Development (LSD) has adapted the principles of lean manufacturing
 to the world of software engineering. The lean principles that inspire the LSD process
 can be summarized ([Pop03], [Pop06a]) as eliminate waste, build quality in, create
 knowledge, defer commitment, deliver fast, respect people, and optimize the whole.
 Each of these principles can be adapted to the software process. For example,
 eliminate waste within the context of an agile software project can be interpreted
 to mean [Das05]: (1) adding no extraneous features or functions, (2) assessing the
 cost and schedule impact of any newly requested requirement, (3) removing any
 superfluous process steps, (4) establishing mechanisms to improve the way team
 members find information, (5) ensuring the testing finds as many errors as possible,
88
 PART ONE THE SOFTWARE PROCESS
 (6) reducing the time required to request and get a decision that affects the software
 or the process that is applied to create it, and (7) streamlining the manner in which
 information is transmitted to all stakeholders involved in the process.
 For a detailed discussion of LSD and pragmatic guidelines for implementing the
 process, you should examine [Pop06a] and [Pop06b].
 3.5.7 Agile Modeling (AM)
 WebRef
 Comprehensive
 information on agile
 modeling can be found
 at: www
 .agilemodeling.com.
 uote:
 “I was in the drug
 store the other day
 trying to get a cold
 medication . . . not
 easy. There’s an
 entire wall of
 products you need.
 You stand there
 going, Well, this
 one is quick acting
 but this is long
 lasting. . . . Which
 is more important,
 the present or the
 future?”
 Jerry Seinfeld
 There are many situations in which software engineers must build large, business
critical systems. The scope and complexity of such systems must be modeled so that
 (1) all constituencies can better understand what needs to be accomplished, (2) the
 problem can be partitioned effectively among the people who must solve it, and
 (3) quality can be assessed as the system is being engineered and built.
 Over the past 30 years, a wide variety of software engineering modeling methods
 and notation have been proposed for analysis and design (both architectural and
 component-level). These methods have merit, but they have proven to be difficult
 to apply and challenging to sustain (over many projects). Part of the problem is the
 “weight” of these modeling methods. By this I mean the volume of notation required,
 the degree of formalism suggested, the sheer size of the models for large projects,
 and the difficulty in maintaining the model(s) as changes occur. Yet analysis and de
sign modeling have substantial benefit for large projects—if for no other reason than
 to make these projects intellectually manageable. Is there an agile approach to soft
ware engineering modeling that might provide an alternative?
 At “The Official Agile Modeling Site,” Scott Ambler [Amb02a] describes agile mod
eling (AM) in the following manner:
 Agile Modeling (AM) is a practice-based methodology for effective modeling and documen
tation of software-based systems. Simply put, Agile Modeling (AM) is a collection of values,
 principles, and practices for modeling software that can be applied on a software develop
ment project in an effective and light-weight manner. Agile models are more effective than
 traditional models because they are just barely good, they don’t have to be perfect.
 Agile modeling adopts all of the values that are consistent with the agile manifesto.
 The agile modeling philosophy recognizes that an agile team must have the courage
 to make decisions that may cause it to reject a design and refactor. The team must
 also have the humility to recognize that technologists do not have all the answers and
 that business experts and other stakeholders should be respected and embraced.
 Although AM suggests a wide array of “core” and “supplementary” modeling prin
ciples, those that make AM unique are [Amb02a]:
 Model with a purpose. A developer who uses AM should have a specific
 goal (e.g., to communicate information to the customer or to help better un
derstand some aspect of the software) in mind before creating the model.
 Once the goal for the model is identified, the type of notation to be used and
 level of detail required will be more obvious.
89
 CHAPTER 3 AGILE DEVELOPMENT
 Use multiple models. There are many different models and notations that
 can be used to describe software. Only a small subset is essential for most
 projects. AM suggests that to provide needed insight, each model should
 present a different aspect of the system and only those models that provide
 value to their intended audience should be used.
 “Traveling light” is an
 appropriate philosophy
 for all software engi
neering work. Build
 only those models that
 provide value … no
 more, no less.
 Travel light. As software engineering work proceeds, keep only those mod
els that will provide long-term value and jettison the rest. Every work product
 that is kept must be maintained as changes occur. This represents work that
 slows the team down. Ambler [Amb02a] notes that “Every time you decide to
 keep a model you trade-off agility for the convenience of having that informa
tion available to your team in an abstract manner (hence potentially enhanc
ing communication within your team as well as with project stakeholders).”
 Content is more important than representation. Modeling should im
part information to its intended audience. A syntactically perfect model that
 imparts little useful content is not as valuable as a model with flawed nota
tion that nevertheless provides valuable content for its audience.
 Know the models and the tools you use to create them. Understand
 the strengths and weaknesses of each model and the tools that are used to
 create it.
 Adapt locally. The modeling approach should be adapted to the needs of
 the agile team.
 A major segment of the software engineering community has adopted the Unified
 Modeling Language (UML)16 as the preferred method for representing analysis and
 design models. The Unified Process (Chapter 2) has been developed to provide a
 framework for the application of UML. Scott Ambler [Amb06] has developed a sim
plified version of the UP that integrates his agile modeling philosophy.
 3.5.8 Agile Unified Process (AUP)
 The Agile Unified Process (AUP) adopts a “serial in the large” and “iterative in the
 small” [Amb06] philosophy for building computer-based systems. By adopting the
 classic UP phased activities—inception, elaboration, construction, and transition—AUP
 provides a serial overlay (i.e., a linear sequence of software engineering activities)
 that enables a team to visualize the overall process flow for a software project. How
ever, within each of the activities, the team iterates to achieve agility and to deliver
 meaningful software increments to end users as rapidly as possible. Each AUP iter
ation addresses the following activities [Amb06]: 
• Modeling. UML representations of the business and problem domains are
 created. However, to stay agile, these models should be “just barely good
 enough” [Amb06] to allow the team to proceed.
 16 A brief tutorial on UML is presented in Appendix 1.
90
 PART ONE THE SOFTWARE PROCESS
 • Implementation. Models are translated into source code.
 • Testing. Like XP, the team designs and executes a series of tests to uncover
 errors and ensure that the source code meets its requirements.
 • Deployment. Like the generic process activity discussed in Chapters 1 and 2,
 deployment in this context focuses on the delivery of a software increment
 and the acquisition of feedback from end users.
 • Configuration and project management. In the context of AUP, configuration
 management (Chapter 22) addresses change management, risk manage
ment, and the control of any persistent work products17 that are produced by
 the team. Project management tracks and controls the progress of the team
 and coordinates team activities.
 • Environment management. Environment management coordinates a process
 infrastructure that includes standards, tools, and other support technology
 available to the team.
 Although the AUP has historical and technical connections to the Unified Modeling
 Language, it is important to note that UML modeling can be using in conjunction
 with any of the agile process models described in Section 3.5.
 SOFTWARE TOOLS
 Agile Development
 Objective: The objective of agile development
 tools is to assist in one or more aspects of agile
 development with an emphasis on facilitating the rapid
 generation of operational software. These tools can also
 be used when prescriptive process models (Chapter 2) are
 applied.
 Mechanics: Tool mechanics vary. In general, agile tool
 sets encompass automated support for project planning,
 use case development and requirements gathering, rapid
 design, code generation, and testing.
 Representative Tools:18
 Note: Because agile development is a hot topic, most
 software tools vendors purport to sell tools that support 
the agile approach. The tools noted here have
 characteristics that make them particularly useful for
 agile projects.
 OnTime, developed by Axosoft (www.axosoft.com),
 provides agile process management support for
 various technical activities within the process.
 Ideogramic UML, developed by Ideogramic
 (www.ideogramic.com) is a UML tool set
 specifically developed for use within an agile 
process.
 Together Tool Set, distributed by Borland
 (www.borland.com), provides a tools suite that
 supports many technical activities within XP and other
 agile processes.
 17 A persistent work product is a model or document or test case produced by the team that will be kept
 for an indeterminate period of time. It will not be discarded once the software increment is
 delivered.
 18 Tools noted here do not represent an endorsement, but rather a sampling of tools in this category.
 In most cases, tool names are trademarked by their respective developers.
91
 CHAPTER 3 AGILE DEVELOPMENT
 3.6 A TOOL SET FOR THE AGILE PROCESS
 The “tool set” that
 supports agile
 processes focuses
 more on people issues
 than it does on
 technology issues.
 Some proponents of the agile philosophy argue that automated software tools (e.g.,
 design tools) should be viewed as a minor supplement to the team’s activities, and
 not at all pivotal to the success of the team. However, Alistair Cockburn [Coc04] sug
gests that tools can have a benefit and that “agile teams stress using tools that per
mit the rapid flow of understanding. Some of those tools are social, starting even at
 the hiring stage. Some tools are technological, helping distributed teams simulate
 being physically present. Many tools are physical, allowing people to manipulate
 them in workshops.”
 Because acquiring the right people (hiring), team collaboration, stakeholder com
munication, and indirect management are key elements in virtually all agile process
 models, Cockburn argues that “tools” that address these issues are critical success
 factors for agility. For example, a hiring “tool” might be the requirement to have a
 prospective team member spend a few hours pair programming with an existing
 member of the team. The “fit” can be assessed immediately.
 Collaborative and communication “tools” are generally low tech and incorporate
 any mechanism (“physical proximity, whiteboards, poster sheets, index cards, and
 sticky notes” [Coc04]) that provides information and coordination among agile de
velopers. Active communication is achieved via the team dynamics (e.g., pair pro
gramming), while passive communication is achieved by “information radiators”
 (e.g., a flat panel display that presents the overall status of different components of
 an increment). Project management tools deemphasize the Gantt chart and replace
 it with earned value charts or “graphs of tests created versus passed . . . other agile
 tools are used to optimize the environment in which the agile team works (e.g., more
 efficient meeting areas), improve the team culture by nurturing social interactions
 (e.g., collocated teams), physical devices (e.g., electronic whiteboards), and process
 enhancement (e.g., pair programming or time-boxing)” [Coc04].
 Are any of these things really tools? They are, if they facilitate the work performed
 by an agile team member and enhance the quality of the end product.
 3.7 SUMMARY
 In a modern economy, market conditions change rapidly, customer and end-user
 needs evolve, and new competitive threats emerge without warning. Practitioners
 must approach software engineering in a manner that allows them to remain agile—
 to define maneuverable, adaptive, lean processes that can accommodate the needs
 of modern business.
 An agile philosophy for software engineering stresses four key issues: the impor
tance of self-organizing teams that have control over the work they perform, com
munication and collaboration between team members and between practitioners
 and their customers, a recognition that change represents an opportunity, and
92
 PART ONE THE SOFTWARE PROCESS
 an emphasis on rapid delivery of software that satisfies the customer. Agile process
 models have been designed to address each of these issues.
 Extreme programming (XP) is the most widely used agile process. Organized as
 four framework activities—planning, design, coding, and testing—XP suggests a
 number of innovative and powerful techniques that allow an agile team to create
 frequent software releases that deliver features and functionality that have been de
scribed and then prioritized by stakeholders.
 Other agile process models also stress human collaboration and team self
organization, but define their own framework activities and select different points of
 emphasis. For example, ASD uses an iterative process that incorporates adaptive
 cycle planning, relatively rigorous requirement gathering methods, and an iterative
 development cycle that incorporates customer focus groups and formal technical re
views as real-time feedback mechanisms. Scrum emphasizes the use of a set of soft
ware process patterns that have proven effective for projects with tight time lines,
 changing requirements, and business criticality. Each process pattern defines a set
 of development tasks and allows the Scrum team to construct a process that is
 adapted to the needs of the project. The Dynamic Systems Development Method
 (DSDM) advocates the use of time-box scheduling and suggests that only enough
 work is required for each software increment to facilitate movement to the next
 increment. Crystal is a family of agile process models that can be adopted to the spe
cific characteristics of a project.
 Feature Driven Development (FDD) is somewhat more “formal” than other agile
 methods, but still maintains agility by focusing the project team on the development
 of features—a client-valued function that can be implemented in two weeks or less.
 Lean Software Development (LSD) has adapted the principles of lean manufacturing
 to the world of software engineering. Agile modeling (AM) suggests that modeling is
 essential for all systems, but that the complexity, type, and size of the model must be
 tuned to the software to be built. The Agile Unified Process (AUP) adopts a “serial in
 the large” and “iterative in the small” philosophy for building software.
 PROBLEMS AND POINTS TO PONDER
 3.1. Reread “The Manifesto for Agile Software Development” at the beginning of this chapter.
 Can you think of a situation in which one or more of the four “values” could get a software team
 into trouble?
 3.2. Describe agility (for software projects) in your own words.
 3.3. Why does an iterative process make it easier to manage change? Is every agile process dis
cussed in this chapter iterative? Is it possible to complete a project in just one iteration and still
 be agile? Explain your answers.
 3.4. Could each of the agile processes be described using the generic framework activities
 noted in Chapter 2? Build a table that maps the generic activities into the activities defined for
 each agile process.
 3.5. Try to come up with one more “agility principle” that would help a software engineering
 team become even more maneuverable.
93
 CHAPTER 3 AGILE DEVELOPMENT
 3.6. Select one agility principle noted in Section 3.3.1 and try to determine whether each of the
 process models presented in this chapter exhibits the principle. [Note: I have presented an
 overview of these process models only, so it may not be possible to determine whether a prin
ciple has been addressed by one or more of the models, unless you do additional research
 (which is not required for this problem).]
 3.7. Why do requirements change so much? After all, don’t people know what they want?
 3.8. Most agile process models recommend face-to-face communication. Yet today, members
 of a software team and their customers may be geographically separated from one another. Do
 you think this implies that geographical separation is something to avoid? Can you think of ways
 to overcome this problem?
 3.9. Write an XP user story that describes the “favorite places” or “bookmarks” feature avail
able on most Web browsers.
 3.10. What is a spike solution in XP?
 3.11. Describe the XP concepts of refactoring and pair programming in your own words.
 3.12. Do a bit more reading and describe what a time-box is. How does this assist an ASD team
 in delivering software increments in a short time period?
 3.13. Do the 80 percent rule in DSDM and the time-boxing approach defined for ASD achieve
 the same result?
 3.14. Using the process pattern template presented in Chapter 2, develop a process pattern for
 any one of the Scrum patterns presented in Section 3.5.2.
 3.15. Why is Crystal called a family of agile methods?
 3.16. Using the FDD feature template described in Section 3.5.5, define a feature set for a Web
 browser. Now develop a set of features for the feature set.
 3.17. Visit the Official Agile Modeling Site and make a complete list of all core and supple
mentary AM principles.
 3.18. The tool set proposed in Section 3.6 supports many of the “soft” aspects of agile meth
ods. Since communication is so important, recommend an actual tool set that might be used to
 enhance communication among stakeholders on an agile team.
 FURTHER READINGS AND INFORMATION SOURCES
 The overall philosophy and underlying principles of agile software development are considered
 in depth in many of the books referenced in the body of this chapter. In addition, books by Shaw
 and Warden (The Art of Agile Development, O’Reilly Media, Inc., 2008), Hunt (Agile Software Con
struction, Springer, 2005), and Carmichael and Haywood (Better Software Faster, Prentice-Hall,
 2002) present useful discussions of the subject. Aguanno (Managing Agile Projects, Multi
Media Publications, 2005), Highsmith (Agile Project Management: Creating Innovative Products,
 Addison-Wesley, 2004), and Larman (Agile and Iterative Development: A Manager’s Guide,
 Addison-Wesley, 2003) present a management overview and consider project management
 issues. Highsmith (Agile Software Development Ecosystems, Addison-Wesley, 2002) presents a
 survey of agile principles, processes, and practices. A worthwhile discussion of the delicate bal
ance between agility and discipline is presented by Booch and his colleagues (Balancing Agility
 and Discipline, Addison-Wesley, 2004).
 Martin (Clean Code: A Handbook of Agile Software Craftsmanship, Prentice-Hall, 2009) pres
ents the principles, patterns, and practices required to develop “clean code” in an agile software
 engineering environment. Leffingwell (Scaling Software Agility: Best Practices for Large Enter
prises, Addison-Wesley, 2007) discusses strategies for scaling up agile practices for large proj
ects. Lippert and Rook (Refactoring in Large Software Projects: Performing Complex Restructurings
 Successfully, Wiley, 2006) discuss the use of refactoring when applied in large, complex systems.
94
 PART ONE THE SOFTWARE PROCESS
 Stamelos and Sfetsos (Agile Software Development Quality Assurance, IGI Global, 2007) discuss
 SQA techniques that conform to the agile philosophy.
 Dozens of books have been written about Extreme Programming over the past decade. Beck
 (Extreme Programming Explained: Embrace Change, 2d ed., Addison-Wesley, 2004) remains the
 definitive treatment of the subject. In addition, Jeffries and his colleagues (Extreme Programming
 Installed, Addison-Wesley, 2000), Succi and Marchesi (Extreme Programming Examined,
 Addison-Wesley, 2001), Newkirk and Martin (Extreme Programming in Practice, Addison-Wesley,
 2001), and Auer and his colleagues (Extreme Programming Applied: Play to Win, Addison-Wesley,
 2001) provide a nuts-and-bolts discussion of XP along with guidance on how best to apply it.
 McBreen (Questioning Extreme Programming, Addison-Wesley, 2003) takes a critical look at XP,
 defining when and where it is appropriate. An in-depth consideration of pair programming is
 presented by McBreen (Pair Programming Illuminated, Addison-Wesley, 2003).
 ASD is addressed in depth by Highsmith [Hig00]. Schwaber (The Enterprise and Scrum,
 Microsoft Press, 2007) discusses the use of Scrum for projects that have a major business
 impact. The nuts and bolts of Scrum are discussed by Schwaber and Beedle (Agile Software
 Development with SCRUM, Prentice-Hall, 2001). Worthwhile treatments of DSDM have been
 written by the DSDM Consortium (DSDM: Business Focused Development, 2d ed., Pearson Edu
cation, 2003) and Stapleton (DSDM: The Method in Practice, Addison-Wesley, 1997). Cockburn
 (Crystal Clear, Addison-Wesley, 2005) presents an excellent overview of the Crystal family of
 processes. Palmer and Felsing [Pal02] present a detailed treatment of FDD. Carmichael and
 Haywood (Better Software Faster, Prentice-Hall, 2002) provides another useful treatment of FDD
 that includes a step-by-step journey through the mechanics of the process. Poppendieck and 
Poppendieck (Lean Development: An Agile Toolkit for Software Development Managers, Addison
Wesley, 2003) provide guidelines for managing and controlling agile projects. Ambler and
 Jeffries (Agile Modeling, Wiley, 2002) discuss AM in some depth.
 A wide variety of information sources on agile software development are available on the
 Internet. An up-to-date list of World Wide Web references that are relevant to the agile process
 can be found at the SEPA website: www.mhhe.com/engcs/compsci/pressman/
 professional/olc/ser.htm.
In 2001, Kent Beck and 16 other noted software developers, writers, and con
sultants [Bec01a] (referred to as the “Agile Alliance”) signed the “Manifesto for
 Agile Software Development.” It stated:
 We are uncovering better ways of developing software by doing it and helping others
 do it. Through this work we have come to value: 
Individuals and interactions over processes and tools
 Working software over comprehensive documentation
 Customer collaboration over contract negotiation
 Responding to change over following a plan
 That is, while there is value in the items on the right, we value the items on the 
left more.
 QUICK
 LOOK
 What is it? Agile software engi
neering combines a philosophy and
 a set of development guidelines. The
 philosophy encourages customer
 satisfaction and early incremental delivery of
 software; small, highly motivated project teams;
 informal methods; minimal software engineer
ing work products; and overall development
 simplicity. The development guidelines stress
 delivery over analysis and design (although
 these activities are not discouraged), and active
 and continuous communication between devel
opers and customers.
 Who does it? Software engineers and other
 project stakeholders (managers, customers, end
 users) work together on an agile team—a team
 that is self-organizing and in control of its own
 destiny. An agile team fosters communication
 and collaboration among all who serve on it.
 Why is it important? The modern business envi
ronment that spawns computer-based systems
 and software products is fast-paced and ever
changing. Agile software engineering repre
sents a reasonable alternative to conventional
 software engineering for certain classes of soft
ware and certain types of software projects. It
 has been demonstrated to deliver successful sys
tems quickly.
 Whatarethesteps? Agiledevelopmentmightbest
 be termed “software engineering lite.” The basic
 framework activities—communication, planning,
 modeling, construction, and deployment—
 remain. But they morph into a minimal task set
 that pushes the project team toward construction
 and delivery (some would argue that this is
 done at the expense of problem analysis and
 solution design).
 What is the work product? Both the customer
 and the software engineer have the same
 view—the only really important work product
 is an operational “software increment” that is
 delivered to the customer on the appropriate
 commitment date.
 How do I ensure that I’ve done it right? If the
 agile team agrees that the process works, and
 the team produces deliverable software
 increments that satisfy the customer, you’ve
 done it right.
 65
66
 PART ONE THE SOFTWARE PROCESS
 FDD . . . . . . . . . .86
 Industrial XP . . .77
 Lean Software
 Development . . .87
 pair 
programming . . .76
 project 
velocity . . . . . . .74
 refactoring . . . . .75
 Scrum . . . . . . . .82
 stories . . . . . . . .74
 XP process . . . . .73
 uote:
 “Agility: 1,
 everything else: 0.”
 Tom DeMarco
 A manifesto is normally associated with an emerging political movement—one
 that attacks the old guard and suggests revolutionary change (hopefully for the
 better). In some ways, that’s exactly what agile development is all about.
 Although the underlying ideas that guide agile development have been with us for
 many years, it has been less than two decades since these ideas have crystallized
 into a “movement.” In essence, agile1 methods were developed in an effort to over
come perceived and actual weaknesses in conventional software engineering. Agile
 development can provide important benefits, but it is not applicable to all projects,
 all products, all people, and all situations. It is also not antithetical to solid software
 engineering practice and can be applied as an overriding philosophy for all software
 work.
 In the modern economy, it is often difficult or impossible to predict how a
 computer-based system (e.g., a Web-based application) will evolve as time passes.
 Market conditions change rapidly, end-user needs evolve, and new competitive
 threats emerge without warning. In many situations, you won’t be able to define
 requirements fully before the project begins. You must be agile enough to respond to
 a fluid business environment.
 Fluidity implies change, and change is expensive. Particularly if it is uncontrolled
 or poorly managed. One of the most compelling characteristics of the agile approach
 is its ability to reduce the costs of change throughout the software process.
 Does this mean that a recognition of challenges posed by modern realities causes
 you to discard valuable software engineering principles, concepts, methods, and
 tools? Absolutely not! Like all engineering disciplines, software engineering contin
ues to evolve. It can be adapted easily to meet the challenges posed by a demand for
 agility.
 In a thought-provoking book on agile software development, Alistair Cockburn
 [Coc02] argues that the prescriptive process models introduced in Chapter 2 have a
 major failing: they forget the frailties of the people who build computer software. Software
 engineers are not robots. They exhibit great variation in working styles; significant dif
ferences in skill level, creativity, orderliness, consistency, and spontaneity. Some com
municate well in written form, others do not. Cockburn argues that process models
 can “deal with people’s common weaknesses with [either] discipline or tolerance” and
 that most prescriptive process models choose discipline. He states: “Because consis
tency in action is a human weakness, high discipline methodologies are fragile.”
 If process models are to work, they must provide a realistic mechanism for en
couraging the discipline that is necessary, or they must be characterized in a man
ner that shows “tolerance” for the people who do software engineering work.
 Invariably, tolerant practices are easier for software people to adopt and sustain, but
 (as Cockburn admits) they may be less productive. Like most things in life, trade-offs
 must be considered.
 1 Agile methods are sometimes referred to as light methods or lean methods.
67
 CHAPTER 3 AGILE DEVELOPMENT
 3.1 WHAT IS AGILITY?
 Just what is agility in the context of software engineering work? Ivar Jacobson
 [Jac02a] provides a useful discussion:
 Agility has become today’s buzzword when describing a modern software process. Every
one is agile. An agile team is a nimble team able to appropriately respond to changes.
 Change is what software development is very much about. Changes in the software be
ing built, changes to the team members, changes because of new technology, changes of
 all kinds that may have an impact on the product they build or the project that creates the
 product. Support for changes should be built-in everything we do in software, something
 we embrace because it is the heart and soul of software. An agile team recognizes that
 software is developed by individuals working in teams and that the skills of these people,
 their ability to collaborate is at the core for the success of the project.
 Don’t make the
 mistake of assuming
 that agility gives you
 license to hack out
 solutions. A process is
 required and discipline
 is essential.
 In Jacobson’s view, the pervasiveness of change is the primary driver for agility. Soft
ware engineers must be quick on their feet if they are to accommodate the rapid
 changes that Jacobson describes.
 But agility is more than an effective response to change. It also encompasses the
 philosophy espoused in the manifesto noted at the beginning of this chapter. It
 encourages team structures and attitudes that make communication (among team
 members, between technologists and business people, between software engineers
 and their managers) more facile. It emphasizes rapid delivery of operational soft
ware and de-emphasizes the importance of intermediate work products (not always
 a good thing); it adopts the customer as a part of the development team and works
 to eliminate the “us and them” attitude that continues to pervade many software
 projects; it recognizes that planning in an uncertain world has its limits and that a
 project plan must be flexible.
 Agility can be applied to any software process. However, to accomplish this, it is
 essential that the process be designed in a way that allows the project team to adapt
 tasks and to streamline them, conduct planning in a way that understands the fluid
ity of an agile development approach, eliminate all but the most essential work prod
ucts and keep them lean, and emphasize an incremental delivery strategy that gets
 working software to the customer as rapidly as feasible for the product type and
 operational environment.
 3.2 AGILITY AND THE COST OF CHANGE
 The conventional wisdom in software development (supported by decades of expe
rience) is that the cost of change increases nonlinearly as a project progresses
 (Figure 3.1, solid black curve). It is relatively easy to accommodate a change when a
 software team is gathering requirements (early in a project). A usage scenario might
 have to be modified, a list of functions may be extended, or a written specification
 can be edited. The costs of doing this work are minimal, and the time required will
68
 PART ONE THE SOFTWARE PROCESS
 FIGURE 3.1
 Change costs
 as a function
 of time in
 development
 uote:
 Development cost
 Cost of change
 using conventional
 software processes
 Cost of change
 using agile processes
 “Agility is dynamic,
 content specific,
 aggressively
 change embracing,
 and growth
 oriented.”
 Idealized cost of change
 using agile process
 Development schedule progress–Steven
 Goldman et al.
 An agile process
 reduces the cost of
 change because
 software is released in
 increments and change
 can be better
 controlled within an
 increment.
 not adversely affect the outcome of the project. But what if we fast-forward a num
ber of months? The team is in the middle of validation testing (something that occurs
 relatively late in the project), and an important stakeholder is requesting a major
 functional change. The change requires a modification to the architectural design of
 the software, the design and construction of three new components, modifications
 to another five components, the design of new tests, and so on. Costs escalate
 quickly, and the time and cost required to ensure that the change is made without
 unintended side effects is nontrivial.
 Proponents of agility (e.g., [Bec00], [Amb04]) argue that a well-designed agile
 process “flattens” the cost of change curve (Figure 3.1, shaded, solid curve), allowing
 a software team to accommodate changes late in a software project without dramatic
 cost and time impact. You’ve already learned that the agile process encompasses in
cremental delivery. When incremental delivery is coupled with other agile practices
 such as continuous unit testing and pair programming (discussed later in this chap
ter), the cost of making a change is attenuated. Although debate about the degree to
 which the cost curve flattens is ongoing, there is evidence [Coc01a] to suggest that a
 significant reduction in the cost of change can be achieved.
 3.3 WHAT IS ANAGILE PROCESS?
 Any agile software process is characterized in a manner that addresses a number of
 key assumptions [Fow02] about the majority of software projects: 
1. It is difficult to predict in advance which software requirements will persist
 and which will change. It is equally difficult to predict how customer
 priorities will change as the project proceeds.
69
 CHAPTER 3 AGILE DEVELOPMENT
 WebRef
 A comprehensive
 collection of articles on
 the agile process 
can be found at
 www.aanpo.org/
 articles/index.
 Although agile
 processes embrace
 change, it is still
 important to examine
 the reasons for
 change.
 Working software is
 important, but don’t
 forget that it must also
 exhibit a variety of
 quality attributes
 including reliability,
 usability, and 
maintainability.
 2. For many types of software, design and construction are interleaved. That is,
 both activities should be performed in tandem so that design models are
 proven as they are created. It is difficult to predict how much design is
 necessary before construction is used to prove the design.
 3. Analysis, design, construction, and testing are not as predictable (from a
 planning point of view) as we might like.
 Given these three assumptions, an important question arises: How do we create a
 process that can manage unpredictability? The answer, as I have already noted, lies
 in process adaptability (to rapidly changing project and technical conditions). An
 agile process, therefore, must be adaptable.
 But continual adaptation without forward progress accomplishes little. Therefore,
 an agile software process must adapt incrementally. To accomplish incremental adap
tation, an agile team requires customer feedback (so that the appropriate adaptations
 can be made). An effective catalyst for customer feedback is an operational prototype
 or a portion of an operational system. Hence, an incremental development strategy
 should be instituted. Software increments (executable prototypes or portions of an op
erational system) must be delivered in short time periods so that adaptation keeps pace
 with change (unpredictability). This iterative approach enables the customer to evalu
ate the software increment regularly, provide necessary feedback to the software team,
 and influence the process adaptations that are made to accommodate the feedback.
 3.3.1 Agility Principles
 The Agile Alliance (see [Agi03], [Fow01]) defines 12 agility principles for those who
 want to achieve agility: 
1. Our highest priority is to satisfy the customer through early and continuous
 delivery of valuable software.
 2. Welcome changing requirements, even late in development. Agile processes
 harness change for the customer’s competitive advantage.
 3. Deliver working software frequently, from a couple of weeks to a couple of
 months, with a preference to the shorter timescale.
 4. Business people and developers must work together daily throughout the
 project.
 5. Build projects around motivated individuals. Give them the environment and
 support they need, and trust them to get the job done.
 6. The most efficient and effective method of conveying information to and
 within a development team is face-to-face conversation.
 7. Working software is the primary measure of progress.
 8. Agile processes promote sustainable development. The sponsors, developers,
 and users should be able to maintain a constant pace indefinitely.
70
 PART ONE THE SOFTWARE PROCESS
 9. Continuous attention to technical excellence and good design enhances
 agility.
 10. Simplicity—the art of maximizing the amount of work not done—is 
essential.
 11. The best architectures, requirements, and designs emerge from self
organizing teams.
 12. At regular intervals, the team reflects on how to become more effective, then
 tunes and adjusts its behavior accordingly.
 Not every agile process model applies these 12 principles with equal weight, and
 some models choose to ignore (or at least downplay) the importance of one or more
 of the principles. However, the principles define an agile spirit that is maintained in
 each of the process models presented in this chapter.
 3.3.2 The Politics of Agile Development
 You don’t have to
 choose between agility
 and software engi
neering. Rather, define
 a software engineering
 approach that is agile.
 There is considerable debate (sometimes strident) about the benefits and applicabil
ity of agile software development as opposed to more conventional software engi
neering processes. Jim Highsmith [Hig02a] (facetiously) states the extremes when he
 characterizes the feeling of the pro-agility camp (“agilists”). “Traditional methodolo
gists are a bunch of stick-in-the-muds who’d rather produce flawless documentation
 than a working system that meets business needs.” As a counterpoint, he states
 (again, facetiously) the position of the traditional software engineering camp: “Light
weight, er, ‘agile’ methodologists are a bunch of glorified hackers who are going to
 be in for a heck of a surprise when they try to scale up their toys into enterprise-wide
 software.”
 Like all software technology arguments, this methodology debate risks degener
ating into a religious war. If warfare breaks out, rational thought disappears and
 beliefs rather than facts guide decision making.
 No one is against agility. The real question is: What is the best way to achieve it?
 As important, how do you build software that meets customers’ needs today and
 exhibits the quality characteristics that will enable it to be extended and scaled to
 meet customers’ needs over the long term?
 There are no absolute answers to either of these questions. Even within the agile
 school itself, there are many proposed process models (Section 3.4), each with a
 subtly different approach to the agility problem. Within each model there is a set of
 “ideas” (agilists are loath to call them “work tasks”) that represent a significant
 departure from traditional software engineering. And yet, many agile concepts are
 simply adaptations of good software engineering concepts. Bottom line: there is
 much that can be gained by considering the best of both schools and virtually
 nothing to be gained by denigrating either approach.
 If you have further interest, see [Hig01], [Hig02a], and [DeM02] for an entertain
ing summary of other important technical and political issues.
71
 CHAPTER 3 AGILE DEVELOPMENT
 uote:
 “Agile methods
 derive much of
 their agility by
 relying on the
 tacit knowledge
 embodied in the
 team, rather than
 writing the
 knowledge down
 in plans.”
 Barry Boehm
 ?
 What key
 traits must
 exist among the
 people on an
 effective software
 team?
 uote:
 “What counts as
 barely sufficient
 for one team is
 either overly
 sufficient or
 insufficient for
 another.”
 Alistair
 Cockburn
 3.3.3 Human Factors
 Proponents of agile software development take great pains to emphasize the impor
tance of “people factors.” As Cockburn and Highsmith [Coc01a] state, “Agile devel
opment focuses on the talents and skills of individuals, molding the process to
 specific people and teams.” The key point in this statement is that the process molds
 to the needs of the people and team, not the other way around.2
 If members of the software team are to drive the characteristics of the process that
 is applied to build software, a number of key traits must exist among the people on
 an agile team and the team itself:
 Competence. In an agile development (as well as software engineering)
 context, “competence” encompasses innate talent, specific software-related
 skills, and overall knowledge of the process that the team has chosen to
 apply. Skill and knowledge of process can and should be taught to all people
 who serve as agile team members.
 Common focus. Although members of the agile team may perform differ
ent tasks and bring different skills to the project, all should be focused on one
 goal—to deliver a working software increment to the customer within the
 time promised. To achieve this goal, the team will also focus on continual
 adaptations (small and large) that will make the process fit the needs of the
 team.
 Collaboration. Software engineering (regardless of process) is about as
sessing, analyzing, and using information that is communicated to the soft
ware team; creating information that will help all stakeholders understand
 the work of the team; and building information (computer software and rele
vant databases) that provides business value for the customer. To accomplish
 these tasks, team members must collaborate—with one another and all other
 stakeholders.
 Decision-making ability. Any good software team (including agile teams)
 must be allowed the freedom to control its own destiny. This implies that the
 team is given autonomy—decision-making authority for both technical and
 project issues.
 Fuzzy problem-solving ability. Software managers must recognize that
 the agile team will continually have to deal with ambiguity and will continu
ally be buffeted by change. In some cases, the team must accept the fact that
 the problem they are solving today may not be the problem that needs to be
 solved tomorrow. However, lessons learned from any problem-solving
 2 Successful software engineering organizations recognize this reality regardless of the process
 model they choose.
72
 PART ONE THE SOFTWARE PROCESS
 A self-organizing team
 is in control of the
 work it performs. The
 team makes its own
 commitments and
 defines plans to
 achieve them.
 activity (including those that solve the wrong problem) may be of benefit to
 the team later in the project.
 Mutual trust and respect. The agile team must become what DeMarco
 and Lister [DeM98] call a “jelled” team (Chapter 24). A jelled team exhibits
 the trust and respect that are necessary to make them “so strongly knit that
 the whole is greater than the sum of the parts.” [DeM98]
 Self-organization. In the context of agile development, self-organization
 implies three things: (1) the agile team organizes itself for the work to be
 done, (2) the team organizes the process to best accommodate its local envi
ronment, (3) the team organizes the work schedule to best achieve delivery
 of the software increment. Self-organization has a number of technical bene
fits, but more importantly, it serves to improve collaboration and boost team
 morale. In essence, the team serves as its own management. Ken Schwaber
 [Sch02] addresses these issues when he writes: “The team selects how much
 work it believes it can perform within the iteration, and the team commits to
 the work. Nothing demotivates a team as much as someone else making
 commitments for it. Nothing motivates a team as much as accepting the
 responsibility for fulfilling commitments that it made itself.”
 3.4 EXTREME PROGRAMMING (XP)
 In order to illustrate an agile process in a bit more detail, I’ll provide you with an
 overview of Extreme Programming (XP), the most widely used approach to agile soft
ware development. Although early work on the ideas and methods associated with
 XP occurred during the late 1980s, the seminal work on the subject has been written
 by Kent Beck [Bec04a]. More recently, a variant of XP, called Industrial XP (IXP) has
 been proposed [Ker05]. IXP refines XP and targets the agile process specifically for
 use within large organizations.
 3.4.1 XP Values
 Beck [Bec04a] defines a set of five values that establish a foundation for all work per
formed as part of XP—communication, simplicity, feedback, courage, and respect. Each
 of these values is used as a driver for specific XP activities, actions, and tasks.
 In order to achieve effective communication between software engineers and
 other stakeholders (e.g., to establish required features and functions for the soft
ware), XP emphasizes close, yet informal (verbal) collaboration between customers
 and developers, the establishment of effective metaphors3 for communicating
 important concepts, continuous feedback, and the avoidance of voluminous docu
mentation as a communication medium.
 3 In the XP context, a metaphor is “a story that everyone—customers, programmers, and managers—
 can tell about how the system works” [Bec04a].
73
 CHAPTER 3 AGILE DEVELOPMENT
 Keep it simple
 whenever you can, but
 recognize that
 continual “refactoring”
 can absorb significant
 time and resources.
 uote:
 “XP is the answer
 to the question,
 ‘How little can we
 do and still build
 great software?’“
 Anonymous
 WebRef
 An excellent overview
 of “rules” for XP can
 be found at www
 .extremeprogramm
 ing.org/rules.html.
 To achieve simplicity, XP restricts developers to design only for immediate needs,
 rather than consider future needs. The intent is to create a simple design that can be
 easily implemented in code). If the design must be improved, it can be refactored4 at
 a later time.
 Feedback is derived from three sources: the implemented software itself, the
 customer, and other software team members. By designing and implementing an
 effective testing strategy (Chapters 17 through 20), the software (via test results) pro
vides the agile team with feedback. XP makes use of the unit test as its primary test
ing tactic. As each class is developed, the team develops a unit test to exercise each
 operation according to its specified functionality. As an increment is delivered to a
 customer, the user stories or use cases (Chapter 5) that are implemented by the
 increment are used as a basis for acceptance tests. The degree to which the software
 implements the output, function, and behavior of the use case is a form of feedback.
 Finally, as new requirements are derived as part of iterative planning, the team pro
vides the customer with rapid feedback regarding cost and schedule impact.
 Beck [Bec04a] argues that strict adherence to certain XP practices demands
 courage. A better word might be discipline. For example, there is often significant
 pressure to design for future requirements. Most software teams succumb, arguing
 that “designing for tomorrow” will save time and effort in the long run. An agile XP
 team must have the discipline (courage) to design for today, recognizing that future
 requirements may change dramatically, thereby demanding substantial rework of
 the design and implemented code.
 By following each of these values, the agile team inculcates respect among it
 members, between other stakeholders and team members, and indirectly, for the
 software itself. As they achieve successful delivery of software increments, the team
 develops growing respect for the XP process.
 3.4.2 The XP Process
 Extreme Programming uses an object-oriented approach (Appendix 2) as its pre
ferred development paradigm and encompasses a set of rules and practices that
 occur within the context of four framework activities: planning, design, coding, and
 testing. Figure 3.2 illustrates the XP process and notes some of the key ideas and
 tasks that are associated with each framework activity. Key XP activities are sum
marized in the paragraphs that follow.
 Planning. The planning activity (also called the planning game) begins with
 listening—a requirements gathering activity that enables the technical members of
 the XP team to understand the business context for the software and to get a broad
 4 Refactoring allows a software engineer to improve the internal structure of a design (or source
 code) without changing its external functionality or behavior. In essence, refactoring can be used
 to improve the efficiency, readability, or performance of a design or the code that implements a
 design.
74
 PART ONE THE SOFTWARE PROCESS
 FIGURE 3.2
 The Extreme
 Programming
 process
 ?
 What is an
 XP “story”?
 WebRef
 A worthwhile XP
 “planning game” can
 be found at:
 c2.com/cgi/
 wiki?planningGame.
 simple design
 CRC cards
 user stories
 values
 acceptance test criteria
 iteration plan
 Release
 spike solutions
 prototypes
 refactoring
 design
 pair programming
 planning
 software increment
 project velocity computed
 unit test
 continuous integration
 acceptance testing
 test
 coding
 feel for required output and major features and functionality. Listening leads to the
 creation of a set of “stories” (also called user stories) that describe required output,
 features, and functionality for software to be built. Each story (similar to use cases
 described in Chapter 5) is written by the customer and is placed on an index card.
 The customer assigns a value (i.e., a priority) to the story based on the overall busi
ness value of the feature or function.5 Members of the XP team then assess each
 story and assign a cost—measured in development weeks—to it. If the story is esti
mated to require more than three development weeks, the customer is asked to split
 the story into smaller stories and the assignment of value and cost occurs again. It
 is important to note that new stories can be written at any time.
 Customers and developers work together to decide how to group stories into the
 next release (the next software increment) to be developed by the XP team. Once a
 basic commitment (agreement on stories to be included, delivery date, and other
 project matters) is made for a release, the XP team orders the stories that will be de
veloped in one of three ways: (1) all stories will be implemented immediately (within
 a few weeks), (2) the stories with highest value will be moved up in the schedule and
 implemented first, or (3) the riskiest stories will be moved up in the schedule and
 implemented first.
 After the first project release (also called a software increment) has been deliv
ered, the XP team computes project velocity. Stated simply, project velocity is the
 5 The value of a story may also be dependent on the presence of another story.
75
 CHAPTER 3 AGILE DEVELOPMENT
 Project velocity is a
 subtle measure of
 team productivity.
 XP deemphasizes the
 importance of design.
 Not everyone agrees.
 In fact, there are times
 when design should be
 emphasized.
 WebRef
 Refactoring techniques
 and tools can be
 found at:
 www.refactoring
 .com.
 number of customer stories implemented during the first release. Project velocity can
 then be used to (1) help estimate delivery dates and schedule for subsequent releases
 and (2) determine whether an overcommitment has been made for all stories across
 the entire development project. If an overcommitment occurs, the content of releases
 is modified or end delivery dates are changed.
 As development work proceeds, the customer can add stories, change the value
 of an existing story, split stories, or eliminate them. The XP team then reconsiders all
 remaining releases and modifies its plans accordingly.
 Design. XP design rigorously follows the KIS (keep it simple) principle. A simple
 design is always preferred over a more complex representation. In addition, the de
sign provides implementation guidance for a story as it is written—nothing less,
 nothing more. The design of extra functionality (because the developer assumes it
 will be required later) is discouraged.6
 XP encourages the use of CRC cards (Chapter 7) as an effective mechanism for
 thinking about the software in an object-oriented context. CRC (class-responsibility
collaborator) cards identify and organize the object-oriented classes7 that are rele
vant to the current software increment. The XP team conducts the design exercise
 using a process similar to the one described in Chapter 8. The CRC cards are the only
 design work product produced as part of the XP process.
 If a difficult design problem is encountered as part of the design of a story, XP rec
ommends the immediate creation of an operational prototype of that portion of the
 design. Called a spike solution, the design prototype is implemented and evaluated.
 The intent is to lower risk when true implementation starts and to validate the orig
inal estimates for the story containing the design problem.
 In the preceding section, we noted that XP encourages refactoring—a construction
 technique that is also a method for design optimization. Fowler [Fow00] describes
 refactoring in the following manner:
 Refactoring is the process of changing a software system in such a way that it does not
 alter the external behavior of the code yet improves the internal structure. It is a disci
plined way to clean up code [and modify/simplify the internal design] that minimizes the
 chances of introducing bugs. In essence, when you refactor you are improving the design
 of the code after it has been written.
 Because XP design uses virtually no notation and produces few, if any, work prod
ucts other than CRC cards and spike solutions, design is viewed as a transient arti
fact that can and should be continually modified as construction proceeds. The intent
 of refactoring is to control these modifications by suggesting small design changes
 6 These design guidelines should be followed in every software engineering method, although there
 are times when sophisticated design notation and terminology may get in the way of simplicity.
 7 Object-oriented classes are discussed in Appendix 2, in Chapter 8, and throughout Part 2 of this
 book.
76
 PART ONE THE SOFTWARE PROCESS
 Refactoring improves
 the internal structure of
 a design (or source
 code) without
 changing its external
 functionality or
 behavior.
 WebRef
 Useful information on
 XP can be obtained 
at www
 .xprogramming.
 com.
 ?
 What is 
pair
 programming?
 Many software teams
 are populated by indi
vidualists. You’ll have
 to work to change that
 culture if pair program
ming is to work effec
tively.
 ?
 XP?
 How are unit
 tests used in
 that “can radically improve the design” [Fow00]. It should be noted, however, that
 the effort required for refactoring can grow dramatically as the size of an application
 grows.
 A central notion in XP is that design occurs both before and after coding com
mences. Refactoring means that design occurs continuously as the system is con
structed. In fact, the construction activity itself will provide the XP team with
 guidance on how to improve the design.
 Coding. After stories are developed and preliminary design work is done, the team
 does not move to code, but rather develops a series of unit tests that will exercise
 each of the stories that is to be included in the current release (software increment).8
 Once the unit test9 has been created, the developer is better able to focus on what
 must be implemented to pass the test. Nothing extraneous is added (KIS). Once the
 code is complete, it can be unit-tested immediately, thereby providing instantaneous
 feedback to the developers.
 A key concept during the coding activity (and one of the most talked about aspects
 of XP) is pair programming. XP recommends that two people work together at one
 computer workstation to create code for a story. This provides a mechanism for real
time problem solving (two heads are often better than one) and real-time quality as
surance (the code is reviewed as it is created). It also keeps the developers focused
 on the problem at hand. In practice, each person takes on a slightly different role. For
 example, one person might think about the coding details of a particular portion of
 the design while the other ensures that coding standards (a required part of XP) are
 being followed or that the code for the story will satisfy the unit test that has been
 developed to validate the code against the story.
 As pair programmers complete their work, the code they develop is integrated
 with the work of others. In some cases this is performed on a daily basis by an inte
gration team. In other cases, the pair programmers have integration responsibility.
 This “continuous integration” strategy helps to avoid compatibility and interfacing
 problems and provides a “smoke testing” environment (Chapter 17) that helps to
 uncover errors early.
 Testing. I have already noted that the creation of unit tests before coding com
mences is a key element of the XP approach. The unit tests that are created should
 be implemented using a framework that enables them to be automated (hence, they
 can be executed easily and repeatedly). This encourages a regression testing strat
egy (Chapter 17) whenever code is modified (which is often, given the XP refactor
ing philosophy).
 8 This approach is analogous to knowing the exam questions before you begin to study. It makes
 studying much easier by focusing attention only on the questions that will be asked.
 9 Unit testing, discussed in detail in Chapter 17, focuses on an individual software component, exer
cising the component’s interface, data structures, and functionality in an effort to uncover errors
 that are local to the component.
77
 CHAPTER 3 AGILE DEVELOPMENT
 XP acceptance tests
 are derived from user
 stories.
 ?
 What new
 practices are
 appended to XP
 to create IXP?
 uote:
 “Ability is what
 you’re capable of
 doing. Motivation
 determines what
 you do. Attitude
 determines how
 well you do it.”
 Lou Holtz
 As the individual unit tests are organized into a “universal testing suite” [Wel99],
 integration and validation testing of the system can occur on a daily basis. This pro
vides the XP team with a continual indication of progress and also can raise warn
ing flags early if things go awry. Wells [Wel99] states: “Fixing small problems every
 few hours takes less time than fixing huge problems just before the deadline.”
 XP acceptance tests, also called customer tests, are specified by the customer and
 focus on overall system features and functionality that are visible and reviewable by
 the customer. Acceptance tests are derived from user stories that have been imple
mented as part of a software release.
 3.4.3 Industrial XP
 Joshua Kerievsky [Ker05] describes Industrial Extreme Programming (IXP) in the fol
lowing manner: “IXP is an organic evolution of XP. It is imbued with XP’s minimal
ist, customer-centric, test-driven spirit. IXP differs most from the original XP in its
 greater inclusion of management, its expanded role for customers, and its upgraded
 technical practices.” IXP incorporates six new practices that are designed to help
 ensure that an XP project works successfully for significant projects within a large
 organization.
 Readiness assessment. Prior to the initiation of an IXP project, the organ
ization should conduct a readiness assessment. The assessment ascertains
 whether (1) an appropriate development environment exists to support IXP,
 (2) the team will be populated by the proper set of stakeholders, (3) the or
ganization has a distinct quality program and supports continuous improve
ment, (4) the organizational culture will support the new values of an agile
 team, and (5) the broader project community will be populated appropriately.
 Project community. Classic XP suggests that the right people be used to
 populate the agile team to ensure success. The implication is that people on
 the team must be well-trained, adaptable and skilled, and have the proper
 temperament to contribute to a self-organizing team. When XP is to be
 applied for a significant project in a large organization, the concept of the
 “team” should morph into that of a community. A community may have a
 technologist and customers who are central to the success of a project as
 well as many other stakeholders (e.g., legal staff, quality auditors, manufac
turing or sales types) who “are often at the periphery of an IXP project yet
 they may play important roles on the project” [Ker05]. In IXP, the community
 members and their roles should be explicitly defined and mechanisms for
 communication and coordination between community members should be
 established.
 Project chartering. The IXP team assesses the project itself to determine
 whether an appropriate business justification for the project exists and
 whether the project will further the overall goals and objectives of the
78
 PART ONE THE SOFTWARE PROCESS
 organization. Chartering also examines the context of the project to deter
mine how it complements, extends, or replaces existing systems or
 processes.
 Test-driven management. An IXP project requires measurable criteria for
 assessing the state of the project and the progress that has been made to
 date. Test-driven management establishes a series of measurable “destina
tions” [Ker05] and then defines mechanisms for determining whether or not
 these destinations have been reached.
 Retrospectives. An IXP team conducts a specialized technical review
 (Chapter 15) after a software increment is delivered. Called a retrospective,
 the review examines “issues, events, and lessons-learned” [Ker05] across a
 software increment and/or the entire software release. The intent is to
 improve the IXP process.
 Continuous learning. Because learning is a vital part of continuous
 process improvement, members of the XP team are encouraged (and possi
bly, incented) to learn new methods and techniques that can lead to a higher
quality product.
 In addition to the six new practices discussed, IXP modifies a number of existing
 XP practices. Story-driven development (SDD) insists that stories for acceptance tests
 be written before a single line of code is generated. Domain-driven design (DDD) is
 an improvement on the “system metaphor” concept used in XP. DDD [Eva03] sug
gests the evolutionary creation of a domain model that “accurately represents how
 domain experts think about their subject” [Ker05]. Pairing extends the XP pair
programming concept to include managers and other stakeholders. The intent is to
 improve knowledge sharing among XP team members who may not be directly in
volved in technical development. Iterative usability discourages front-loaded inter
face design in favor of usability design that evolves as software increments are
 delivered and users’ interaction with the software is studied.
 IXP makes smaller modifications to other XP practices and redefines certain roles
 and responsibilities to make them more amenable to significant projects for large
 organizations. For further discussion of IXP, visit http://industrialxp.org.
 3.4.4 The XP Debate
 All new process models and methods spur worthwhile discussion and in some in
stances heated debate. Extreme Programming has done both. In an interesting book
 that examines the efficacy of XP, Stephens and Rosenberg [Ste03] argue that many
 XP practices are worthwhile, but others have been overhyped, and a few are prob
lematic. The authors suggest that the codependent nature of XP practices are both
 its strength and its weakness. Because many organizations adopt only a subset of XP
 practices, they weaken the efficacy of the entire process. Proponents counter that
 XP is continuously evolving and that many of the issues raised by critics have been
79
 CHAPTER 3 AGILE DEVELOPMENT
 addressed as XP practice matures. Among the issues that continue to trouble some
 critics of XP are:10
 ?
 What are
 some of the
 issues that lead to
 an XP debate?
 • Requirements volatility. Because the customer is an active member of the XP
 team, changes to requirements are requested informally. As a consequence,
 the scope of the project can change and earlier work may have to be
 modified to accommodate current needs. Proponents argue that this happens
 regardless of the process that is applied and that XP provides mechanisms for
 controlling scope creep.
 • Conflicting customer needs. Many projects have multiple customers, each with
 his own set of needs. In XP, the team itself is tasked with assimilating the
 needs of different customers, a job that may be beyond their scope of
 authority.
 • Requirements are expressed informally. User stories and acceptance tests are
 the only explicit manifestation of requirements in XP. Critics argue that a
 more formal model or specification is often needed to ensure that omissions,
 inconsistencies, and errors are uncovered before the system is built. Propo
nents counter that the changing nature of requirements makes such models
 and specification obsolete almost as soon as they are developed.
 • Lack of formal design. XP deemphasizes the need for architectural design and
 in many instances, suggests that design of all kinds should be relatively
 informal. Critics argue that when complex systems are built, design must be
 emphasized to ensure that the overall structure of the software will exhibit
 quality and maintainability. XP proponents suggest that the incremental
 nature of the XP process limits complexity (simplicity is a core value) and
 therefore reduces the need for extensive design.
 You should note that every software process has flaws and that many software or
ganizations have used XP successfully. The key is to recognize where a process may
 have weaknesses and to adapt it to the specific needs of your organization.
 SAFEHOME
 Considering Agile Software Development
 The scene: Doug Miller’s office.
 The Players: Doug Miller, software engineering
 manager; Jamie Lazar, software team member; Vinod
 Raman, software team member.
 The conversation:
 (A knock on the door, Jamie and Vinod enter Doug’s office)
 Jamie: Doug, you got a minute?
 10 For a detailed look at some thoughtful criticism that has been leveled at XP, visit
 www.softwarereality.com/ExtremeProgramming.jsp.
3.5 OTHERAGILEPROCESSMODELS
 The history of software engineering is littered with dozens of obsolete process
 descriptions and methodologies, modeling methods and notations, tools, and
 technology. Each flared in notoriety and was then eclipsed by something new and
 (purportedly) better. With the introduction of a wide array of agile process models—
 each contending for acceptance within the software development community—the
 agile movement is following the same historical path.11
 As I noted in the last section, the most widely used of all agile process models
 isExtreme Programming (XP). But many other agile process models have been
 proposed and are in use across the industry. Among the most common are:
 •Adaptive Software Development (ASD)
 •Scrum
 •Dynamic Systems Development Method (DSDM)
 80 PART ONE THE SOFTWARE PROCESS
 Doug: Sure Jamie, what’s up?
 Jamie:We’ve been thinking about our process
 discussion yesterday . . . you know, what process we’re
 going to choose for this new SafeHomeproject.
 Doug:And?
 Vinod: I was talking to a friend at another company,
 and he was telling me about Extreme Programming. It’s
 an agile process model . . . heard of it?
 Doug: Yeah, some good, some bad.
 Jamie:Well, it sounds pretty good to us. Lets you
 develop software really fast, uses something called pair
 programming to do real-time quality checks . . . it’s pretty
 cool, I think.
 Doug: It does have a lot of really good ideas. I like the
 pair-programming concept, for instance, and the idea
 that stakeholders should be part of the team.
 Jamie:Huh? You mean that marketing will work on the
 project team with us?
 Doug (nodding): They’re a stakeholder, aren’t they?
 Jamie: Jeez . . . they’ll be requesting changes every five
 minutes.
 Vinod:Not necessarily. My friend said that there are
 ways to “embrace” changes during an XP project.
 Doug: So you guys think we should use XP?
 Jamie: It’s definitely worth considering.
 Doug: I agree. And even if we choose an incremental
 model as our approach, there’s no reason why we can’t
 incorporate much of what XP has to offer.
 Vinod:Doug, before you said “some good, some bad.”
 What was the “bad”?
 Doug: The thing I don’t like is the way XP downplays
 analysis and design . . . sort of says that writing code is
 where the action is . . . 
(The team members look at one another and smile.)
 Doug: So you agree with the XP approach?
 Jamie (speaking for both):Writing code is what
 we do, Boss!
 Doug (laughing): True, but I’d like to see you spend a
 little less time coding and then recoding and a little more
 time analyzing what has to be done and designing a
 solution that works.
 Vinod:Maybe we can have it both ways, agility with a
 little discipline.
 Doug: I think we can, Vinod. In fact, I’m sure of it.
 uote:
 “Our profession
 goes through
 methodologies like
 a 14-year-old goes
 through clothing.”
 Stephen
 Hawrysh and
 JimRuprecht
 11This is not a bad thing. Before one or more models or methods are accepted as a de facto standard,
 all must contend for the hearts and minds of software engineers. The “winners” evolve into best
 practice, while the “losers” either disappear or merge with the winning models.
81
 CHAPTER 3 AGILE DEVELOPMENT
 • Crystal
 • Feature Drive Development (FDD)
 • Lean Software Development (LSD)
 • Agile Modeling (AM)
 • Agile Unified Process (AUP)
 In the sections that follow, I present a very brief overview of each of these agile
 process models. It is important to note that all agile process models conform (to a
 greater or lesser degree) to the Manifesto for Agile Software Development and the prin
ciples noted in Section 3.3.1. For additional detail, refer to the references noted in
 each subsection or for a survey, examine the “agile software development” entry
 in Wikipedia.12
 3.5.1 Adaptive Software Development (ASD)
 WebRef
 Useful resources for
 ASD can be found at
 www.adaptivesd
 .com.
 Adaptive Software Development (ASD) has been proposed by Jim Highsmith [Hig00] as
 a technique for building complex software and systems. The philosophical under
pinnings of ASD focus on human collaboration and team self-organization.
 Highsmith argues that an agile, adaptive development approach based on collab
oration is “as much a source of order in our complex interactions as discipline and
 engineering.” He defines an ASD “life cycle” (Figure 3.3) that incorporates three
 phases, speculation, collaboration, and learning.
 FIGURE 3.3
 Adaptive
 software
 development
 adaptive cycle planning
 mission statement
 project constraints
 basic requirements
 time-boxed release plan
 Release
 Requirements gathering
 JAD
 mini-specs
 speculation
 software increment
 adjustments for subsequent cycles
 collaboration
 components implemented/tested
 focus groups for feedback
 formal technical reviews
 learning
 postmortems
 12 See http://en.wikipedia.org/wiki/Agile_software_development#Agile_methods.
82
 PART ONE THE SOFTWARE PROCESS
 Effective collaboration
 with your customer will
 only occur if you
 jettison any “us and
 them” attitudes.
 ASD emphasizes
 learning as a key
 element in achieving 
a “self-organizing”
 team.
 WebRef
 Useful Scrum
 information and
 resources can be found
 at www
 .controlchaos.com.
 During speculation, the project is initiated and adaptive cycle planning is con
ducted. Adaptive cycle planning uses project initiation information—the customer’s
 mission statement, project constraints (e.g., delivery dates or user descriptions), and
 basic requirements—to define the set of release cycles (software increments) that
 will be required for the project.
 No matter how complete and farsighted the cycle plan, it will invariably change.
 Based on information obtained at the completion of the first cycle, the plan is re
viewed and adjusted so that planned work better fits the reality in which an ASD
 team is working.
 Motivated people use collaboration in a way that multiplies their talent and cre
ative output beyond their absolute numbers. This approach is a recurring theme in
 all agile methods. But collaboration is not easy. It encompasses communication and
 teamwork, but it also emphasizes individualism, because individual creativity plays
 an important role in collaborative thinking. It is, above all, a matter of trust. People
 working together must trust one another to (1) criticize without animosity, (2) assist
 without resentment, (3) work as hard as or harder than they do, (4) have the skill set
 to contribute to the work at hand, and (5) communicate problems or concerns in a
 way that leads to effective action.
 As members of an ASD team begin to develop the components that are part of an
 adaptive cycle, the emphasis is on “learning” as much as it is on progress toward
 a completed cycle. In fact, Highsmith [Hig00] argues that software developers often
 overestimate their own understanding (of the technology, the process, and the proj
ect) and that learning will help them to improve their level of real understanding.
 ASD teams learn in three ways: focus groups (Chapter 5), technical reviews (Chap
ter 14), and project postmortems.
 The ASD philosophy has merit regardless of the process model that is used. ASD’s
 overall emphasis on the dynamics of self-organizing teams, interpersonal collabo
ration, and individual and team learning yield software project teams that have a
 much higher likelihood of success.
 3.5.2 Scrum
 Scrum (the name is derived from an activity that occurs during a rugby match13) is
 an agile software development method that was conceived by Jeff Sutherland and his
 development team in the early 1990s. In recent years, further development on the
 Scrum methods has been performed by Schwaber and Beedle [Sch01a].
 Scrum principles are consistent with the agile manifesto and are used to guide
 development activities within a process that incorporates the following framework
 activities: requirements, analysis, design, evolution, and delivery. Within each
 13 A group of players forms around the ball and the teammates work together (sometimes violently!)
 to move the ball downfield.
every 24
 hours
 30 days
 Scrum: 15 minute daily meeting.
 Team members respond to basics:
 1) What did you do since last Scrum
 meeting?
 2) Do you have any obstacles?
 3) What will you do before next
 meeting?
 Sprint Backlog:
 Feature(s)
 assigned
 to sprint
 Product Backlog:
 Prioritized product features desired by the customer
 Backlog
 items
 expanded
 by team
 New functionality
 is demonstrated
 at end of sprint
 framework activity, work tasks occur within a process pattern (discussed in the fol
lowing paragraph) called a sprint.The work conducted within a sprint (the number
 of sprints required for each framework activity will vary depending on product com
plexity and size) is adapted to the problem at hand and is defined and often modified
 in real time by the Scrum team. The overall flow of the Scrum process is illustrated
 in Figure 3.4.
 Scrum emphasizes the use of a set of software process patterns [Noy02] that have
 proven effective for projects with tight timelines, changing requirements, and business
 criticality. Each of these process patterns defines a set of development actions:
 Backlog—a prioritized list of project requirements or features that provide busi
ness value for the customer. Items can be added to the backlog at any time (this is
 how changes are introduced). The product manager assesses the backlog and
 updates priorities as required.
 Sprints—consist of work units that are required to achieve a requirement de
fined in the backlog that must be fit into a predefined time-box14(typically 30 days).
 CHAPTER 3 AGILE DEVELOPMENT 83
 14A time-boxis a project management term (see Part 4 of this book) that indicates a period of time
 that has been allocated to accomplish some task.
 FIGURE3.4
 Scrum process
 flow
 Scrum incorporates a
 set of process patterns
 that emphasize project
 priorities,
 compartmentalized
 work units,
 communication, and
 frequent customer
 feedback.
84
 PART ONE THE SOFTWARE PROCESS
 Changes (e.g., backlog work items) are not introduced during the sprint. Hence, the
 sprint allows team members to work in a short-term, but stable environment.
 Scrum meetings—are short (typically 15 minutes) meetings held daily by the Scrum
 team. Three key questions are asked and answered by all team members [Noy02]:
 • What did you do since the last team meeting?
 • What obstacles are you encountering?
 • What do you plan to accomplish by the next team meeting?
 A team leader, called a Scrum master, leads the meeting and assesses the responses
 from each person. The Scrum meeting helps the team to uncover potential problems
 as early as possible. Also, these daily meetings lead to “knowledge socialization”
 [Bee99] and thereby promote a self-organizing team structure.
 Demos—deliver the software increment to the customer so that functionality that
 has been implemented can be demonstrated and evaluated by the customer. It is im
portant to note that the demo may not contain all planned functionality, but rather
 those functions that can be delivered within the time-box that was established.
 Beedle and his colleagues [Bee99] present a comprehensive discussion of these pat
terns in which they state: “Scrum assumes up-front the existence of chaos. . . . ” The
 Scrum process patterns enable a software team to work successfully in a world
 where the elimination of uncertainty is impossible.
 3.5.3 Dynamic Systems Development Method (DSDM)
 WebRef
 Useful resources for
 DSSD can be found at
 www.dsdm.org.
 The Dynamic Systems Development Method (DSDM) [Sta97] is an agile software devel
opment approach that “provides a framework for building and maintaining systems
 which meet tight time constraints through the use of incremental prototyping in a con
trolled project environment” [CCS02]. The DSDM philosophy is borrowed from a mod
ified version of the Pareto principle—80 percent of an application can be delivered in
 20 percent of the time it would take to deliver the complete (100 percent) application.
 DSDM is an iterative software process in which each iteration follows the 80 per
cent rule. That is, only enough work is required for each increment to facilitate
 movement to the next increment. The remaining detail can be completed later when
 more business requirements are known or changes have been requested and
 accommodated.
 The DSDM Consortium (www.dsdm.org) is a worldwide group of member com
panies that collectively take on the role of “keeper” of the method. The consortium
 has defined an agile process model, called the DSDM life cycle that defines three dif
ferent iterative cycles, preceded by two additional life cycle activities:
 Feasibility study—establishes the basic business requirements and constraints
 associated with the application to be built and then assesses whether the applica
tion is a viable candidate for the DSDM process.
85
 CHAPTER 3 AGILE DEVELOPMENT
 DSDM is a process
 framework that can
 adopt the tactics of
 another agile approach
 such as XP.
 Crystal is a family of
 process models with
 the same “genetic
 code” but different
 methods for adapting
 to project
 characteristics.
 Business study—establishes the functional and information requirements that
 will allow the application to provide business value; also, defines the basic
 application architecture and identifies the maintainability requirements for the
 application.
 Functional model iteration—produces a set of incremental prototypes that
 demonstrate functionality for the customer. (Note: All DSDM prototypes are in
tended to evolve into the deliverable application.) The intent during this iterative
 cycle is to gather additional requirements by eliciting feedback from users as they
 exercise the prototype.
 Design and build iteration—revisits prototypes built during functional model
 iteration to ensure that each has been engineered in a manner that will enable it to
 provide operational business value for end users. In some cases, functional model
 iteration and design and build iteration occur concurrently.
 Implementation—places the latest software increment (an “operationalized” pro
totype) into the operational environment. It should be noted that (1) the increment
 may not be 100 percent complete or (2) changes may be requested as the incre
ment is put into place. In either case, DSDM development work continues by
 returning to the functional model iteration activity.
 DSDM can be combined with XP (Section 3.4) to provide a combination approach
 that defines a solid process model (the DSDM life cycle) with the nuts and bolts prac
tices (XP) that are required to build software increments. In addition, the ASD con
cepts of collaboration and self-organizing teams can be adapted to a combined
 process model.
 3.5.4 Crystal
 Alistair Cockburn [Coc05] and Jim Highsmith [Hig02b] created the Crystal family of
 agile methods15 in order to achieve a software development approach that puts a
 premium on “maneuverability” during what Cockburn characterizes as “a resource
limited, cooperative game of invention and communication, with a primary goal of
 delivering useful, working software and a secondary goal of setting up for the next
 game” [Coc02].
 To achieve maneuverability, Cockburn and Highsmith have defined a set of
 methodologies, each with core elements that are common to all, and roles, process
 patterns, work products, and practice that are unique to each. The Crystal family is
 actually a set of example agile processes that have been proven effective for differ
ent types of projects. The intent is to allow agile teams to select the member of the
 crystal family that is most appropriate for their project and environment.
 15 The name “crystal” is derived from the characteristics of geological crystals, each with its own
 color, shape, and hardness.
86
 PART ONE THE SOFTWARE PROCESS
 3.5.5 Feature Driven Development (FDD)
 WebRef
 A wide variety of
 articles and
 presentations on FDD
 can be found at:
 www.featuredrive
 ndevelopment
 .com/.
 Feature Driven Development (FDD) was originally conceived by Peter Coad and his
 colleagues [Coa99] as a practical process model for object-oriented software engi
neering. Stephen Palmer and John Felsing [Pal02] have extended and improved
 Coad’s work, describing an adaptive, agile process that can be applied to moderately
 sized and larger software projects.
 Like other agile approaches, FDD adopts a philosophy that (1) emphasizes col
laboration among people on an FDD team; (2) manages problem and project
 complexity using feature-based decomposition followed by the integration of
 software increments, and (3) communication of technical detail using verbal,
 graphical, and text-based means. FDD emphasizes software quality assurance
 activities by encouraging an incremental development strategy, the use of design
 and code inspections, the application of software quality assurance audits (Chap
ter 16), the collection of metrics, and the use of patterns (for analysis, design, and
 construction).
 In the context of FDD, a feature “is a client-valued function that can be imple
mented in two weeks or less” [Coa99]. The emphasis on the definition of features
 provides the following benefits:
 • Because features are small blocks of deliverable functionality, users can
 describe them more easily; understand how they relate to one another more
 readily; and better review them for ambiguity, error, or omissions.
 • Features can be organized into a hierarchical business-related grouping.
 • Since a feature is the FDD deliverable software increment, the team develops
 operational features every two weeks.
 • Because features are small, their design and code representations are easier
 to inspect effectively.
 • Project planning, scheduling, and tracking are driven by the feature
 hierarchy, rather than an arbitrarily adopted software engineering 
task set.
 Coad and his colleagues [Coa99] suggest the following template for defining a
 feature:
 <action> the <result> <by for of to> a(n) <object>
 where an <object> is “a person, place, or thing (including roles, moments in time or
 intervals of time, or catalog-entry-like descriptions).” Examples of features for an 
e-commerce application might be:
 Add the product to shopping cart
 Display the technical-specifications of the product
 Store the shipping-information for the customer
87
 CHAPTER 3 AGILE DEVELOPMENT
 FIGURE 3.5
 Feature Driven
 Development
 [Coa99] (with
 permission)
 Develop
 an
 Overall
 Model
 Build a
 Features
 List
 Plan
 By
 Feature
 Design
 By
 Feature
 (more shape
 than content)
 A list of features
 grouped into sets
 and subject areas
 A development plan
 Class owners
 Feature Set Owners
 A design
 package
 (sequences)
 Build
 By
 Feature
 Completed
 client-value
 function
 A feature set groups related features into business-related categories and is defined
 [Coa99] as:
 <action><-ing> a(n) <object>
 For example: Making a product sale is a feature set that would encompass the fea
tures noted earlier and others.
 The FDD approach defines five “collaborating” [Coa99] framework activities (in
 FDD these are called “processes”) as shown in Figure 3.5.
 FDD provides greater emphasis on project management guidelines and tech
niques than many other agile methods. As projects grow in size and complexity,
 ad hoc project management is often inadequate. It is essential for developers, their
 managers, and other stakeholders to understand project status—what accomplish
ments have been made and problems have been encountered. If deadline pressure
 is significant, it is critical to determine if software increments (features) are properly
 scheduled. To accomplish this, FDD defines six milestones during the design and
 implementation of a feature: “design walkthrough, design, design inspection, code,
 code inspection, promote to build” [Coa99].
 3.5.6 Lean Software Development (LSD)
 Lean Software Development (LSD) has adapted the principles of lean manufacturing
 to the world of software engineering. The lean principles that inspire the LSD process
 can be summarized ([Pop03], [Pop06a]) as eliminate waste, build quality in, create
 knowledge, defer commitment, deliver fast, respect people, and optimize the whole.
 Each of these principles can be adapted to the software process. For example,
 eliminate waste within the context of an agile software project can be interpreted
 to mean [Das05]: (1) adding no extraneous features or functions, (2) assessing the
 cost and schedule impact of any newly requested requirement, (3) removing any
 superfluous process steps, (4) establishing mechanisms to improve the way team
 members find information, (5) ensuring the testing finds as many errors as possible,
88
 PART ONE THE SOFTWARE PROCESS
 (6) reducing the time required to request and get a decision that affects the software
 or the process that is applied to create it, and (7) streamlining the manner in which
 information is transmitted to all stakeholders involved in the process.
 For a detailed discussion of LSD and pragmatic guidelines for implementing the
 process, you should examine [Pop06a] and [Pop06b].
 3.5.7 Agile Modeling (AM)
 WebRef
 Comprehensive
 information on agile
 modeling can be found
 at: www
 .agilemodeling.com.
 uote:
 “I was in the drug
 store the other day
 trying to get a cold
 medication . . . not
 easy. There’s an
 entire wall of
 products you need.
 You stand there
 going, Well, this
 one is quick acting
 but this is long
 lasting. . . . Which
 is more important,
 the present or the
 future?”
 Jerry Seinfeld
 There are many situations in which software engineers must build large, business
critical systems. The scope and complexity of such systems must be modeled so that
 (1) all constituencies can better understand what needs to be accomplished, (2) the
 problem can be partitioned effectively among the people who must solve it, and
 (3) quality can be assessed as the system is being engineered and built.
 Over the past 30 years, a wide variety of software engineering modeling methods
 and notation have been proposed for analysis and design (both architectural and
 component-level). These methods have merit, but they have proven to be difficult
 to apply and challenging to sustain (over many projects). Part of the problem is the
 “weight” of these modeling methods. By this I mean the volume of notation required,
 the degree of formalism suggested, the sheer size of the models for large projects,
 and the difficulty in maintaining the model(s) as changes occur. Yet analysis and de
sign modeling have substantial benefit for large projects—if for no other reason than
 to make these projects intellectually manageable. Is there an agile approach to soft
ware engineering modeling that might provide an alternative?
 At “The Official Agile Modeling Site,” Scott Ambler [Amb02a] describes agile mod
eling (AM) in the following manner:
 Agile Modeling (AM) is a practice-based methodology for effective modeling and documen
tation of software-based systems. Simply put, Agile Modeling (AM) is a collection of values,
 principles, and practices for modeling software that can be applied on a software develop
ment project in an effective and light-weight manner. Agile models are more effective than
 traditional models because they are just barely good, they don’t have to be perfect.
 Agile modeling adopts all of the values that are consistent with the agile manifesto.
 The agile modeling philosophy recognizes that an agile team must have the courage
 to make decisions that may cause it to reject a design and refactor. The team must
 also have the humility to recognize that technologists do not have all the answers and
 that business experts and other stakeholders should be respected and embraced.
 Although AM suggests a wide array of “core” and “supplementary” modeling prin
ciples, those that make AM unique are [Amb02a]:
 Model with a purpose. A developer who uses AM should have a specific
 goal (e.g., to communicate information to the customer or to help better un
derstand some aspect of the software) in mind before creating the model.
 Once the goal for the model is identified, the type of notation to be used and
 level of detail required will be more obvious.
89
 CHAPTER 3 AGILE DEVELOPMENT
 Use multiple models. There are many different models and notations that
 can be used to describe software. Only a small subset is essential for most
 projects. AM suggests that to provide needed insight, each model should
 present a different aspect of the system and only those models that provide
 value to their intended audience should be used.
 “Traveling light” is an
 appropriate philosophy
 for all software engi
neering work. Build
 only those models that
 provide value … no
 more, no less.
 Travel light. As software engineering work proceeds, keep only those mod
els that will provide long-term value and jettison the rest. Every work product
 that is kept must be maintained as changes occur. This represents work that
 slows the team down. Ambler [Amb02a] notes that “Every time you decide to
 keep a model you trade-off agility for the convenience of having that informa
tion available to your team in an abstract manner (hence potentially enhanc
ing communication within your team as well as with project stakeholders).”
 Content is more important than representation. Modeling should im
part information to its intended audience. A syntactically perfect model that
 imparts little useful content is not as valuable as a model with flawed nota
tion that nevertheless provides valuable content for its audience.
 Know the models and the tools you use to create them. Understand
 the strengths and weaknesses of each model and the tools that are used to
 create it.
 Adapt locally. The modeling approach should be adapted to the needs of
 the agile team.
 A major segment of the software engineering community has adopted the Unified
 Modeling Language (UML)16 as the preferred method for representing analysis and
 design models. The Unified Process (Chapter 2) has been developed to provide a
 framework for the application of UML. Scott Ambler [Amb06] has developed a sim
plified version of the UP that integrates his agile modeling philosophy.
 3.5.8 Agile Unified Process (AUP)
 The Agile Unified Process (AUP) adopts a “serial in the large” and “iterative in the
 small” [Amb06] philosophy for building computer-based systems. By adopting the
 classic UP phased activities—inception, elaboration, construction, and transition—AUP
 provides a serial overlay (i.e., a linear sequence of software engineering activities)
 that enables a team to visualize the overall process flow for a software project. How
ever, within each of the activities, the team iterates to achieve agility and to deliver
 meaningful software increments to end users as rapidly as possible. Each AUP iter
ation addresses the following activities [Amb06]: 
• Modeling. UML representations of the business and problem domains are
 created. However, to stay agile, these models should be “just barely good
 enough” [Amb06] to allow the team to proceed.
 16 A brief tutorial on UML is presented in Appendix 1.
90
 PART ONE THE SOFTWARE PROCESS
 • Implementation. Models are translated into source code.
 • Testing. Like XP, the team designs and executes a series of tests to uncover
 errors and ensure that the source code meets its requirements.
 • Deployment. Like the generic process activity discussed in Chapters 1 and 2,
 deployment in this context focuses on the delivery of a software increment
 and the acquisition of feedback from end users.
 • Configuration and project management. In the context of AUP, configuration
 management (Chapter 22) addresses change management, risk manage
ment, and the control of any persistent work products17 that are produced by
 the team. Project management tracks and controls the progress of the team
 and coordinates team activities.
 • Environment management. Environment management coordinates a process
 infrastructure that includes standards, tools, and other support technology
 available to the team.
 Although the AUP has historical and technical connections to the Unified Modeling
 Language, it is important to note that UML modeling can be using in conjunction
 with any of the agile process models described in Section 3.5.
 SOFTWARE TOOLS
 Agile Development
 Objective: The objective of agile development
 tools is to assist in one or more aspects of agile
 development with an emphasis on facilitating the rapid
 generation of operational software. These tools can also
 be used when prescriptive process models (Chapter 2) are
 applied.
 Mechanics: Tool mechanics vary. In general, agile tool
 sets encompass automated support for project planning,
 use case development and requirements gathering, rapid
 design, code generation, and testing.
 Representative Tools:18
 Note: Because agile development is a hot topic, most
 software tools vendors purport to sell tools that support 
the agile approach. The tools noted here have
 characteristics that make them particularly useful for
 agile projects.
 OnTime, developed by Axosoft (www.axosoft.com),
 provides agile process management support for
 various technical activities within the process.
 Ideogramic UML, developed by Ideogramic
 (www.ideogramic.com) is a UML tool set
 specifically developed for use within an agile 
process.
 Together Tool Set, distributed by Borland
 (www.borland.com), provides a tools suite that
 supports many technical activities within XP and other
 agile processes.
 17 A persistent work product is a model or document or test case produced by the team that will be kept
 for an indeterminate period of time. It will not be discarded once the software increment is
 delivered.
 18 Tools noted here do not represent an endorsement, but rather a sampling of tools in this category.
 In most cases, tool names are trademarked by their respective developers.
91
 CHAPTER 3 AGILE DEVELOPMENT
 3.6 A TOOL SET FOR THE AGILE PROCESS
 The “tool set” that
 supports agile
 processes focuses
 more on people issues
 than it does on
 technology issues.
 Some proponents of the agile philosophy argue that automated software tools (e.g.,
 design tools) should be viewed as a minor supplement to the team’s activities, and
 not at all pivotal to the success of the team. However, Alistair Cockburn [Coc04] sug
gests that tools can have a benefit and that “agile teams stress using tools that per
mit the rapid flow of understanding. Some of those tools are social, starting even at
 the hiring stage. Some tools are technological, helping distributed teams simulate
 being physically present. Many tools are physical, allowing people to manipulate
 them in workshops.”
 Because acquiring the right people (hiring), team collaboration, stakeholder com
munication, and indirect management are key elements in virtually all agile process
 models, Cockburn argues that “tools” that address these issues are critical success
 factors for agility. For example, a hiring “tool” might be the requirement to have a
 prospective team member spend a few hours pair programming with an existing
 member of the team. The “fit” can be assessed immediately.
 Collaborative and communication “tools” are generally low tech and incorporate
 any mechanism (“physical proximity, whiteboards, poster sheets, index cards, and
 sticky notes” [Coc04]) that provides information and coordination among agile de
velopers. Active communication is achieved via the team dynamics (e.g., pair pro
gramming), while passive communication is achieved by “information radiators”
 (e.g., a flat panel display that presents the overall status of different components of
 an increment). Project management tools deemphasize the Gantt chart and replace
 it with earned value charts or “graphs of tests created versus passed . . . other agile
 tools are used to optimize the environment in which the agile team works (e.g., more
 efficient meeting areas), improve the team culture by nurturing social interactions
 (e.g., collocated teams), physical devices (e.g., electronic whiteboards), and process
 enhancement (e.g., pair programming or time-boxing)” [Coc04].
 Are any of these things really tools? They are, if they facilitate the work performed
 by an agile team member and enhance the quality of the end product.
 3.7 SUMMARY
 In a modern economy, market conditions change rapidly, customer and end-user
 needs evolve, and new competitive threats emerge without warning. Practitioners
 must approach software engineering in a manner that allows them to remain agile—
 to define maneuverable, adaptive, lean processes that can accommodate the needs
 of modern business.
 An agile philosophy for software engineering stresses four key issues: the impor
tance of self-organizing teams that have control over the work they perform, com
munication and collaboration between team members and between practitioners
 and their customers, a recognition that change represents an opportunity, and
92
 PART ONE THE SOFTWARE PROCESS
 an emphasis on rapid delivery of software that satisfies the customer. Agile process
 models have been designed to address each of these issues.
 Extreme programming (XP) is the most widely used agile process. Organized as
 four framework activities—planning, design, coding, and testing—XP suggests a
 number of innovative and powerful techniques that allow an agile team to create
 frequent software releases that deliver features and functionality that have been de
scribed and then prioritized by stakeholders.
 Other agile process models also stress human collaboration and team self
organization, but define their own framework activities and select different points of
 emphasis. For example, ASD uses an iterative process that incorporates adaptive
 cycle planning, relatively rigorous requirement gathering methods, and an iterative
 development cycle that incorporates customer focus groups and formal technical re
views as real-time feedback mechanisms. Scrum emphasizes the use of a set of soft
ware process patterns that have proven effective for projects with tight time lines,
 changing requirements, and business criticality. Each process pattern defines a set
 of development tasks and allows the Scrum team to construct a process that is
 adapted to the needs of the project. The Dynamic Systems Development Method
 (DSDM) advocates the use of time-box scheduling and suggests that only enough
 work is required for each software increment to facilitate movement to the next
 increment. Crystal is a family of agile process models that can be adopted to the spe
cific characteristics of a project.
 Feature Driven Development (FDD) is somewhat more “formal” than other agile
 methods, but still maintains agility by focusing the project team on the development
 of features—a client-valued function that can be implemented in two weeks or less.
 Lean Software Development (LSD) has adapted the principles of lean manufacturing
 to the world of software engineering. Agile modeling (AM) suggests that modeling is
 essential for all systems, but that the complexity, type, and size of the model must be
 tuned to the software to be built. The Agile Unified Process (AUP) adopts a “serial in
 the large” and “iterative in the small” philosophy for building software.
 PROBLEMS AND POINTS TO PONDER
 3.1. Reread “The Manifesto for Agile Software Development” at the beginning of this chapter.
 Can you think of a situation in which one or more of the four “values” could get a software team
 into trouble?
 3.2. Describe agility (for software projects) in your own words.
 3.3. Why does an iterative process make it easier to manage change? Is every agile process dis
cussed in this chapter iterative? Is it possible to complete a project in just one iteration and still
 be agile? Explain your answers.
 3.4. Could each of the agile processes be described using the generic framework activities
 noted in Chapter 2? Build a table that maps the generic activities into the activities defined for
 each agile process.
 3.5. Try to come up with one more “agility principle” that would help a software engineering
 team become even more maneuverable.
93
 CHAPTER 3 AGILE DEVELOPMENT
 3.6. Select one agility principle noted in Section 3.3.1 and try to determine whether each of the
 process models presented in this chapter exhibits the principle. [Note: I have presented an
 overview of these process models only, so it may not be possible to determine whether a prin
ciple has been addressed by one or more of the models, unless you do additional research
 (which is not required for this problem).]
 3.7. Why do requirements change so much? After all, don’t people know what they want?
 3.8. Most agile process models recommend face-to-face communication. Yet today, members
 of a software team and their customers may be geographically separated from one another. Do
 you think this implies that geographical separation is something to avoid? Can you think of ways
 to overcome this problem?
 3.9. Write an XP user story that describes the “favorite places” or “bookmarks” feature avail
able on most Web browsers.
 3.10. What is a spike solution in XP?
 3.11. Describe the XP concepts of refactoring and pair programming in your own words.
 3.12. Do a bit more reading and describe what a time-box is. How does this assist an ASD team
 in delivering software increments in a short time period?
 3.13. Do the 80 percent rule in DSDM and the time-boxing approach defined for ASD achieve
 the same result?
 3.14. Using the process pattern template presented in Chapter 2, develop a process pattern for
 any one of the Scrum patterns presented in Section 3.5.2.
 3.15. Why is Crystal called a family of agile methods?
 3.16. Using the FDD feature template described in Section 3.5.5, define a feature set for a Web
 browser. Now develop a set of features for the feature set.
 3.17. Visit the Official Agile Modeling Site and make a complete list of all core and supple
mentary AM principles.
 3.18. The tool set proposed in Section 3.6 supports many of the “soft” aspects of agile meth
ods. Since communication is so important, recommend an actual tool set that might be used to
 enhance communication among stakeholders on an agile team.
 FURTHER READINGS AND INFORMATION SOURCES
 The overall philosophy and underlying principles of agile software development are considered
 in depth in many of the books referenced in the body of this chapter. In addition, books by Shaw
 and Warden (The Art of Agile Development, O’Reilly Media, Inc., 2008), Hunt (Agile Software Con
struction, Springer, 2005), and Carmichael and Haywood (Better Software Faster, Prentice-Hall,
 2002) present useful discussions of the subject. Aguanno (Managing Agile Projects, Multi
Media Publications, 2005), Highsmith (Agile Project Management: Creating Innovative Products,
 Addison-Wesley, 2004), and Larman (Agile and Iterative Development: A Manager’s Guide,
 Addison-Wesley, 2003) present a management overview and consider project management
 issues. Highsmith (Agile Software Development Ecosystems, Addison-Wesley, 2002) presents a
 survey of agile principles, processes, and practices. A worthwhile discussion of the delicate bal
ance between agility and discipline is presented by Booch and his colleagues (Balancing Agility
 and Discipline, Addison-Wesley, 2004).
 Martin (Clean Code: A Handbook of Agile Software Craftsmanship, Prentice-Hall, 2009) pres
ents the principles, patterns, and practices required to develop “clean code” in an agile software
 engineering environment. Leffingwell (Scaling Software Agility: Best Practices for Large Enter
prises, Addison-Wesley, 2007) discusses strategies for scaling up agile practices for large proj
ects. Lippert and Rook (Refactoring in Large Software Projects: Performing Complex Restructurings
 Successfully, Wiley, 2006) discuss the use of refactoring when applied in large, complex systems.
94
 PART ONE THE SOFTWARE PROCESS
 Stamelos and Sfetsos (Agile Software Development Quality Assurance, IGI Global, 2007) discuss
 SQA techniques that conform to the agile philosophy.
 Dozens of books have been written about Extreme Programming over the past decade. Beck
 (Extreme Programming Explained: Embrace Change, 2d ed., Addison-Wesley, 2004) remains the
 definitive treatment of the subject. In addition, Jeffries and his colleagues (Extreme Programming
 Installed, Addison-Wesley, 2000), Succi and Marchesi (Extreme Programming Examined,
 Addison-Wesley, 2001), Newkirk and Martin (Extreme Programming in Practice, Addison-Wesley,
 2001), and Auer and his colleagues (Extreme Programming Applied: Play to Win, Addison-Wesley,
 2001) provide a nuts-and-bolts discussion of XP along with guidance on how best to apply it.
 McBreen (Questioning Extreme Programming, Addison-Wesley, 2003) takes a critical look at XP,
 defining when and where it is appropriate. An in-depth consideration of pair programming is
 presented by McBreen (Pair Programming Illuminated, Addison-Wesley, 2003).
 ASD is addressed in depth by Highsmith [Hig00]. Schwaber (The Enterprise and Scrum,
 Microsoft Press, 2007) discusses the use of Scrum for projects that have a major business
 impact. The nuts and bolts of Scrum are discussed by Schwaber and Beedle (Agile Software
 Development with SCRUM, Prentice-Hall, 2001). Worthwhile treatments of DSDM have been
 written by the DSDM Consortium (DSDM: Business Focused Development, 2d ed., Pearson Edu
cation, 2003) and Stapleton (DSDM: The Method in Practice, Addison-Wesley, 1997). Cockburn
 (Crystal Clear, Addison-Wesley, 2005) presents an excellent overview of the Crystal family of
 processes. Palmer and Felsing [Pal02] present a detailed treatment of FDD. Carmichael and
 Haywood (Better Software Faster, Prentice-Hall, 2002) provides another useful treatment of FDD
 that includes a step-by-step journey through the mechanics of the process. Poppendieck and 
Poppendieck (Lean Development: An Agile Toolkit for Software Development Managers, Addison
Wesley, 2003) provide guidelines for managing and controlling agile projects. Ambler and
 Jeffries (Agile Modeling, Wiley, 2002) discuss AM in some depth.
 A wide variety of information sources on agile software development are available on the
 Internet. An up-to-date list of World Wide Web references that are relevant to the agile process
 can be found at the SEPA website: www.mhhe.com/engcs/compsci/pressman/
 professional/olc/ser.htm.
In 2001, Kent Beck and 16 other noted software developers, writers, and con
sultants [Bec01a] (referred to as the “Agile Alliance”) signed the “Manifesto for
 Agile Software Development.” It stated:
 We are uncovering better ways of developing software by doing it and helping others
 do it. Through this work we have come to value: 
Individuals and interactions over processes and tools
 Working software over comprehensive documentation
 Customer collaboration over contract negotiation
 Responding to change over following a plan
 That is, while there is value in the items on the right, we value the items on the 
left more.
 QUICK
 LOOK
 What is it? Agile software engi
neering combines a philosophy and
 a set of development guidelines. The
 philosophy encourages customer
 satisfaction and early incremental delivery of
 software; small, highly motivated project teams;
 informal methods; minimal software engineer
ing work products; and overall development
 simplicity. The development guidelines stress
 delivery over analysis and design (although
 these activities are not discouraged), and active
 and continuous communication between devel
opers and customers.
 Who does it? Software engineers and other
 project stakeholders (managers, customers, end
 users) work together on an agile team—a team
 that is self-organizing and in control of its own
 destiny. An agile team fosters communication
 and collaboration among all who serve on it.
 Why is it important? The modern business envi
ronment that spawns computer-based systems
 and software products is fast-paced and ever
changing. Agile software engineering repre
sents a reasonable alternative to conventional
 software engineering for certain classes of soft
ware and certain types of software projects. It
 has been demonstrated to deliver successful sys
tems quickly.
 Whatarethesteps? Agiledevelopmentmightbest
 be termed “software engineering lite.” The basic
 framework activities—communication, planning,
 modeling, construction, and deployment—
 remain. But they morph into a minimal task set
 that pushes the project team toward construction
 and delivery (some would argue that this is
 done at the expense of problem analysis and
 solution design).
 What is the work product? Both the customer
 and the software engineer have the same
 view—the only really important work product
 is an operational “software increment” that is
 delivered to the customer on the appropriate
 commitment date.
 How do I ensure that I’ve done it right? If the
 agile team agrees that the process works, and
 the team produces deliverable software
 increments that satisfy the customer, you’ve
 done it right.
 65
66
 PART ONE THE SOFTWARE PROCESS
 FDD . . . . . . . . . .86
 Industrial XP . . .77
 Lean Software
 Development . . .87
 pair 
programming . . .76
 project 
velocity . . . . . . .74
 refactoring . . . . .75
 Scrum . . . . . . . .82
 stories . . . . . . . .74
 XP process . . . . .73
 uote:
 “Agility: 1,
 everything else: 0.”
 Tom DeMarco
 A manifesto is normally associated with an emerging political movement—one
 that attacks the old guard and suggests revolutionary change (hopefully for the
 better). In some ways, that’s exactly what agile development is all about.
 Although the underlying ideas that guide agile development have been with us for
 many years, it has been less than two decades since these ideas have crystallized
 into a “movement.” In essence, agile1 methods were developed in an effort to over
come perceived and actual weaknesses in conventional software engineering. Agile
 development can provide important benefits, but it is not applicable to all projects,
 all products, all people, and all situations. It is also not antithetical to solid software
 engineering practice and can be applied as an overriding philosophy for all software
 work.
 In the modern economy, it is often difficult or impossible to predict how a
 computer-based system (e.g., a Web-based application) will evolve as time passes.
 Market conditions change rapidly, end-user needs evolve, and new competitive
 threats emerge without warning. In many situations, you won’t be able to define
 requirements fully before the project begins. You must be agile enough to respond to
 a fluid business environment.
 Fluidity implies change, and change is expensive. Particularly if it is uncontrolled
 or poorly managed. One of the most compelling characteristics of the agile approach
 is its ability to reduce the costs of change throughout the software process.
 Does this mean that a recognition of challenges posed by modern realities causes
 you to discard valuable software engineering principles, concepts, methods, and
 tools? Absolutely not! Like all engineering disciplines, software engineering contin
ues to evolve. It can be adapted easily to meet the challenges posed by a demand for
 agility.
 In a thought-provoking book on agile software development, Alistair Cockburn
 [Coc02] argues that the prescriptive process models introduced in Chapter 2 have a
 major failing: they forget the frailties of the people who build computer software. Software
 engineers are not robots. They exhibit great variation in working styles; significant dif
ferences in skill level, creativity, orderliness, consistency, and spontaneity. Some com
municate well in written form, others do not. Cockburn argues that process models
 can “deal with people’s common weaknesses with [either] discipline or tolerance” and
 that most prescriptive process models choose discipline. He states: “Because consis
tency in action is a human weakness, high discipline methodologies are fragile.”
 If process models are to work, they must provide a realistic mechanism for en
couraging the discipline that is necessary, or they must be characterized in a man
ner that shows “tolerance” for the people who do software engineering work.
 Invariably, tolerant practices are easier for software people to adopt and sustain, but
 (as Cockburn admits) they may be less productive. Like most things in life, trade-offs
 must be considered.
 1 Agile methods are sometimes referred to as light methods or lean methods.
67
 CHAPTER 3 AGILE DEVELOPMENT
 3.1 WHAT IS AGILITY?
 Just what is agility in the context of software engineering work? Ivar Jacobson
 [Jac02a] provides a useful discussion:
 Agility has become today’s buzzword when describing a modern software process. Every
one is agile. An agile team is a nimble team able to appropriately respond to changes.
 Change is what software development is very much about. Changes in the software be
ing built, changes to the team members, changes because of new technology, changes of
 all kinds that may have an impact on the product they build or the project that creates the
 product. Support for changes should be built-in everything we do in software, something
 we embrace because it is the heart and soul of software. An agile team recognizes that
 software is developed by individuals working in teams and that the skills of these people,
 their ability to collaborate is at the core for the success of the project.
 Don’t make the
 mistake of assuming
 that agility gives you
 license to hack out
 solutions. A process is
 required and discipline
 is essential.
 In Jacobson’s view, the pervasiveness of change is the primary driver for agility. Soft
ware engineers must be quick on their feet if they are to accommodate the rapid
 changes that Jacobson describes.
 But agility is more than an effective response to change. It also encompasses the
 philosophy espoused in the manifesto noted at the beginning of this chapter. It
 encourages team structures and attitudes that make communication (among team
 members, between technologists and business people, between software engineers
 and their managers) more facile. It emphasizes rapid delivery of operational soft
ware and de-emphasizes the importance of intermediate work products (not always
 a good thing); it adopts the customer as a part of the development team and works
 to eliminate the “us and them” attitude that continues to pervade many software
 projects; it recognizes that planning in an uncertain world has its limits and that a
 project plan must be flexible.
 Agility can be applied to any software process. However, to accomplish this, it is
 essential that the process be designed in a way that allows the project team to adapt
 tasks and to streamline them, conduct planning in a way that understands the fluid
ity of an agile development approach, eliminate all but the most essential work prod
ucts and keep them lean, and emphasize an incremental delivery strategy that gets
 working software to the customer as rapidly as feasible for the product type and
 operational environment.
 3.2 AGILITY AND THE COST OF CHANGE
 The conventional wisdom in software development (supported by decades of expe
rience) is that the cost of change increases nonlinearly as a project progresses
 (Figure 3.1, solid black curve). It is relatively easy to accommodate a change when a
 software team is gathering requirements (early in a project). A usage scenario might
 have to be modified, a list of functions may be extended, or a written specification
 can be edited. The costs of doing this work are minimal, and the time required will
68
 PART ONE THE SOFTWARE PROCESS
 FIGURE 3.1
 Change costs
 as a function
 of time in
 development
 uote:
 Development cost
 Cost of change
 using conventional
 software processes
 Cost of change
 using agile processes
 “Agility is dynamic,
 content specific,
 aggressively
 change embracing,
 and growth
 oriented.”
 Idealized cost of change
 using agile process
 Development schedule progress–Steven
 Goldman et al.
 An agile process
 reduces the cost of
 change because
 software is released in
 increments and change
 can be better
 controlled within an
 increment.
 not adversely affect the outcome of the project. But what if we fast-forward a num
ber of months? The team is in the middle of validation testing (something that occurs
 relatively late in the project), and an important stakeholder is requesting a major
 functional change. The change requires a modification to the architectural design of
 the software, the design and construction of three new components, modifications
 to another five components, the design of new tests, and so on. Costs escalate
 quickly, and the time and cost required to ensure that the change is made without
 unintended side effects is nontrivial.
 Proponents of agility (e.g., [Bec00], [Amb04]) argue that a well-designed agile
 process “flattens” the cost of change curve (Figure 3.1, shaded, solid curve), allowing
 a software team to accommodate changes late in a software project without dramatic
 cost and time impact. You’ve already learned that the agile process encompasses in
cremental delivery. When incremental delivery is coupled with other agile practices
 such as continuous unit testing and pair programming (discussed later in this chap
ter), the cost of making a change is attenuated. Although debate about the degree to
 which the cost curve flattens is ongoing, there is evidence [Coc01a] to suggest that a
 significant reduction in the cost of change can be achieved.
 3.3 WHAT IS ANAGILE PROCESS?
 Any agile software process is characterized in a manner that addresses a number of
 key assumptions [Fow02] about the majority of software projects: 
1. It is difficult to predict in advance which software requirements will persist
 and which will change. It is equally difficult to predict how customer
 priorities will change as the project proceeds.
69
 CHAPTER 3 AGILE DEVELOPMENT
 WebRef
 A comprehensive
 collection of articles on
 the agile process 
can be found at
 www.aanpo.org/
 articles/index.
 Although agile
 processes embrace
 change, it is still
 important to examine
 the reasons for
 change.
 Working software is
 important, but don’t
 forget that it must also
 exhibit a variety of
 quality attributes
 including reliability,
 usability, and 
maintainability.
 2. For many types of software, design and construction are interleaved. That is,
 both activities should be performed in tandem so that design models are
 proven as they are created. It is difficult to predict how much design is
 necessary before construction is used to prove the design.
 3. Analysis, design, construction, and testing are not as predictable (from a
 planning point of view) as we might like.
 Given these three assumptions, an important question arises: How do we create a
 process that can manage unpredictability? The answer, as I have already noted, lies
 in process adaptability (to rapidly changing project and technical conditions). An
 agile process, therefore, must be adaptable.
 But continual adaptation without forward progress accomplishes little. Therefore,
 an agile software process must adapt incrementally. To accomplish incremental adap
tation, an agile team requires customer feedback (so that the appropriate adaptations
 can be made). An effective catalyst for customer feedback is an operational prototype
 or a portion of an operational system. Hence, an incremental development strategy
 should be instituted. Software increments (executable prototypes or portions of an op
erational system) must be delivered in short time periods so that adaptation keeps pace
 with change (unpredictability). This iterative approach enables the customer to evalu
ate the software increment regularly, provide necessary feedback to the software team,
 and influence the process adaptations that are made to accommodate the feedback.
 3.3.1 Agility Principles
 The Agile Alliance (see [Agi03], [Fow01]) defines 12 agility principles for those who
 want to achieve agility: 
1. Our highest priority is to satisfy the customer through early and continuous
 delivery of valuable software.
 2. Welcome changing requirements, even late in development. Agile processes
 harness change for the customer’s competitive advantage.
 3. Deliver working software frequently, from a couple of weeks to a couple of
 months, with a preference to the shorter timescale.
 4. Business people and developers must work together daily throughout the
 project.
 5. Build projects around motivated individuals. Give them the environment and
 support they need, and trust them to get the job done.
 6. The most efficient and effective method of conveying information to and
 within a development team is face-to-face conversation.
 7. Working software is the primary measure of progress.
 8. Agile processes promote sustainable development. The sponsors, developers,
 and users should be able to maintain a constant pace indefinitely.
70
 PART ONE THE SOFTWARE PROCESS
 9. Continuous attention to technical excellence and good design enhances
 agility.
 10. Simplicity—the art of maximizing the amount of work not done—is 
essential.
 11. The best architectures, requirements, and designs emerge from self
organizing teams.
 12. At regular intervals, the team reflects on how to become more effective, then
 tunes and adjusts its behavior accordingly.
 Not every agile process model applies these 12 principles with equal weight, and
 some models choose to ignore (or at least downplay) the importance of one or more
 of the principles. However, the principles define an agile spirit that is maintained in
 each of the process models presented in this chapter.
 3.3.2 The Politics of Agile Development
 You don’t have to
 choose between agility
 and software engi
neering. Rather, define
 a software engineering
 approach that is agile.
 There is considerable debate (sometimes strident) about the benefits and applicabil
ity of agile software development as opposed to more conventional software engi
neering processes. Jim Highsmith [Hig02a] (facetiously) states the extremes when he
 characterizes the feeling of the pro-agility camp (“agilists”). “Traditional methodolo
gists are a bunch of stick-in-the-muds who’d rather produce flawless documentation
 than a working system that meets business needs.” As a counterpoint, he states
 (again, facetiously) the position of the traditional software engineering camp: “Light
weight, er, ‘agile’ methodologists are a bunch of glorified hackers who are going to
 be in for a heck of a surprise when they try to scale up their toys into enterprise-wide
 software.”
 Like all software technology arguments, this methodology debate risks degener
ating into a religious war. If warfare breaks out, rational thought disappears and
 beliefs rather than facts guide decision making.
 No one is against agility. The real question is: What is the best way to achieve it?
 As important, how do you build software that meets customers’ needs today and
 exhibits the quality characteristics that will enable it to be extended and scaled to
 meet customers’ needs over the long term?
 There are no absolute answers to either of these questions. Even within the agile
 school itself, there are many proposed process models (Section 3.4), each with a
 subtly different approach to the agility problem. Within each model there is a set of
 “ideas” (agilists are loath to call them “work tasks”) that represent a significant
 departure from traditional software engineering. And yet, many agile concepts are
 simply adaptations of good software engineering concepts. Bottom line: there is
 much that can be gained by considering the best of both schools and virtually
 nothing to be gained by denigrating either approach.
 If you have further interest, see [Hig01], [Hig02a], and [DeM02] for an entertain
ing summary of other important technical and political issues.
71
 CHAPTER 3 AGILE DEVELOPMENT
 uote:
 “Agile methods
 derive much of
 their agility by
 relying on the
 tacit knowledge
 embodied in the
 team, rather than
 writing the
 knowledge down
 in plans.”
 Barry Boehm
 ?
 What key
 traits must
 exist among the
 people on an
 effective software
 team?
 uote:
 “What counts as
 barely sufficient
 for one team is
 either overly
 sufficient or
 insufficient for
 another.”
 Alistair
 Cockburn
 3.3.3 Human Factors
 Proponents of agile software development take great pains to emphasize the impor
tance of “people factors.” As Cockburn and Highsmith [Coc01a] state, “Agile devel
opment focuses on the talents and skills of individuals, molding the process to
 specific people and teams.” The key point in this statement is that the process molds
 to the needs of the people and team, not the other way around.2
 If members of the software team are to drive the characteristics of the process that
 is applied to build software, a number of key traits must exist among the people on
 an agile team and the team itself:
 Competence. In an agile development (as well as software engineering)
 context, “competence” encompasses innate talent, specific software-related
 skills, and overall knowledge of the process that the team has chosen to
 apply. Skill and knowledge of process can and should be taught to all people
 who serve as agile team members.
 Common focus. Although members of the agile team may perform differ
ent tasks and bring different skills to the project, all should be focused on one
 goal—to deliver a working software increment to the customer within the
 time promised. To achieve this goal, the team will also focus on continual
 adaptations (small and large) that will make the process fit the needs of the
 team.
 Collaboration. Software engineering (regardless of process) is about as
sessing, analyzing, and using information that is communicated to the soft
ware team; creating information that will help all stakeholders understand
 the work of the team; and building information (computer software and rele
vant databases) that provides business value for the customer. To accomplish
 these tasks, team members must collaborate—with one another and all other
 stakeholders.
 Decision-making ability. Any good software team (including agile teams)
 must be allowed the freedom to control its own destiny. This implies that the
 team is given autonomy—decision-making authority for both technical and
 project issues.
 Fuzzy problem-solving ability. Software managers must recognize that
 the agile team will continually have to deal with ambiguity and will continu
ally be buffeted by change. In some cases, the team must accept the fact that
 the problem they are solving today may not be the problem that needs to be
 solved tomorrow. However, lessons learned from any problem-solving
 2 Successful software engineering organizations recognize this reality regardless of the process
 model they choose.
72
 PART ONE THE SOFTWARE PROCESS
 A self-organizing team
 is in control of the
 work it performs. The
 team makes its own
 commitments and
 defines plans to
 achieve them.
 activity (including those that solve the wrong problem) may be of benefit to
 the team later in the project.
 Mutual trust and respect. The agile team must become what DeMarco
 and Lister [DeM98] call a “jelled” team (Chapter 24). A jelled team exhibits
 the trust and respect that are necessary to make them “so strongly knit that
 the whole is greater than the sum of the parts.” [DeM98]
 Self-organization. In the context of agile development, self-organization
 implies three things: (1) the agile team organizes itself for the work to be
 done, (2) the team organizes the process to best accommodate its local envi
ronment, (3) the team organizes the work schedule to best achieve delivery
 of the software increment. Self-organization has a number of technical bene
fits, but more importantly, it serves to improve collaboration and boost team
 morale. In essence, the team serves as its own management. Ken Schwaber
 [Sch02] addresses these issues when he writes: “The team selects how much
 work it believes it can perform within the iteration, and the team commits to
 the work. Nothing demotivates a team as much as someone else making
 commitments for it. Nothing motivates a team as much as accepting the
 responsibility for fulfilling commitments that it made itself.”
 3.4 EXTREME PROGRAMMING (XP)
 In order to illustrate an agile process in a bit more detail, I’ll provide you with an
 overview of Extreme Programming (XP), the most widely used approach to agile soft
ware development. Although early work on the ideas and methods associated with
 XP occurred during the late 1980s, the seminal work on the subject has been written
 by Kent Beck [Bec04a]. More recently, a variant of XP, called Industrial XP (IXP) has
 been proposed [Ker05]. IXP refines XP and targets the agile process specifically for
 use within large organizations.
 3.4.1 XP Values
 Beck [Bec04a] defines a set of five values that establish a foundation for all work per
formed as part of XP—communication, simplicity, feedback, courage, and respect. Each
 of these values is used as a driver for specific XP activities, actions, and tasks.
 In order to achieve effective communication between software engineers and
 other stakeholders (e.g., to establish required features and functions for the soft
ware), XP emphasizes close, yet informal (verbal) collaboration between customers
 and developers, the establishment of effective metaphors3 for communicating
 important concepts, continuous feedback, and the avoidance of voluminous docu
mentation as a communication medium.
 3 In the XP context, a metaphor is “a story that everyone—customers, programmers, and managers—
 can tell about how the system works” [Bec04a].
73
 CHAPTER 3 AGILE DEVELOPMENT
 Keep it simple
 whenever you can, but
 recognize that
 continual “refactoring”
 can absorb significant
 time and resources.
 uote:
 “XP is the answer
 to the question,
 ‘How little can we
 do and still build
 great software?’“
 Anonymous
 WebRef
 An excellent overview
 of “rules” for XP can
 be found at www
 .extremeprogramm
 ing.org/rules.html.
 To achieve simplicity, XP restricts developers to design only for immediate needs,
 rather than consider future needs. The intent is to create a simple design that can be
 easily implemented in code). If the design must be improved, it can be refactored4 at
 a later time.
 Feedback is derived from three sources: the implemented software itself, the
 customer, and other software team members. By designing and implementing an
 effective testing strategy (Chapters 17 through 20), the software (via test results) pro
vides the agile team with feedback. XP makes use of the unit test as its primary test
ing tactic. As each class is developed, the team develops a unit test to exercise each
 operation according to its specified functionality. As an increment is delivered to a
 customer, the user stories or use cases (Chapter 5) that are implemented by the
 increment are used as a basis for acceptance tests. The degree to which the software
 implements the output, function, and behavior of the use case is a form of feedback.
 Finally, as new requirements are derived as part of iterative planning, the team pro
vides the customer with rapid feedback regarding cost and schedule impact.
 Beck [Bec04a] argues that strict adherence to certain XP practices demands
 courage. A better word might be discipline. For example, there is often significant
 pressure to design for future requirements. Most software teams succumb, arguing
 that “designing for tomorrow” will save time and effort in the long run. An agile XP
 team must have the discipline (courage) to design for today, recognizing that future
 requirements may change dramatically, thereby demanding substantial rework of
 the design and implemented code.
 By following each of these values, the agile team inculcates respect among it
 members, between other stakeholders and team members, and indirectly, for the
 software itself. As they achieve successful delivery of software increments, the team
 develops growing respect for the XP process.
 3.4.2 The XP Process
 Extreme Programming uses an object-oriented approach (Appendix 2) as its pre
ferred development paradigm and encompasses a set of rules and practices that
 occur within the context of four framework activities: planning, design, coding, and
 testing. Figure 3.2 illustrates the XP process and notes some of the key ideas and
 tasks that are associated with each framework activity. Key XP activities are sum
marized in the paragraphs that follow.
 Planning. The planning activity (also called the planning game) begins with
 listening—a requirements gathering activity that enables the technical members of
 the XP team to understand the business context for the software and to get a broad
 4 Refactoring allows a software engineer to improve the internal structure of a design (or source
 code) without changing its external functionality or behavior. In essence, refactoring can be used
 to improve the efficiency, readability, or performance of a design or the code that implements a
 design.
74
 PART ONE THE SOFTWARE PROCESS
 FIGURE 3.2
 The Extreme
 Programming
 process
 ?
 What is an
 XP “story”?
 WebRef
 A worthwhile XP
 “planning game” can
 be found at:
 c2.com/cgi/
 wiki?planningGame.
 simple design
 CRC cards
 user stories
 values
 acceptance test criteria
 iteration plan
 Release
 spike solutions
 prototypes
 refactoring
 design
 pair programming
 planning
 software increment
 project velocity computed
 unit test
 continuous integration
 acceptance testing
 test
 coding
 feel for required output and major features and functionality. Listening leads to the
 creation of a set of “stories” (also called user stories) that describe required output,
 features, and functionality for software to be built. Each story (similar to use cases
 described in Chapter 5) is written by the customer and is placed on an index card.
 The customer assigns a value (i.e., a priority) to the story based on the overall busi
ness value of the feature or function.5 Members of the XP team then assess each
 story and assign a cost—measured in development weeks—to it. If the story is esti
mated to require more than three development weeks, the customer is asked to split
 the story into smaller stories and the assignment of value and cost occurs again. It
 is important to note that new stories can be written at any time.
 Customers and developers work together to decide how to group stories into the
 next release (the next software increment) to be developed by the XP team. Once a
 basic commitment (agreement on stories to be included, delivery date, and other
 project matters) is made for a release, the XP team orders the stories that will be de
veloped in one of three ways: (1) all stories will be implemented immediately (within
 a few weeks), (2) the stories with highest value will be moved up in the schedule and
 implemented first, or (3) the riskiest stories will be moved up in the schedule and
 implemented first.
 After the first project release (also called a software increment) has been deliv
ered, the XP team computes project velocity. Stated simply, project velocity is the
 5 The value of a story may also be dependent on the presence of another story.
75
 CHAPTER 3 AGILE DEVELOPMENT
 Project velocity is a
 subtle measure of
 team productivity.
 XP deemphasizes the
 importance of design.
 Not everyone agrees.
 In fact, there are times
 when design should be
 emphasized.
 WebRef
 Refactoring techniques
 and tools can be
 found at:
 www.refactoring
 .com.
 number of customer stories implemented during the first release. Project velocity can
 then be used to (1) help estimate delivery dates and schedule for subsequent releases
 and (2) determine whether an overcommitment has been made for all stories across
 the entire development project. If an overcommitment occurs, the content of releases
 is modified or end delivery dates are changed.
 As development work proceeds, the customer can add stories, change the value
 of an existing story, split stories, or eliminate them. The XP team then reconsiders all
 remaining releases and modifies its plans accordingly.
 Design. XP design rigorously follows the KIS (keep it simple) principle. A simple
 design is always preferred over a more complex representation. In addition, the de
sign provides implementation guidance for a story as it is written—nothing less,
 nothing more. The design of extra functionality (because the developer assumes it
 will be required later) is discouraged.6
 XP encourages the use of CRC cards (Chapter 7) as an effective mechanism for
 thinking about the software in an object-oriented context. CRC (class-responsibility
collaborator) cards identify and organize the object-oriented classes7 that are rele
vant to the current software increment. The XP team conducts the design exercise
 using a process similar to the one described in Chapter 8. The CRC cards are the only
 design work product produced as part of the XP process.
 If a difficult design problem is encountered as part of the design of a story, XP rec
ommends the immediate creation of an operational prototype of that portion of the
 design. Called a spike solution, the design prototype is implemented and evaluated.
 The intent is to lower risk when true implementation starts and to validate the orig
inal estimates for the story containing the design problem.
 In the preceding section, we noted that XP encourages refactoring—a construction
 technique that is also a method for design optimization. Fowler [Fow00] describes
 refactoring in the following manner:
 Refactoring is the process of changing a software system in such a way that it does not
 alter the external behavior of the code yet improves the internal structure. It is a disci
plined way to clean up code [and modify/simplify the internal design] that minimizes the
 chances of introducing bugs. In essence, when you refactor you are improving the design
 of the code after it has been written.
 Because XP design uses virtually no notation and produces few, if any, work prod
ucts other than CRC cards and spike solutions, design is viewed as a transient arti
fact that can and should be continually modified as construction proceeds. The intent
 of refactoring is to control these modifications by suggesting small design changes
 6 These design guidelines should be followed in every software engineering method, although there
 are times when sophisticated design notation and terminology may get in the way of simplicity.
 7 Object-oriented classes are discussed in Appendix 2, in Chapter 8, and throughout Part 2 of this
 book.
76
 PART ONE THE SOFTWARE PROCESS
 Refactoring improves
 the internal structure of
 a design (or source
 code) without
 changing its external
 functionality or
 behavior.
 WebRef
 Useful information on
 XP can be obtained 
at www
 .xprogramming.
 com.
 ?
 What is 
pair
 programming?
 Many software teams
 are populated by indi
vidualists. You’ll have
 to work to change that
 culture if pair program
ming is to work effec
tively.
 ?
 XP?
 How are unit
 tests used in
 that “can radically improve the design” [Fow00]. It should be noted, however, that
 the effort required for refactoring can grow dramatically as the size of an application
 grows.
 A central notion in XP is that design occurs both before and after coding com
mences. Refactoring means that design occurs continuously as the system is con
structed. In fact, the construction activity itself will provide the XP team with
 guidance on how to improve the design.
 Coding. After stories are developed and preliminary design work is done, the team
 does not move to code, but rather develops a series of unit tests that will exercise
 each of the stories that is to be included in the current release (software increment).8
 Once the unit test9 has been created, the developer is better able to focus on what
 must be implemented to pass the test. Nothing extraneous is added (KIS). Once the
 code is complete, it can be unit-tested immediately, thereby providing instantaneous
 feedback to the developers.
 A key concept during the coding activity (and one of the most talked about aspects
 of XP) is pair programming. XP recommends that two people work together at one
 computer workstation to create code for a story. This provides a mechanism for real
time problem solving (two heads are often better than one) and real-time quality as
surance (the code is reviewed as it is created). It also keeps the developers focused
 on the problem at hand. In practice, each person takes on a slightly different role. For
 example, one person might think about the coding details of a particular portion of
 the design while the other ensures that coding standards (a required part of XP) are
 being followed or that the code for the story will satisfy the unit test that has been
 developed to validate the code against the story.
 As pair programmers complete their work, the code they develop is integrated
 with the work of others. In some cases this is performed on a daily basis by an inte
gration team. In other cases, the pair programmers have integration responsibility.
 This “continuous integration” strategy helps to avoid compatibility and interfacing
 problems and provides a “smoke testing” environment (Chapter 17) that helps to
 uncover errors early.
 Testing. I have already noted that the creation of unit tests before coding com
mences is a key element of the XP approach. The unit tests that are created should
 be implemented using a framework that enables them to be automated (hence, they
 can be executed easily and repeatedly). This encourages a regression testing strat
egy (Chapter 17) whenever code is modified (which is often, given the XP refactor
ing philosophy).
 8 This approach is analogous to knowing the exam questions before you begin to study. It makes
 studying much easier by focusing attention only on the questions that will be asked.
 9 Unit testing, discussed in detail in Chapter 17, focuses on an individual software component, exer
cising the component’s interface, data structures, and functionality in an effort to uncover errors
 that are local to the component.
77
 CHAPTER 3 AGILE DEVELOPMENT
 XP acceptance tests
 are derived from user
 stories.
 ?
 What new
 practices are
 appended to XP
 to create IXP?
 uote:
 “Ability is what
 you’re capable of
 doing. Motivation
 determines what
 you do. Attitude
 determines how
 well you do it.”
 Lou Holtz
 As the individual unit tests are organized into a “universal testing suite” [Wel99],
 integration and validation testing of the system can occur on a daily basis. This pro
vides the XP team with a continual indication of progress and also can raise warn
ing flags early if things go awry. Wells [Wel99] states: “Fixing small problems every
 few hours takes less time than fixing huge problems just before the deadline.”
 XP acceptance tests, also called customer tests, are specified by the customer and
 focus on overall system features and functionality that are visible and reviewable by
 the customer. Acceptance tests are derived from user stories that have been imple
mented as part of a software release.
 3.4.3 Industrial XP
 Joshua Kerievsky [Ker05] describes Industrial Extreme Programming (IXP) in the fol
lowing manner: “IXP is an organic evolution of XP. It is imbued with XP’s minimal
ist, customer-centric, test-driven spirit. IXP differs most from the original XP in its
 greater inclusion of management, its expanded role for customers, and its upgraded
 technical practices.” IXP incorporates six new practices that are designed to help
 ensure that an XP project works successfully for significant projects within a large
 organization.
 Readiness assessment. Prior to the initiation of an IXP project, the organ
ization should conduct a readiness assessment. The assessment ascertains
 whether (1) an appropriate development environment exists to support IXP,
 (2) the team will be populated by the proper set of stakeholders, (3) the or
ganization has a distinct quality program and supports continuous improve
ment, (4) the organizational culture will support the new values of an agile
 team, and (5) the broader project community will be populated appropriately.
 Project community. Classic XP suggests that the right people be used to
 populate the agile team to ensure success. The implication is that people on
 the team must be well-trained, adaptable and skilled, and have the proper
 temperament to contribute to a self-organizing team. When XP is to be
 applied for a significant project in a large organization, the concept of the
 “team” should morph into that of a community. A community may have a
 technologist and customers who are central to the success of a project as
 well as many other stakeholders (e.g., legal staff, quality auditors, manufac
turing or sales types) who “are often at the periphery of an IXP project yet
 they may play important roles on the project” [Ker05]. In IXP, the community
 members and their roles should be explicitly defined and mechanisms for
 communication and coordination between community members should be
 established.
 Project chartering. The IXP team assesses the project itself to determine
 whether an appropriate business justification for the project exists and
 whether the project will further the overall goals and objectives of the
78
 PART ONE THE SOFTWARE PROCESS
 organization. Chartering also examines the context of the project to deter
mine how it complements, extends, or replaces existing systems or
 processes.
 Test-driven management. An IXP project requires measurable criteria for
 assessing the state of the project and the progress that has been made to
 date. Test-driven management establishes a series of measurable “destina
tions” [Ker05] and then defines mechanisms for determining whether or not
 these destinations have been reached.
 Retrospectives. An IXP team conducts a specialized technical review
 (Chapter 15) after a software increment is delivered. Called a retrospective,
 the review examines “issues, events, and lessons-learned” [Ker05] across a
 software increment and/or the entire software release. The intent is to
 improve the IXP process.
 Continuous learning. Because learning is a vital part of continuous
 process improvement, members of the XP team are encouraged (and possi
bly, incented) to learn new methods and techniques that can lead to a higher
quality product.
 In addition to the six new practices discussed, IXP modifies a number of existing
 XP practices. Story-driven development (SDD) insists that stories for acceptance tests
 be written before a single line of code is generated. Domain-driven design (DDD) is
 an improvement on the “system metaphor” concept used in XP. DDD [Eva03] sug
gests the evolutionary creation of a domain model that “accurately represents how
 domain experts think about their subject” [Ker05]. Pairing extends the XP pair
programming concept to include managers and other stakeholders. The intent is to
 improve knowledge sharing among XP team members who may not be directly in
volved in technical development. Iterative usability discourages front-loaded inter
face design in favor of usability design that evolves as software increments are
 delivered and users’ interaction with the software is studied.
 IXP makes smaller modifications to other XP practices and redefines certain roles
 and responsibilities to make them more amenable to significant projects for large
 organizations. For further discussion of IXP, visit http://industrialxp.org.
 3.4.4 The XP Debate
 All new process models and methods spur worthwhile discussion and in some in
stances heated debate. Extreme Programming has done both. In an interesting book
 that examines the efficacy of XP, Stephens and Rosenberg [Ste03] argue that many
 XP practices are worthwhile, but others have been overhyped, and a few are prob
lematic. The authors suggest that the codependent nature of XP practices are both
 its strength and its weakness. Because many organizations adopt only a subset of XP
 practices, they weaken the efficacy of the entire process. Proponents counter that
 XP is continuously evolving and that many of the issues raised by critics have been
79
 CHAPTER 3 AGILE DEVELOPMENT
 addressed as XP practice matures. Among the issues that continue to trouble some
 critics of XP are:10
 ?
 What are
 some of the
 issues that lead to
 an XP debate?
 • Requirements volatility. Because the customer is an active member of the XP
 team, changes to requirements are requested informally. As a consequence,
 the scope of the project can change and earlier work may have to be
 modified to accommodate current needs. Proponents argue that this happens
 regardless of the process that is applied and that XP provides mechanisms for
 controlling scope creep.
 • Conflicting customer needs. Many projects have multiple customers, each with
 his own set of needs. In XP, the team itself is tasked with assimilating the
 needs of different customers, a job that may be beyond their scope of
 authority.
 • Requirements are expressed informally. User stories and acceptance tests are
 the only explicit manifestation of requirements in XP. Critics argue that a
 more formal model or specification is often needed to ensure that omissions,
 inconsistencies, and errors are uncovered before the system is built. Propo
nents counter that the changing nature of requirements makes such models
 and specification obsolete almost as soon as they are developed.
 • Lack of formal design. XP deemphasizes the need for architectural design and
 in many instances, suggests that design of all kinds should be relatively
 informal. Critics argue that when complex systems are built, design must be
 emphasized to ensure that the overall structure of the software will exhibit
 quality and maintainability. XP proponents suggest that the incremental
 nature of the XP process limits complexity (simplicity is a core value) and
 therefore reduces the need for extensive design.
 You should note that every software process has flaws and that many software or
ganizations have used XP successfully. The key is to recognize where a process may
 have weaknesses and to adapt it to the specific needs of your organization.
 SAFEHOME
 Considering Agile Software Development
 The scene: Doug Miller’s office.
 The Players: Doug Miller, software engineering
 manager; Jamie Lazar, software team member; Vinod
 Raman, software team member.
 The conversation:
 (A knock on the door, Jamie and Vinod enter Doug’s office)
 Jamie: Doug, you got a minute?
 10 For a detailed look at some thoughtful criticism that has been leveled at XP, visit
 www.softwarereality.com/ExtremeProgramming.jsp.
3.5 OTHERAGILEPROCESSMODELS
 The history of software engineering is littered with dozens of obsolete process
 descriptions and methodologies, modeling methods and notations, tools, and
 technology. Each flared in notoriety and was then eclipsed by something new and
 (purportedly) better. With the introduction of a wide array of agile process models—
 each contending for acceptance within the software development community—the
 agile movement is following the same historical path.11
 As I noted in the last section, the most widely used of all agile process models
 isExtreme Programming (XP). But many other agile process models have been
 proposed and are in use across the industry. Among the most common are:
 •Adaptive Software Development (ASD)
 •Scrum
 •Dynamic Systems Development Method (DSDM)
 80 PART ONE THE SOFTWARE PROCESS
 Doug: Sure Jamie, what’s up?
 Jamie:We’ve been thinking about our process
 discussion yesterday . . . you know, what process we’re
 going to choose for this new SafeHomeproject.
 Doug:And?
 Vinod: I was talking to a friend at another company,
 and he was telling me about Extreme Programming. It’s
 an agile process model . . . heard of it?
 Doug: Yeah, some good, some bad.
 Jamie:Well, it sounds pretty good to us. Lets you
 develop software really fast, uses something called pair
 programming to do real-time quality checks . . . it’s pretty
 cool, I think.
 Doug: It does have a lot of really good ideas. I like the
 pair-programming concept, for instance, and the idea
 that stakeholders should be part of the team.
 Jamie:Huh? You mean that marketing will work on the
 project team with us?
 Doug (nodding): They’re a stakeholder, aren’t they?
 Jamie: Jeez . . . they’ll be requesting changes every five
 minutes.
 Vinod:Not necessarily. My friend said that there are
 ways to “embrace” changes during an XP project.
 Doug: So you guys think we should use XP?
 Jamie: It’s definitely worth considering.
 Doug: I agree. And even if we choose an incremental
 model as our approach, there’s no reason why we can’t
 incorporate much of what XP has to offer.
 Vinod:Doug, before you said “some good, some bad.”
 What was the “bad”?
 Doug: The thing I don’t like is the way XP downplays
 analysis and design . . . sort of says that writing code is
 where the action is . . . 
(The team members look at one another and smile.)
 Doug: So you agree with the XP approach?
 Jamie (speaking for both):Writing code is what
 we do, Boss!
 Doug (laughing): True, but I’d like to see you spend a
 little less time coding and then recoding and a little more
 time analyzing what has to be done and designing a
 solution that works.
 Vinod:Maybe we can have it both ways, agility with a
 little discipline.
 Doug: I think we can, Vinod. In fact, I’m sure of it.
 uote:
 “Our profession
 goes through
 methodologies like
 a 14-year-old goes
 through clothing.”
 Stephen
 Hawrysh and
 JimRuprecht
 11This is not a bad thing. Before one or more models or methods are accepted as a de facto standard,
 all must contend for the hearts and minds of software engineers. The “winners” evolve into best
 practice, while the “losers” either disappear or merge with the winning models.
81
 CHAPTER 3 AGILE DEVELOPMENT
 • Crystal
 • Feature Drive Development (FDD)
 • Lean Software Development (LSD)
 • Agile Modeling (AM)
 • Agile Unified Process (AUP)
 In the sections that follow, I present a very brief overview of each of these agile
 process models. It is important to note that all agile process models conform (to a
 greater or lesser degree) to the Manifesto for Agile Software Development and the prin
ciples noted in Section 3.3.1. For additional detail, refer to the references noted in
 each subsection or for a survey, examine the “agile software development” entry
 in Wikipedia.12
 3.5.1 Adaptive Software Development (ASD)
 WebRef
 Useful resources for
 ASD can be found at
 www.adaptivesd
 .com.
 Adaptive Software Development (ASD) has been proposed by Jim Highsmith [Hig00] as
 a technique for building complex software and systems. The philosophical under
pinnings of ASD focus on human collaboration and team self-organization.
 Highsmith argues that an agile, adaptive development approach based on collab
oration is “as much a source of order in our complex interactions as discipline and
 engineering.” He defines an ASD “life cycle” (Figure 3.3) that incorporates three
 phases, speculation, collaboration, and learning.
 FIGURE 3.3
 Adaptive
 software
 development
 adaptive cycle planning
 mission statement
 project constraints
 basic requirements
 time-boxed release plan
 Release
 Requirements gathering
 JAD
 mini-specs
 speculation
 software increment
 adjustments for subsequent cycles
 collaboration
 components implemented/tested
 focus groups for feedback
 formal technical reviews
 learning
 postmortems
 12 See http://en.wikipedia.org/wiki/Agile_software_development#Agile_methods.
82
 PART ONE THE SOFTWARE PROCESS
 Effective collaboration
 with your customer will
 only occur if you
 jettison any “us and
 them” attitudes.
 ASD emphasizes
 learning as a key
 element in achieving 
a “self-organizing”
 team.
 WebRef
 Useful Scrum
 information and
 resources can be found
 at www
 .controlchaos.com.
 During speculation, the project is initiated and adaptive cycle planning is con
ducted. Adaptive cycle planning uses project initiation information—the customer’s
 mission statement, project constraints (e.g., delivery dates or user descriptions), and
 basic requirements—to define the set of release cycles (software increments) that
 will be required for the project.
 No matter how complete and farsighted the cycle plan, it will invariably change.
 Based on information obtained at the completion of the first cycle, the plan is re
viewed and adjusted so that planned work better fits the reality in which an ASD
 team is working.
 Motivated people use collaboration in a way that multiplies their talent and cre
ative output beyond their absolute numbers. This approach is a recurring theme in
 all agile methods. But collaboration is not easy. It encompasses communication and
 teamwork, but it also emphasizes individualism, because individual creativity plays
 an important role in collaborative thinking. It is, above all, a matter of trust. People
 working together must trust one another to (1) criticize without animosity, (2) assist
 without resentment, (3) work as hard as or harder than they do, (4) have the skill set
 to contribute to the work at hand, and (5) communicate problems or concerns in a
 way that leads to effective action.
 As members of an ASD team begin to develop the components that are part of an
 adaptive cycle, the emphasis is on “learning” as much as it is on progress toward
 a completed cycle. In fact, Highsmith [Hig00] argues that software developers often
 overestimate their own understanding (of the technology, the process, and the proj
ect) and that learning will help them to improve their level of real understanding.
 ASD teams learn in three ways: focus groups (Chapter 5), technical reviews (Chap
ter 14), and project postmortems.
 The ASD philosophy has merit regardless of the process model that is used. ASD’s
 overall emphasis on the dynamics of self-organizing teams, interpersonal collabo
ration, and individual and team learning yield software project teams that have a
 much higher likelihood of success.
 3.5.2 Scrum
 Scrum (the name is derived from an activity that occurs during a rugby match13) is
 an agile software development method that was conceived by Jeff Sutherland and his
 development team in the early 1990s. In recent years, further development on the
 Scrum methods has been performed by Schwaber and Beedle [Sch01a].
 Scrum principles are consistent with the agile manifesto and are used to guide
 development activities within a process that incorporates the following framework
 activities: requirements, analysis, design, evolution, and delivery. Within each
 13 A group of players forms around the ball and the teammates work together (sometimes violently!)
 to move the ball downfield.
every 24
 hours
 30 days
 Scrum: 15 minute daily meeting.
 Team members respond to basics:
 1) What did you do since last Scrum
 meeting?
 2) Do you have any obstacles?
 3) What will you do before next
 meeting?
 Sprint Backlog:
 Feature(s)
 assigned
 to sprint
 Product Backlog:
 Prioritized product features desired by the customer
 Backlog
 items
 expanded
 by team
 New functionality
 is demonstrated
 at end of sprint
 framework activity, work tasks occur within a process pattern (discussed in the fol
lowing paragraph) called a sprint.The work conducted within a sprint (the number
 of sprints required for each framework activity will vary depending on product com
plexity and size) is adapted to the problem at hand and is defined and often modified
 in real time by the Scrum team. The overall flow of the Scrum process is illustrated
 in Figure 3.4.
 Scrum emphasizes the use of a set of software process patterns [Noy02] that have
 proven effective for projects with tight timelines, changing requirements, and business
 criticality. Each of these process patterns defines a set of development actions:
 Backlog—a prioritized list of project requirements or features that provide busi
ness value for the customer. Items can be added to the backlog at any time (this is
 how changes are introduced). The product manager assesses the backlog and
 updates priorities as required.
 Sprints—consist of work units that are required to achieve a requirement de
fined in the backlog that must be fit into a predefined time-box14(typically 30 days).
 CHAPTER 3 AGILE DEVELOPMENT 83
 14A time-boxis a project management term (see Part 4 of this book) that indicates a period of time
 that has been allocated to accomplish some task.
 FIGURE3.4
 Scrum process
 flow
 Scrum incorporates a
 set of process patterns
 that emphasize project
 priorities,
 compartmentalized
 work units,
 communication, and
 frequent customer
 feedback.
84
 PART ONE THE SOFTWARE PROCESS
 Changes (e.g., backlog work items) are not introduced during the sprint. Hence, the
 sprint allows team members to work in a short-term, but stable environment.
 Scrum meetings—are short (typically 15 minutes) meetings held daily by the Scrum
 team. Three key questions are asked and answered by all team members [Noy02]:
 • What did you do since the last team meeting?
 • What obstacles are you encountering?
 • What do you plan to accomplish by the next team meeting?
 A team leader, called a Scrum master, leads the meeting and assesses the responses
 from each person. The Scrum meeting helps the team to uncover potential problems
 as early as possible. Also, these daily meetings lead to “knowledge socialization”
 [Bee99] and thereby promote a self-organizing team structure.
 Demos—deliver the software increment to the customer so that functionality that
 has been implemented can be demonstrated and evaluated by the customer. It is im
portant to note that the demo may not contain all planned functionality, but rather
 those functions that can be delivered within the time-box that was established.
 Beedle and his colleagues [Bee99] present a comprehensive discussion of these pat
terns in which they state: “Scrum assumes up-front the existence of chaos. . . . ” The
 Scrum process patterns enable a software team to work successfully in a world
 where the elimination of uncertainty is impossible.
 3.5.3 Dynamic Systems Development Method (DSDM)
 WebRef
 Useful resources for
 DSSD can be found at
 www.dsdm.org.
 The Dynamic Systems Development Method (DSDM) [Sta97] is an agile software devel
opment approach that “provides a framework for building and maintaining systems
 which meet tight time constraints through the use of incremental prototyping in a con
trolled project environment” [CCS02]. The DSDM philosophy is borrowed from a mod
ified version of the Pareto principle—80 percent of an application can be delivered in
 20 percent of the time it would take to deliver the complete (100 percent) application.
 DSDM is an iterative software process in which each iteration follows the 80 per
cent rule. That is, only enough work is required for each increment to facilitate
 movement to the next increment. The remaining detail can be completed later when
 more business requirements are known or changes have been requested and
 accommodated.
 The DSDM Consortium (www.dsdm.org) is a worldwide group of member com
panies that collectively take on the role of “keeper” of the method. The consortium
 has defined an agile process model, called the DSDM life cycle that defines three dif
ferent iterative cycles, preceded by two additional life cycle activities:
 Feasibility study—establishes the basic business requirements and constraints
 associated with the application to be built and then assesses whether the applica
tion is a viable candidate for the DSDM process.
85
 CHAPTER 3 AGILE DEVELOPMENT
 DSDM is a process
 framework that can
 adopt the tactics of
 another agile approach
 such as XP.
 Crystal is a family of
 process models with
 the same “genetic
 code” but different
 methods for adapting
 to project
 characteristics.
 Business study—establishes the functional and information requirements that
 will allow the application to provide business value; also, defines the basic
 application architecture and identifies the maintainability requirements for the
 application.
 Functional model iteration—produces a set of incremental prototypes that
 demonstrate functionality for the customer. (Note: All DSDM prototypes are in
tended to evolve into the deliverable application.) The intent during this iterative
 cycle is to gather additional requirements by eliciting feedback from users as they
 exercise the prototype.
 Design and build iteration—revisits prototypes built during functional model
 iteration to ensure that each has been engineered in a manner that will enable it to
 provide operational business value for end users. In some cases, functional model
 iteration and design and build iteration occur concurrently.
 Implementation—places the latest software increment (an “operationalized” pro
totype) into the operational environment. It should be noted that (1) the increment
 may not be 100 percent complete or (2) changes may be requested as the incre
ment is put into place. In either case, DSDM development work continues by
 returning to the functional model iteration activity.
 DSDM can be combined with XP (Section 3.4) to provide a combination approach
 that defines a solid process model (the DSDM life cycle) with the nuts and bolts prac
tices (XP) that are required to build software increments. In addition, the ASD con
cepts of collaboration and self-organizing teams can be adapted to a combined
 process model.
 3.5.4 Crystal
 Alistair Cockburn [Coc05] and Jim Highsmith [Hig02b] created the Crystal family of
 agile methods15 in order to achieve a software development approach that puts a
 premium on “maneuverability” during what Cockburn characterizes as “a resource
limited, cooperative game of invention and communication, with a primary goal of
 delivering useful, working software and a secondary goal of setting up for the next
 game” [Coc02].
 To achieve maneuverability, Cockburn and Highsmith have defined a set of
 methodologies, each with core elements that are common to all, and roles, process
 patterns, work products, and practice that are unique to each. The Crystal family is
 actually a set of example agile processes that have been proven effective for differ
ent types of projects. The intent is to allow agile teams to select the member of the
 crystal family that is most appropriate for their project and environment.
 15 The name “crystal” is derived from the characteristics of geological crystals, each with its own
 color, shape, and hardness.
86
 PART ONE THE SOFTWARE PROCESS
 3.5.5 Feature Driven Development (FDD)
 WebRef
 A wide variety of
 articles and
 presentations on FDD
 can be found at:
 www.featuredrive
 ndevelopment
 .com/.
 Feature Driven Development (FDD) was originally conceived by Peter Coad and his
 colleagues [Coa99] as a practical process model for object-oriented software engi
neering. Stephen Palmer and John Felsing [Pal02] have extended and improved
 Coad’s work, describing an adaptive, agile process that can be applied to moderately
 sized and larger software projects.
 Like other agile approaches, FDD adopts a philosophy that (1) emphasizes col
laboration among people on an FDD team; (2) manages problem and project
 complexity using feature-based decomposition followed by the integration of
 software increments, and (3) communication of technical detail using verbal,
 graphical, and text-based means. FDD emphasizes software quality assurance
 activities by encouraging an incremental development strategy, the use of design
 and code inspections, the application of software quality assurance audits (Chap
ter 16), the collection of metrics, and the use of patterns (for analysis, design, and
 construction).
 In the context of FDD, a feature “is a client-valued function that can be imple
mented in two weeks or less” [Coa99]. The emphasis on the definition of features
 provides the following benefits:
 • Because features are small blocks of deliverable functionality, users can
 describe them more easily; understand how they relate to one another more
 readily; and better review them for ambiguity, error, or omissions.
 • Features can be organized into a hierarchical business-related grouping.
 • Since a feature is the FDD deliverable software increment, the team develops
 operational features every two weeks.
 • Because features are small, their design and code representations are easier
 to inspect effectively.
 • Project planning, scheduling, and tracking are driven by the feature
 hierarchy, rather than an arbitrarily adopted software engineering 
task set.
 Coad and his colleagues [Coa99] suggest the following template for defining a
 feature:
 <action> the <result> <by for of to> a(n) <object>
 where an <object> is “a person, place, or thing (including roles, moments in time or
 intervals of time, or catalog-entry-like descriptions).” Examples of features for an 
e-commerce application might be:
 Add the product to shopping cart
 Display the technical-specifications of the product
 Store the shipping-information for the customer
87
 CHAPTER 3 AGILE DEVELOPMENT
 FIGURE 3.5
 Feature Driven
 Development
 [Coa99] (with
 permission)
 Develop
 an
 Overall
 Model
 Build a
 Features
 List
 Plan
 By
 Feature
 Design
 By
 Feature
 (more shape
 than content)
 A list of features
 grouped into sets
 and subject areas
 A development plan
 Class owners
 Feature Set Owners
 A design
 package
 (sequences)
 Build
 By
 Feature
 Completed
 client-value
 function
 A feature set groups related features into business-related categories and is defined
 [Coa99] as:
 <action><-ing> a(n) <object>
 For example: Making a product sale is a feature set that would encompass the fea
tures noted earlier and others.
 The FDD approach defines five “collaborating” [Coa99] framework activities (in
 FDD these are called “processes”) as shown in Figure 3.5.
 FDD provides greater emphasis on project management guidelines and tech
niques than many other agile methods. As projects grow in size and complexity,
 ad hoc project management is often inadequate. It is essential for developers, their
 managers, and other stakeholders to understand project status—what accomplish
ments have been made and problems have been encountered. If deadline pressure
 is significant, it is critical to determine if software increments (features) are properly
 scheduled. To accomplish this, FDD defines six milestones during the design and
 implementation of a feature: “design walkthrough, design, design inspection, code,
 code inspection, promote to build” [Coa99].
 3.5.6 Lean Software Development (LSD)
 Lean Software Development (LSD) has adapted the principles of lean manufacturing
 to the world of software engineering. The lean principles that inspire the LSD process
 can be summarized ([Pop03], [Pop06a]) as eliminate waste, build quality in, create
 knowledge, defer commitment, deliver fast, respect people, and optimize the whole.
 Each of these principles can be adapted to the software process. For example,
 eliminate waste within the context of an agile software project can be interpreted
 to mean [Das05]: (1) adding no extraneous features or functions, (2) assessing the
 cost and schedule impact of any newly requested requirement, (3) removing any
 superfluous process steps, (4) establishing mechanisms to improve the way team
 members find information, (5) ensuring the testing finds as many errors as possible,
88
 PART ONE THE SOFTWARE PROCESS
 (6) reducing the time required to request and get a decision that affects the software
 or the process that is applied to create it, and (7) streamlining the manner in which
 information is transmitted to all stakeholders involved in the process.
 For a detailed discussion of LSD and pragmatic guidelines for implementing the
 process, you should examine [Pop06a] and [Pop06b].
 3.5.7 Agile Modeling (AM)
 WebRef
 Comprehensive
 information on agile
 modeling can be found
 at: www
 .agilemodeling.com.
 uote:
 “I was in the drug
 store the other day
 trying to get a cold
 medication . . . not
 easy. There’s an
 entire wall of
 products you need.
 You stand there
 going, Well, this
 one is quick acting
 but this is long
 lasting. . . . Which
 is more important,
 the present or the
 future?”
 Jerry Seinfeld
 There are many situations in which software engineers must build large, business
critical systems. The scope and complexity of such systems must be modeled so that
 (1) all constituencies can better understand what needs to be accomplished, (2) the
 problem can be partitioned effectively among the people who must solve it, and
 (3) quality can be assessed as the system is being engineered and built.
 Over the past 30 years, a wide variety of software engineering modeling methods
 and notation have been proposed for analysis and design (both architectural and
 component-level). These methods have merit, but they have proven to be difficult
 to apply and challenging to sustain (over many projects). Part of the problem is the
 “weight” of these modeling methods. By this I mean the volume of notation required,
 the degree of formalism suggested, the sheer size of the models for large projects,
 and the difficulty in maintaining the model(s) as changes occur. Yet analysis and de
sign modeling have substantial benefit for large projects—if for no other reason than
 to make these projects intellectually manageable. Is there an agile approach to soft
ware engineering modeling that might provide an alternative?
 At “The Official Agile Modeling Site,” Scott Ambler [Amb02a] describes agile mod
eling (AM) in the following manner:
 Agile Modeling (AM) is a practice-based methodology for effective modeling and documen
tation of software-based systems. Simply put, Agile Modeling (AM) is a collection of values,
 principles, and practices for modeling software that can be applied on a software develop
ment project in an effective and light-weight manner. Agile models are more effective than
 traditional models because they are just barely good, they don’t have to be perfect.
 Agile modeling adopts all of the values that are consistent with the agile manifesto.
 The agile modeling philosophy recognizes that an agile team must have the courage
 to make decisions that may cause it to reject a design and refactor. The team must
 also have the humility to recognize that technologists do not have all the answers and
 that business experts and other stakeholders should be respected and embraced.
 Although AM suggests a wide array of “core” and “supplementary” modeling prin
ciples, those that make AM unique are [Amb02a]:
 Model with a purpose. A developer who uses AM should have a specific
 goal (e.g., to communicate information to the customer or to help better un
derstand some aspect of the software) in mind before creating the model.
 Once the goal for the model is identified, the type of notation to be used and
 level of detail required will be more obvious.
89
 CHAPTER 3 AGILE DEVELOPMENT
 Use multiple models. There are many different models and notations that
 can be used to describe software. Only a small subset is essential for most
 projects. AM suggests that to provide needed insight, each model should
 present a different aspect of the system and only those models that provide
 value to their intended audience should be used.
 “Traveling light” is an
 appropriate philosophy
 for all software engi
neering work. Build
 only those models that
 provide value … no
 more, no less.
 Travel light. As software engineering work proceeds, keep only those mod
els that will provide long-term value and jettison the rest. Every work product
 that is kept must be maintained as changes occur. This represents work that
 slows the team down. Ambler [Amb02a] notes that “Every time you decide to
 keep a model you trade-off agility for the convenience of having that informa
tion available to your team in an abstract manner (hence potentially enhanc
ing communication within your team as well as with project stakeholders).”
 Content is more important than representation. Modeling should im
part information to its intended audience. A syntactically perfect model that
 imparts little useful content is not as valuable as a model with flawed nota
tion that nevertheless provides valuable content for its audience.
 Know the models and the tools you use to create them. Understand
 the strengths and weaknesses of each model and the tools that are used to
 create it.
 Adapt locally. The modeling approach should be adapted to the needs of
 the agile team.
 A major segment of the software engineering community has adopted the Unified
 Modeling Language (UML)16 as the preferred method for representing analysis and
 design models. The Unified Process (Chapter 2) has been developed to provide a
 framework for the application of UML. Scott Ambler [Amb06] has developed a sim
plified version of the UP that integrates his agile modeling philosophy.
 3.5.8 Agile Unified Process (AUP)
 The Agile Unified Process (AUP) adopts a “serial in the large” and “iterative in the
 small” [Amb06] philosophy for building computer-based systems. By adopting the
 classic UP phased activities—inception, elaboration, construction, and transition—AUP
 provides a serial overlay (i.e., a linear sequence of software engineering activities)
 that enables a team to visualize the overall process flow for a software project. How
ever, within each of the activities, the team iterates to achieve agility and to deliver
 meaningful software increments to end users as rapidly as possible. Each AUP iter
ation addresses the following activities [Amb06]: 
• Modeling. UML representations of the business and problem domains are
 created. However, to stay agile, these models should be “just barely good
 enough” [Amb06] to allow the team to proceed.
 16 A brief tutorial on UML is presented in Appendix 1.
90
 PART ONE THE SOFTWARE PROCESS
 • Implementation. Models are translated into source code.
 • Testing. Like XP, the team designs and executes a series of tests to uncover
 errors and ensure that the source code meets its requirements.
 • Deployment. Like the generic process activity discussed in Chapters 1 and 2,
 deployment in this context focuses on the delivery of a software increment
 and the acquisition of feedback from end users.
 • Configuration and project management. In the context of AUP, configuration
 management (Chapter 22) addresses change management, risk manage
ment, and the control of any persistent work products17 that are produced by
 the team. Project management tracks and controls the progress of the team
 and coordinates team activities.
 • Environment management. Environment management coordinates a process
 infrastructure that includes standards, tools, and other support technology
 available to the team.
 Although the AUP has historical and technical connections to the Unified Modeling
 Language, it is important to note that UML modeling can be using in conjunction
 with any of the agile process models described in Section 3.5.
 SOFTWARE TOOLS
 Agile Development
 Objective: The objective of agile development
 tools is to assist in one or more aspects of agile
 development with an emphasis on facilitating the rapid
 generation of operational software. These tools can also
 be used when prescriptive process models (Chapter 2) are
 applied.
 Mechanics: Tool mechanics vary. In general, agile tool
 sets encompass automated support for project planning,
 use case development and requirements gathering, rapid
 design, code generation, and testing.
 Representative Tools:18
 Note: Because agile development is a hot topic, most
 software tools vendors purport to sell tools that support 
the agile approach. The tools noted here have
 characteristics that make them particularly useful for
 agile projects.
 OnTime, developed by Axosoft (www.axosoft.com),
 provides agile process management support for
 various technical activities within the process.
 Ideogramic UML, developed by Ideogramic
 (www.ideogramic.com) is a UML tool set
 specifically developed for use within an agile 
process.
 Together Tool Set, distributed by Borland
 (www.borland.com), provides a tools suite that
 supports many technical activities within XP and other
 agile processes.
 17 A persistent work product is a model or document or test case produced by the team that will be kept
 for an indeterminate period of time. It will not be discarded once the software increment is
 delivered.
 18 Tools noted here do not represent an endorsement, but rather a sampling of tools in this category.
 In most cases, tool names are trademarked by their respective developers.
91
 CHAPTER 3 AGILE DEVELOPMENT
 3.6 A TOOL SET FOR THE AGILE PROCESS
 The “tool set” that
 supports agile
 processes focuses
 more on people issues
 than it does on
 technology issues.
 Some proponents of the agile philosophy argue that automated software tools (e.g.,
 design tools) should be viewed as a minor supplement to the team’s activities, and
 not at all pivotal to the success of the team. However, Alistair Cockburn [Coc04] sug
gests that tools can have a benefit and that “agile teams stress using tools that per
mit the rapid flow of understanding. Some of those tools are social, starting even at
 the hiring stage. Some tools are technological, helping distributed teams simulate
 being physically present. Many tools are physical, allowing people to manipulate
 them in workshops.”
 Because acquiring the right people (hiring), team collaboration, stakeholder com
munication, and indirect management are key elements in virtually all agile process
 models, Cockburn argues that “tools” that address these issues are critical success
 factors for agility. For example, a hiring “tool” might be the requirement to have a
 prospective team member spend a few hours pair programming with an existing
 member of the team. The “fit” can be assessed immediately.
 Collaborative and communication “tools” are generally low tech and incorporate
 any mechanism (“physical proximity, whiteboards, poster sheets, index cards, and
 sticky notes” [Coc04]) that provides information and coordination among agile de
velopers. Active communication is achieved via the team dynamics (e.g., pair pro
gramming), while passive communication is achieved by “information radiators”
 (e.g., a flat panel display that presents the overall status of different components of
 an increment). Project management tools deemphasize the Gantt chart and replace
 it with earned value charts or “graphs of tests created versus passed . . . other agile
 tools are used to optimize the environment in which the agile team works (e.g., more
 efficient meeting areas), improve the team culture by nurturing social interactions
 (e.g., collocated teams), physical devices (e.g., electronic whiteboards), and process
 enhancement (e.g., pair programming or time-boxing)” [Coc04].
 Are any of these things really tools? They are, if they facilitate the work performed
 by an agile team member and enhance the quality of the end product.
 3.7 SUMMARY
 In a modern economy, market conditions change rapidly, customer and end-user
 needs evolve, and new competitive threats emerge without warning. Practitioners
 must approach software engineering in a manner that allows them to remain agile—
 to define maneuverable, adaptive, lean processes that can accommodate the needs
 of modern business.
 An agile philosophy for software engineering stresses four key issues: the impor
tance of self-organizing teams that have control over the work they perform, com
munication and collaboration between team members and between practitioners
 and their customers, a recognition that change represents an opportunity, and
92
 PART ONE THE SOFTWARE PROCESS
 an emphasis on rapid delivery of software that satisfies the customer. Agile process
 models have been designed to address each of these issues.
 Extreme programming (XP) is the most widely used agile process. Organized as
 four framework activities—planning, design, coding, and testing—XP suggests a
 number of innovative and powerful techniques that allow an agile team to create
 frequent software releases that deliver features and functionality that have been de
scribed and then prioritized by stakeholders.
 Other agile process models also stress human collaboration and team self
organization, but define their own framework activities and select different points of
 emphasis. For example, ASD uses an iterative process that incorporates adaptive
 cycle planning, relatively rigorous requirement gathering methods, and an iterative
 development cycle that incorporates customer focus groups and formal technical re
views as real-time feedback mechanisms. Scrum emphasizes the use of a set of soft
ware process patterns that have proven effective for projects with tight time lines,
 changing requirements, and business criticality. Each process pattern defines a set
 of development tasks and allows the Scrum team to construct a process that is
 adapted to the needs of the project. The Dynamic Systems Development Method
 (DSDM) advocates the use of time-box scheduling and suggests that only enough
 work is required for each software increment to facilitate movement to the next
 increment. Crystal is a family of agile process models that can be adopted to the spe
cific characteristics of a project.
 Feature Driven Development (FDD) is somewhat more “formal” than other agile
 methods, but still maintains agility by focusing the project team on the development
 of features—a client-valued function that can be implemented in two weeks or less.
 Lean Software Development (LSD) has adapted the principles of lean manufacturing
 to the world of software engineering. Agile modeling (AM) suggests that modeling is
 essential for all systems, but that the complexity, type, and size of the model must be
 tuned to the software to be built. The Agile Unified Process (AUP) adopts a “serial in
 the large” and “iterative in the small” philosophy for building software.
 PROBLEMS AND POINTS TO PONDER
 3.1. Reread “The Manifesto for Agile Software Development” at the beginning of this chapter.
 Can you think of a situation in which one or more of the four “values” could get a software team
 into trouble?
 3.2. Describe agility (for software projects) in your own words.
 3.3. Why does an iterative process make it easier to manage change? Is every agile process dis
cussed in this chapter iterative? Is it possible to complete a project in just one iteration and still
 be agile? Explain your answers.
 3.4. Could each of the agile processes be described using the generic framework activities
 noted in Chapter 2? Build a table that maps the generic activities into the activities defined for
 each agile process.
 3.5. Try to come up with one more “agility principle” that would help a software engineering
 team become even more maneuverable.
93
 CHAPTER 3 AGILE DEVELOPMENT
 3.6. Select one agility principle noted in Section 3.3.1 and try to determine whether each of the
 process models presented in this chapter exhibits the principle. [Note: I have presented an
 overview of these process models only, so it may not be possible to determine whether a prin
ciple has been addressed by one or more of the models, unless you do additional research
 (which is not required for this problem).]
 3.7. Why do requirements change so much? After all, don’t people know what they want?
 3.8. Most agile process models recommend face-to-face communication. Yet today, members
 of a software team and their customers may be geographically separated from one another. Do
 you think this implies that geographical separation is something to avoid? Can you think of ways
 to overcome this problem?
 3.9. Write an XP user story that describes the “favorite places” or “bookmarks” feature avail
able on most Web browsers.
 3.10. What is a spike solution in XP?
 3.11. Describe the XP concepts of refactoring and pair programming in your own words.
 3.12. Do a bit more reading and describe what a time-box is. How does this assist an ASD team
 in delivering software increments in a short time period?
 3.13. Do the 80 percent rule in DSDM and the time-boxing approach defined for ASD achieve
 the same result?
 3.14. Using the process pattern template presented in Chapter 2, develop a process pattern for
 any one of the Scrum patterns presented in Section 3.5.2.
 3.15. Why is Crystal called a family of agile methods?
 3.16. Using the FDD feature template described in Section 3.5.5, define a feature set for a Web
 browser. Now develop a set of features for the feature set.
 3.17. Visit the Official Agile Modeling Site and make a complete list of all core and supple
mentary AM principles.
 3.18. The tool set proposed in Section 3.6 supports many of the “soft” aspects of agile meth
ods. Since communication is so important, recommend an actual tool set that might be used to
 enhance communication among stakeholders on an agile team.
 FURTHER READINGS AND INFORMATION SOURCES
 The overall philosophy and underlying principles of agile software development are considered
 in depth in many of the books referenced in the body of this chapter. In addition, books by Shaw
 and Warden (The Art of Agile Development, O’Reilly Media, Inc., 2008), Hunt (Agile Software Con
struction, Springer, 2005), and Carmichael and Haywood (Better Software Faster, Prentice-Hall,
 2002) present useful discussions of the subject. Aguanno (Managing Agile Projects, Multi
Media Publications, 2005), Highsmith (Agile Project Management: Creating Innovative Products,
 Addison-Wesley, 2004), and Larman (Agile and Iterative Development: A Manager’s Guide,
 Addison-Wesley, 2003) present a management overview and consider project management
 issues. Highsmith (Agile Software Development Ecosystems, Addison-Wesley, 2002) presents a
 survey of agile principles, processes, and practices. A worthwhile discussion of the delicate bal
ance between agility and discipline is presented by Booch and his colleagues (Balancing Agility
 and Discipline, Addison-Wesley, 2004).
 Martin (Clean Code: A Handbook of Agile Software Craftsmanship, Prentice-Hall, 2009) pres
ents the principles, patterns, and practices required to develop “clean code” in an agile software
 engineering environment. Leffingwell (Scaling Software Agility: Best Practices for Large Enter
prises, Addison-Wesley, 2007) discusses strategies for scaling up agile practices for large proj
ects. Lippert and Rook (Refactoring in Large Software Projects: Performing Complex Restructurings
 Successfully, Wiley, 2006) discuss the use of refactoring when applied in large, complex systems.
94
 PART ONE THE SOFTWARE PROCESS
 Stamelos and Sfetsos (Agile Software Development Quality Assurance, IGI Global, 2007) discuss
 SQA techniques that conform to the agile philosophy.
 Dozens of books have been written about Extreme Programming over the past decade. Beck
 (Extreme Programming Explained: Embrace Change, 2d ed., Addison-Wesley, 2004) remains the
 definitive treatment of the subject. In addition, Jeffries and his colleagues (Extreme Programming
 Installed, Addison-Wesley, 2000), Succi and Marchesi (Extreme Programming Examined,
 Addison-Wesley, 2001), Newkirk and Martin (Extreme Programming in Practice, Addison-Wesley,
 2001), and Auer and his colleagues (Extreme Programming Applied: Play to Win, Addison-Wesley,
 2001) provide a nuts-and-bolts discussion of XP along with guidance on how best to apply it.
 McBreen (Questioning Extreme Programming, Addison-Wesley, 2003) takes a critical look at XP,
 defining when and where it is appropriate. An in-depth consideration of pair programming is
 presented by McBreen (Pair Programming Illuminated, Addison-Wesley, 2003).
 ASD is addressed in depth by Highsmith [Hig00]. Schwaber (The Enterprise and Scrum,
 Microsoft Press, 2007) discusses the use of Scrum for projects that have a major business
 impact. The nuts and bolts of Scrum are discussed by Schwaber and Beedle (Agile Software
 Development with SCRUM, Prentice-Hall, 2001). Worthwhile treatments of DSDM have been
 written by the DSDM Consortium (DSDM: Business Focused Development, 2d ed., Pearson Edu
cation, 2003) and Stapleton (DSDM: The Method in Practice, Addison-Wesley, 1997). Cockburn
 (Crystal Clear, Addison-Wesley, 2005) presents an excellent overview of the Crystal family of
 processes. Palmer and Felsing [Pal02] present a detailed treatment of FDD. Carmichael and
 Haywood (Better Software Faster, Prentice-Hall, 2002) provides another useful treatment of FDD
 that includes a step-by-step journey through the mechanics of the process. Poppendieck and 
Poppendieck (Lean Development: An Agile Toolkit for Software Development Managers, Addison
Wesley, 2003) provide guidelines for managing and controlling agile projects. Ambler and
 Jeffries (Agile Modeling, Wiley, 2002) discuss AM in some depth.
 A wide variety of information sources on agile software development are available on the
 Internet. An up-to-date list of World Wide Web references that are relevant to the agile process
 can be found at the SEPA website: www.mhhe.com/engcs/compsci/pressman/
 professional/olc/ser.htm.
In 2001, Kent Beck and 16 other noted software developers, writers, and con
sultants [Bec01a] (referred to as the “Agile Alliance”) signed the “Manifesto for
 Agile Software Development.” It stated:
 We are uncovering better ways of developing software by doing it and helping others
 do it. Through this work we have come to value: 
Individuals and interactions over processes and tools
 Working software over comprehensive documentation
 Customer collaboration over contract negotiation
 Responding to change over following a plan
 That is, while there is value in the items on the right, we value the items on the 
left more.
 QUICK
 LOOK
 What is it? Agile software engi
neering combines a philosophy and
 a set of development guidelines. The
 philosophy encourages customer
 satisfaction and early incremental delivery of
 software; small, highly motivated project teams;
 informal methods; minimal software engineer
ing work products; and overall development
 simplicity. The development guidelines stress
 delivery over analysis and design (although
 these activities are not discouraged), and active
 and continuous communication between devel
opers and customers.
 Who does it? Software engineers and other
 project stakeholders (managers, customers, end
 users) work together on an agile team—a team
 that is self-organizing and in control of its own
 destiny. An agile team fosters communication
 and collaboration among all who serve on it.
 Why is it important? The modern business envi
ronment that spawns computer-based systems
 and software products is fast-paced and ever
changing. Agile software engineering repre
sents a reasonable alternative to conventional
 software engineering for certain classes of soft
ware and certain types of software projects. It
 has been demonstrated to deliver successful sys
tems quickly.
 Whatarethesteps? Agiledevelopmentmightbest
 be termed “software engineering lite.” The basic
 framework activities—communication, planning,
 modeling, construction, and deployment—
 remain. But they morph into a minimal task set
 that pushes the project team toward construction
 and delivery (some would argue that this is
 done at the expense of problem analysis and
 solution design).
 What is the work product? Both the customer
 and the software engineer have the same
 view—the only really important work product
 is an operational “software increment” that is
 delivered to the customer on the appropriate
 commitment date.
 How do I ensure that I’ve done it right? If the
 agile team agrees that the process works, and
 the team produces deliverable software
 increments that satisfy the customer, you’ve
 done it right.
 65
66
 PART ONE THE SOFTWARE PROCESS
 FDD . . . . . . . . . .86
 Industrial XP . . .77
 Lean Software
 Development . . .87
 pair 
programming . . .76
 project 
velocity . . . . . . .74
 refactoring . . . . .75
 Scrum . . . . . . . .82
 stories . . . . . . . .74
 XP process . . . . .73
 uote:
 “Agility: 1,
 everything else: 0.”
 Tom DeMarco
 A manifesto is normally associated with an emerging political movement—one
 that attacks the old guard and suggests revolutionary change (hopefully for the
 better). In some ways, that’s exactly what agile development is all about.
 Although the underlying ideas that guide agile development have been with us for
 many years, it has been less than two decades since these ideas have crystallized
 into a “movement.” In essence, agile1 methods were developed in an effort to over
come perceived and actual weaknesses in conventional software engineering. Agile
 development can provide important benefits, but it is not applicable to all projects,
 all products, all people, and all situations. It is also not antithetical to solid software
 engineering practice and can be applied as an overriding philosophy for all software
 work.
 In the modern economy, it is often difficult or impossible to predict how a
 computer-based system (e.g., a Web-based application) will evolve as time passes.
 Market conditions change rapidly, end-user needs evolve, and new competitive
 threats emerge without warning. In many situations, you won’t be able to define
 requirements fully before the project begins. You must be agile enough to respond to
 a fluid business environment.
 Fluidity implies change, and change is expensive. Particularly if it is uncontrolled
 or poorly managed. One of the most compelling characteristics of the agile approach
 is its ability to reduce the costs of change throughout the software process.
 Does this mean that a recognition of challenges posed by modern realities causes
 you to discard valuable software engineering principles, concepts, methods, and
 tools? Absolutely not! Like all engineering disciplines, software engineering contin
ues to evolve. It can be adapted easily to meet the challenges posed by a demand for
 agility.
 In a thought-provoking book on agile software development, Alistair Cockburn
 [Coc02] argues that the prescriptive process models introduced in Chapter 2 have a
 major failing: they forget the frailties of the people who build computer software. Software
 engineers are not robots. They exhibit great variation in working styles; significant dif
ferences in skill level, creativity, orderliness, consistency, and spontaneity. Some com
municate well in written form, others do not. Cockburn argues that process models
 can “deal with people’s common weaknesses with [either] discipline or tolerance” and
 that most prescriptive process models choose discipline. He states: “Because consis
tency in action is a human weakness, high discipline methodologies are fragile.”
 If process models are to work, they must provide a realistic mechanism for en
couraging the discipline that is necessary, or they must be characterized in a man
ner that shows “tolerance” for the people who do software engineering work.
 Invariably, tolerant practices are easier for software people to adopt and sustain, but
 (as Cockburn admits) they may be less productive. Like most things in life, trade-offs
 must be considered.
 1 Agile methods are sometimes referred to as light methods or lean methods.
67
 CHAPTER 3 AGILE DEVELOPMENT
 3.1 WHAT IS AGILITY?
 Just what is agility in the context of software engineering work? Ivar Jacobson
 [Jac02a] provides a useful discussion:
 Agility has become today’s buzzword when describing a modern software process. Every
one is agile. An agile team is a nimble team able to appropriately respond to changes.
 Change is what software development is very much about. Changes in the software be
ing built, changes to the team members, changes because of new technology, changes of
 all kinds that may have an impact on the product they build or the project that creates the
 product. Support for changes should be built-in everything we do in software, something
 we embrace because it is the heart and soul of software. An agile team recognizes that
 software is developed by individuals working in teams and that the skills of these people,
 their ability to collaborate is at the core for the success of the project.
 Don’t make the
 mistake of assuming
 that agility gives you
 license to hack out
 solutions. A process is
 required and discipline
 is essential.
 In Jacobson’s view, the pervasiveness of change is the primary driver for agility. Soft
ware engineers must be quick on their feet if they are to accommodate the rapid
 changes that Jacobson describes.
 But agility is more than an effective response to change. It also encompasses the
 philosophy espoused in the manifesto noted at the beginning of this chapter. It
 encourages team structures and attitudes that make communication (among team
 members, between technologists and business people, between software engineers
 and their managers) more facile. It emphasizes rapid delivery of operational soft
ware and de-emphasizes the importance of intermediate work products (not always
 a good thing); it adopts the customer as a part of the development team and works
 to eliminate the “us and them” attitude that continues to pervade many software
 projects; it recognizes that planning in an uncertain world has its limits and that a
 project plan must be flexible.
 Agility can be applied to any software process. However, to accomplish this, it is
 essential that the process be designed in a way that allows the project team to adapt
 tasks and to streamline them, conduct planning in a way that understands the fluid
ity of an agile development approach, eliminate all but the most essential work prod
ucts and keep them lean, and emphasize an incremental delivery strategy that gets
 working software to the customer as rapidly as feasible for the product type and
 operational environment.
 3.2 AGILITY AND THE COST OF CHANGE
 The conventional wisdom in software development (supported by decades of expe
rience) is that the cost of change increases nonlinearly as a project progresses
 (Figure 3.1, solid black curve). It is relatively easy to accommodate a change when a
 software team is gathering requirements (early in a project). A usage scenario might
 have to be modified, a list of functions may be extended, or a written specification
 can be edited. The costs of doing this work are minimal, and the time required will
68
 PART ONE THE SOFTWARE PROCESS
 FIGURE 3.1
 Change costs
 as a function
 of time in
 development
 uote:
 Development cost
 Cost of change
 using conventional
 software processes
 Cost of change
 using agile processes
 “Agility is dynamic,
 content specific,
 aggressively
 change embracing,
 and growth
 oriented.”
 Idealized cost of change
 using agile process
 Development schedule progress–Steven
 Goldman et al.
 An agile process
 reduces the cost of
 change because
 software is released in
 increments and change
 can be better
 controlled within an
 increment.
 not adversely affect the outcome of the project. But what if we fast-forward a num
ber of months? The team is in the middle of validation testing (something that occurs
 relatively late in the project), and an important stakeholder is requesting a major
 functional change. The change requires a modification to the architectural design of
 the software, the design and construction of three new components, modifications
 to another five components, the design of new tests, and so on. Costs escalate
 quickly, and the time and cost required to ensure that the change is made without
 unintended side effects is nontrivial.
 Proponents of agility (e.g., [Bec00], [Amb04]) argue that a well-designed agile
 process “flattens” the cost of change curve (Figure 3.1, shaded, solid curve), allowing
 a software team to accommodate changes late in a software project without dramatic
 cost and time impact. You’ve already learned that the agile process encompasses in
cremental delivery. When incremental delivery is coupled with other agile practices
 such as continuous unit testing and pair programming (discussed later in this chap
ter), the cost of making a change is attenuated. Although debate about the degree to
 which the cost curve flattens is ongoing, there is evidence [Coc01a] to suggest that a
 significant reduction in the cost of change can be achieved.
 3.3 WHAT IS ANAGILE PROCESS?
 Any agile software process is characterized in a manner that addresses a number of
 key assumptions [Fow02] about the majority of software projects: 
1. It is difficult to predict in advance which software requirements will persist
 and which will change. It is equally difficult to predict how customer
 priorities will change as the project proceeds.
69
 CHAPTER 3 AGILE DEVELOPMENT
 WebRef
 A comprehensive
 collection of articles on
 the agile process 
can be found at
 www.aanpo.org/
 articles/index.
 Although agile
 processes embrace
 change, it is still
 important to examine
 the reasons for
 change.
 Working software is
 important, but don’t
 forget that it must also
 exhibit a variety of
 quality attributes
 including reliability,
 usability, and 
maintainability.
 2. For many types of software, design and construction are interleaved. That is,
 both activities should be performed in tandem so that design models are
 proven as they are created. It is difficult to predict how much design is
 necessary before construction is used to prove the design.
 3. Analysis, design, construction, and testing are not as predictable (from a
 planning point of view) as we might like.
 Given these three assumptions, an important question arises: How do we create a
 process that can manage unpredictability? The answer, as I have already noted, lies
 in process adaptability (to rapidly changing project and technical conditions). An
 agile process, therefore, must be adaptable.
 But continual adaptation without forward progress accomplishes little. Therefore,
 an agile software process must adapt incrementally. To accomplish incremental adap
tation, an agile team requires customer feedback (so that the appropriate adaptations
 can be made). An effective catalyst for customer feedback is an operational prototype
 or a portion of an operational system. Hence, an incremental development strategy
 should be instituted. Software increments (executable prototypes or portions of an op
erational system) must be delivered in short time periods so that adaptation keeps pace
 with change (unpredictability). This iterative approach enables the customer to evalu
ate the software increment regularly, provide necessary feedback to the software team,
 and influence the process adaptations that are made to accommodate the feedback.
 3.3.1 Agility Principles
 The Agile Alliance (see [Agi03], [Fow01]) defines 12 agility principles for those who
 want to achieve agility: 
1. Our highest priority is to satisfy the customer through early and continuous
 delivery of valuable software.
 2. Welcome changing requirements, even late in development. Agile processes
 harness change for the customer’s competitive advantage.
 3. Deliver working software frequently, from a couple of weeks to a couple of
 months, with a preference to the shorter timescale.
 4. Business people and developers must work together daily throughout the
 project.
 5. Build projects around motivated individuals. Give them the environment and
 support they need, and trust them to get the job done.
 6. The most efficient and effective method of conveying information to and
 within a development team is face-to-face conversation.
 7. Working software is the primary measure of progress.
 8. Agile processes promote sustainable development. The sponsors, developers,
 and users should be able to maintain a constant pace indefinitely.
70
 PART ONE THE SOFTWARE PROCESS
 9. Continuous attention to technical excellence and good design enhances
 agility.
 10. Simplicity—the art of maximizing the amount of work not done—is 
essential.
 11. The best architectures, requirements, and designs emerge from self
organizing teams.
 12. At regular intervals, the team reflects on how to become more effective, then
 tunes and adjusts its behavior accordingly.
 Not every agile process model applies these 12 principles with equal weight, and
 some models choose to ignore (or at least downplay) the importance of one or more
 of the principles. However, the principles define an agile spirit that is maintained in
 each of the process models presented in this chapter.
 3.3.2 The Politics of Agile Development
 You don’t have to
 choose between agility
 and software engi
neering. Rather, define
 a software engineering
 approach that is agile.
 There is considerable debate (sometimes strident) about the benefits and applicabil
ity of agile software development as opposed to more conventional software engi
neering processes. Jim Highsmith [Hig02a] (facetiously) states the extremes when he
 characterizes the feeling of the pro-agility camp (“agilists”). “Traditional methodolo
gists are a bunch of stick-in-the-muds who’d rather produce flawless documentation
 than a working system that meets business needs.” As a counterpoint, he states
 (again, facetiously) the position of the traditional software engineering camp: “Light
weight, er, ‘agile’ methodologists are a bunch of glorified hackers who are going to
 be in for a heck of a surprise when they try to scale up their toys into enterprise-wide
 software.”
 Like all software technology arguments, this methodology debate risks degener
ating into a religious war. If warfare breaks out, rational thought disappears and
 beliefs rather than facts guide decision making.
 No one is against agility. The real question is: What is the best way to achieve it?
 As important, how do you build software that meets customers’ needs today and
 exhibits the quality characteristics that will enable it to be extended and scaled to
 meet customers’ needs over the long term?
 There are no absolute answers to either of these questions. Even within the agile
 school itself, there are many proposed process models (Section 3.4), each with a
 subtly different approach to the agility problem. Within each model there is a set of
 “ideas” (agilists are loath to call them “work tasks”) that represent a significant
 departure from traditional software engineering. And yet, many agile concepts are
 simply adaptations of good software engineering concepts. Bottom line: there is
 much that can be gained by considering the best of both schools and virtually
 nothing to be gained by denigrating either approach.
 If you have further interest, see [Hig01], [Hig02a], and [DeM02] for an entertain
ing summary of other important technical and political issues.
71
 CHAPTER 3 AGILE DEVELOPMENT
 uote:
 “Agile methods
 derive much of
 their agility by
 relying on the
 tacit knowledge
 embodied in the
 team, rather than
 writing the
 knowledge down
 in plans.”
 Barry Boehm
 ?
 What key
 traits must
 exist among the
 people on an
 effective software
 team?
 uote:
 “What counts as
 barely sufficient
 for one team is
 either overly
 sufficient or
 insufficient for
 another.”
 Alistair
 Cockburn
 3.3.3 Human Factors
 Proponents of agile software development take great pains to emphasize the impor
tance of “people factors.” As Cockburn and Highsmith [Coc01a] state, “Agile devel
opment focuses on the talents and skills of individuals, molding the process to
 specific people and teams.” The key point in this statement is that the process molds
 to the needs of the people and team, not the other way around.2
 If members of the software team are to drive the characteristics of the process that
 is applied to build software, a number of key traits must exist among the people on
 an agile team and the team itself:
 Competence. In an agile development (as well as software engineering)
 context, “competence” encompasses innate talent, specific software-related
 skills, and overall knowledge of the process that the team has chosen to
 apply. Skill and knowledge of process can and should be taught to all people
 who serve as agile team members.
 Common focus. Although members of the agile team may perform differ
ent tasks and bring different skills to the project, all should be focused on one
 goal—to deliver a working software increment to the customer within the
 time promised. To achieve this goal, the team will also focus on continual
 adaptations (small and large) that will make the process fit the needs of the
 team.
 Collaboration. Software engineering (regardless of process) is about as
sessing, analyzing, and using information that is communicated to the soft
ware team; creating information that will help all stakeholders understand
 the work of the team; and building information (computer software and rele
vant databases) that provides business value for the customer. To accomplish
 these tasks, team members must collaborate—with one another and all other
 stakeholders.
 Decision-making ability. Any good software team (including agile teams)
 must be allowed the freedom to control its own destiny. This implies that the
 team is given autonomy—decision-making authority for both technical and
 project issues.
 Fuzzy problem-solving ability. Software managers must recognize that
 the agile team will continually have to deal with ambiguity and will continu
ally be buffeted by change. In some cases, the team must accept the fact that
 the problem they are solving today may not be the problem that needs to be
 solved tomorrow. However, lessons learned from any problem-solving
 2 Successful software engineering organizations recognize this reality regardless of the process
 model they choose.
72
 PART ONE THE SOFTWARE PROCESS
 A self-organizing team
 is in control of the
 work it performs. The
 team makes its own
 commitments and
 defines plans to
 achieve them.
 activity (including those that solve the wrong problem) may be of benefit to
 the team later in the project.
 Mutual trust and respect. The agile team must become what DeMarco
 and Lister [DeM98] call a “jelled” team (Chapter 24). A jelled team exhibits
 the trust and respect that are necessary to make them “so strongly knit that
 the whole is greater than the sum of the parts.” [DeM98]
 Self-organization. In the context of agile development, self-organization
 implies three things: (1) the agile team organizes itself for the work to be
 done, (2) the team organizes the process to best accommodate its local envi
ronment, (3) the team organizes the work schedule to best achieve delivery
 of the software increment. Self-organization has a number of technical bene
fits, but more importantly, it serves to improve collaboration and boost team
 morale. In essence, the team serves as its own management. Ken Schwaber
 [Sch02] addresses these issues when he writes: “The team selects how much
 work it believes it can perform within the iteration, and the team commits to
 the work. Nothing demotivates a team as much as someone else making
 commitments for it. Nothing motivates a team as much as accepting the
 responsibility for fulfilling commitments that it made itself.”
 3.4 EXTREME PROGRAMMING (XP)
 In order to illustrate an agile process in a bit more detail, I’ll provide you with an
 overview of Extreme Programming (XP), the most widely used approach to agile soft
ware development. Although early work on the ideas and methods associated with
 XP occurred during the late 1980s, the seminal work on the subject has been written
 by Kent Beck [Bec04a]. More recently, a variant of XP, called Industrial XP (IXP) has
 been proposed [Ker05]. IXP refines XP and targets the agile process specifically for
 use within large organizations.
 3.4.1 XP Values
 Beck [Bec04a] defines a set of five values that establish a foundation for all work per
formed as part of XP—communication, simplicity, feedback, courage, and respect. Each
 of these values is used as a driver for specific XP activities, actions, and tasks.
 In order to achieve effective communication between software engineers and
 other stakeholders (e.g., to establish required features and functions for the soft
ware), XP emphasizes close, yet informal (verbal) collaboration between customers
 and developers, the establishment of effective metaphors3 for communicating
 important concepts, continuous feedback, and the avoidance of voluminous docu
mentation as a communication medium.
 3 In the XP context, a metaphor is “a story that everyone—customers, programmers, and managers—
 can tell about how the system works” [Bec04a].
73
 CHAPTER 3 AGILE DEVELOPMENT
 Keep it simple
 whenever you can, but
 recognize that
 continual “refactoring”
 can absorb significant
 time and resources.
 uote:
 “XP is the answer
 to the question,
 ‘How little can we
 do and still build
 great software?’“
 Anonymous
 WebRef
 An excellent overview
 of “rules” for XP can
 be found at www
 .extremeprogramm
 ing.org/rules.html.
 To achieve simplicity, XP restricts developers to design only for immediate needs,
 rather than consider future needs. The intent is to create a simple design that can be
 easily implemented in code). If the design must be improved, it can be refactored4 at
 a later time.
 Feedback is derived from three sources: the implemented software itself, the
 customer, and other software team members. By designing and implementing an
 effective testing strategy (Chapters 17 through 20), the software (via test results) pro
vides the agile team with feedback. XP makes use of the unit test as its primary test
ing tactic. As each class is developed, the team develops a unit test to exercise each
 operation according to its specified functionality. As an increment is delivered to a
 customer, the user stories or use cases (Chapter 5) that are implemented by the
 increment are used as a basis for acceptance tests. The degree to which the software
 implements the output, function, and behavior of the use case is a form of feedback.
 Finally, as new requirements are derived as part of iterative planning, the team pro
vides the customer with rapid feedback regarding cost and schedule impact.
 Beck [Bec04a] argues that strict adherence to certain XP practices demands
 courage. A better word might be discipline. For example, there is often significant
 pressure to design for future requirements. Most software teams succumb, arguing
 that “designing for tomorrow” will save time and effort in the long run. An agile XP
 team must have the discipline (courage) to design for today, recognizing that future
 requirements may change dramatically, thereby demanding substantial rework of
 the design and implemented code.
 By following each of these values, the agile team inculcates respect among it
 members, between other stakeholders and team members, and indirectly, for the
 software itself. As they achieve successful delivery of software increments, the team
 develops growing respect for the XP process.
 3.4.2 The XP Process
 Extreme Programming uses an object-oriented approach (Appendix 2) as its pre
ferred development paradigm and encompasses a set of rules and practices that
 occur within the context of four framework activities: planning, design, coding, and
 testing. Figure 3.2 illustrates the XP process and notes some of the key ideas and
 tasks that are associated with each framework activity. Key XP activities are sum
marized in the paragraphs that follow.
 Planning. The planning activity (also called the planning game) begins with
 listening—a requirements gathering activity that enables the technical members of
 the XP team to understand the business context for the software and to get a broad
 4 Refactoring allows a software engineer to improve the internal structure of a design (or source
 code) without changing its external functionality or behavior. In essence, refactoring can be used
 to improve the efficiency, readability, or performance of a design or the code that implements a
 design.
74
 PART ONE THE SOFTWARE PROCESS
 FIGURE 3.2
 The Extreme
 Programming
 process
 ?
 What is an
 XP “story”?
 WebRef
 A worthwhile XP
 “planning game” can
 be found at:
 c2.com/cgi/
 wiki?planningGame.
 simple design
 CRC cards
 user stories
 values
 acceptance test criteria
 iteration plan
 Release
 spike solutions
 prototypes
 refactoring
 design
 pair programming
 planning
 software increment
 project velocity computed
 unit test
 continuous integration
 acceptance testing
 test
 coding
 feel for required output and major features and functionality. Listening leads to the
 creation of a set of “stories” (also called user stories) that describe required output,
 features, and functionality for software to be built. Each story (similar to use cases
 described in Chapter 5) is written by the customer and is placed on an index card.
 The customer assigns a value (i.e., a priority) to the story based on the overall busi
ness value of the feature or function.5 Members of the XP team then assess each
 story and assign a cost—measured in development weeks—to it. If the story is esti
mated to require more than three development weeks, the customer is asked to split
 the story into smaller stories and the assignment of value and cost occurs again. It
 is important to note that new stories can be written at any time.
 Customers and developers work together to decide how to group stories into the
 next release (the next software increment) to be developed by the XP team. Once a
 basic commitment (agreement on stories to be included, delivery date, and other
 project matters) is made for a release, the XP team orders the stories that will be de
veloped in one of three ways: (1) all stories will be implemented immediately (within
 a few weeks), (2) the stories with highest value will be moved up in the schedule and
 implemented first, or (3) the riskiest stories will be moved up in the schedule and
 implemented first.
 After the first project release (also called a software increment) has been deliv
ered, the XP team computes project velocity. Stated simply, project velocity is the
 5 The value of a story may also be dependent on the presence of another story.
75
 CHAPTER 3 AGILE DEVELOPMENT
 Project velocity is a
 subtle measure of
 team productivity.
 XP deemphasizes the
 importance of design.
 Not everyone agrees.
 In fact, there are times
 when design should be
 emphasized.
 WebRef
 Refactoring techniques
 and tools can be
 found at:
 www.refactoring
 .com.
 number of customer stories implemented during the first release. Project velocity can
 then be used to (1) help estimate delivery dates and schedule for subsequent releases
 and (2) determine whether an overcommitment has been made for all stories across
 the entire development project. If an overcommitment occurs, the content of releases
 is modified or end delivery dates are changed.
 As development work proceeds, the customer can add stories, change the value
 of an existing story, split stories, or eliminate them. The XP team then reconsiders all
 remaining releases and modifies its plans accordingly.
 Design. XP design rigorously follows the KIS (keep it simple) principle. A simple
 design is always preferred over a more complex representation. In addition, the de
sign provides implementation guidance for a story as it is written—nothing less,
 nothing more. The design of extra functionality (because the developer assumes it
 will be required later) is discouraged.6
 XP encourages the use of CRC cards (Chapter 7) as an effective mechanism for
 thinking about the software in an object-oriented context. CRC (class-responsibility
collaborator) cards identify and organize the object-oriented classes7 that are rele
vant to the current software increment. The XP team conducts the design exercise
 using a process similar to the one described in Chapter 8. The CRC cards are the only
 design work product produced as part of the XP process.
 If a difficult design problem is encountered as part of the design of a story, XP rec
ommends the immediate creation of an operational prototype of that portion of the
 design. Called a spike solution, the design prototype is implemented and evaluated.
 The intent is to lower risk when true implementation starts and to validate the orig
inal estimates for the story containing the design problem.
 In the preceding section, we noted that XP encourages refactoring—a construction
 technique that is also a method for design optimization. Fowler [Fow00] describes
 refactoring in the following manner:
 Refactoring is the process of changing a software system in such a way that it does not
 alter the external behavior of the code yet improves the internal structure. It is a disci
plined way to clean up code [and modify/simplify the internal design] that minimizes the
 chances of introducing bugs. In essence, when you refactor you are improving the design
 of the code after it has been written.
 Because XP design uses virtually no notation and produces few, if any, work prod
ucts other than CRC cards and spike solutions, design is viewed as a transient arti
fact that can and should be continually modified as construction proceeds. The intent
 of refactoring is to control these modifications by suggesting small design changes
 6 These design guidelines should be followed in every software engineering method, although there
 are times when sophisticated design notation and terminology may get in the way of simplicity.
 7 Object-oriented classes are discussed in Appendix 2, in Chapter 8, and throughout Part 2 of this
 book.
76
 PART ONE THE SOFTWARE PROCESS
 Refactoring improves
 the internal structure of
 a design (or source
 code) without
 changing its external
 functionality or
 behavior.
 WebRef
 Useful information on
 XP can be obtained 
at www
 .xprogramming.
 com.
 ?
 What is 
pair
 programming?
 Many software teams
 are populated by indi
vidualists. You’ll have
 to work to change that
 culture if pair program
ming is to work effec
tively.
 ?
 XP?
 How are unit
 tests used in
 that “can radically improve the design” [Fow00]. It should be noted, however, that
 the effort required for refactoring can grow dramatically as the size of an application
 grows.
 A central notion in XP is that design occurs both before and after coding com
mences. Refactoring means that design occurs continuously as the system is con
structed. In fact, the construction activity itself will provide the XP team with
 guidance on how to improve the design.
 Coding. After stories are developed and preliminary design work is done, the team
 does not move to code, but rather develops a series of unit tests that will exercise
 each of the stories that is to be included in the current release (software increment).8
 Once the unit test9 has been created, the developer is better able to focus on what
 must be implemented to pass the test. Nothing extraneous is added (KIS). Once the
 code is complete, it can be unit-tested immediately, thereby providing instantaneous
 feedback to the developers.
 A key concept during the coding activity (and one of the most talked about aspects
 of XP) is pair programming. XP recommends that two people work together at one
 computer workstation to create code for a story. This provides a mechanism for real
time problem solving (two heads are often better than one) and real-time quality as
surance (the code is reviewed as it is created). It also keeps the developers focused
 on the problem at hand. In practice, each person takes on a slightly different role. For
 example, one person might think about the coding details of a particular portion of
 the design while the other ensures that coding standards (a required part of XP) are
 being followed or that the code for the story will satisfy the unit test that has been
 developed to validate the code against the story.
 As pair programmers complete their work, the code they develop is integrated
 with the work of others. In some cases this is performed on a daily basis by an inte
gration team. In other cases, the pair programmers have integration responsibility.
 This “continuous integration” strategy helps to avoid compatibility and interfacing
 problems and provides a “smoke testing” environment (Chapter 17) that helps to
 uncover errors early.
 Testing. I have already noted that the creation of unit tests before coding com
mences is a key element of the XP approach. The unit tests that are created should
 be implemented using a framework that enables them to be automated (hence, they
 can be executed easily and repeatedly). This encourages a regression testing strat
egy (Chapter 17) whenever code is modified (which is often, given the XP refactor
ing philosophy).
 8 This approach is analogous to knowing the exam questions before you begin to study. It makes
 studying much easier by focusing attention only on the questions that will be asked.
 9 Unit testing, discussed in detail in Chapter 17, focuses on an individual software component, exer
cising the component’s interface, data structures, and functionality in an effort to uncover errors
 that are local to the component.
77
 CHAPTER 3 AGILE DEVELOPMENT
 XP acceptance tests
 are derived from user
 stories.
 ?
 What new
 practices are
 appended to XP
 to create IXP?
 uote:
 “Ability is what
 you’re capable of
 doing. Motivation
 determines what
 you do. Attitude
 determines how
 well you do it.”
 Lou Holtz
 As the individual unit tests are organized into a “universal testing suite” [Wel99],
 integration and validation testing of the system can occur on a daily basis. This pro
vides the XP team with a continual indication of progress and also can raise warn
ing flags early if things go awry. Wells [Wel99] states: “Fixing small problems every
 few hours takes less time than fixing huge problems just before the deadline.”
 XP acceptance tests, also called customer tests, are specified by the customer and
 focus on overall system features and functionality that are visible and reviewable by
 the customer. Acceptance tests are derived from user stories that have been imple
mented as part of a software release.
 3.4.3 Industrial XP
 Joshua Kerievsky [Ker05] describes Industrial Extreme Programming (IXP) in the fol
lowing manner: “IXP is an organic evolution of XP. It is imbued with XP’s minimal
ist, customer-centric, test-driven spirit. IXP differs most from the original XP in its
 greater inclusion of management, its expanded role for customers, and its upgraded
 technical practices.” IXP incorporates six new practices that are designed to help
 ensure that an XP project works successfully for significant projects within a large
 organization.
 Readiness assessment. Prior to the initiation of an IXP project, the organ
ization should conduct a readiness assessment. The assessment ascertains
 whether (1) an appropriate development environment exists to support IXP,
 (2) the team will be populated by the proper set of stakeholders, (3) the or
ganization has a distinct quality program and supports continuous improve
ment, (4) the organizational culture will support the new values of an agile
 team, and (5) the broader project community will be populated appropriately.
 Project community. Classic XP suggests that the right people be used to
 populate the agile team to ensure success. The implication is that people on
 the team must be well-trained, adaptable and skilled, and have the proper
 temperament to contribute to a self-organizing team. When XP is to be
 applied for a significant project in a large organization, the concept of the
 “team” should morph into that of a community. A community may have a
 technologist and customers who are central to the success of a project as
 well as many other stakeholders (e.g., legal staff, quality auditors, manufac
turing or sales types) who “are often at the periphery of an IXP project yet
 they may play important roles on the project” [Ker05]. In IXP, the community
 members and their roles should be explicitly defined and mechanisms for
 communication and coordination between community members should be
 established.
 Project chartering. The IXP team assesses the project itself to determine
 whether an appropriate business justification for the project exists and
 whether the project will further the overall goals and objectives of the
78
 PART ONE THE SOFTWARE PROCESS
 organization. Chartering also examines the context of the project to deter
mine how it complements, extends, or replaces existing systems or
 processes.
 Test-driven management. An IXP project requires measurable criteria for
 assessing the state of the project and the progress that has been made to
 date. Test-driven management establishes a series of measurable “destina
tions” [Ker05] and then defines mechanisms for determining whether or not
 these destinations have been reached.
 Retrospectives. An IXP team conducts a specialized technical review
 (Chapter 15) after a software increment is delivered. Called a retrospective,
 the review examines “issues, events, and lessons-learned” [Ker05] across a
 software increment and/or the entire software release. The intent is to
 improve the IXP process.
 Continuous learning. Because learning is a vital part of continuous
 process improvement, members of the XP team are encouraged (and possi
bly, incented) to learn new methods and techniques that can lead to a higher
quality product.
 In addition to the six new practices discussed, IXP modifies a number of existing
 XP practices. Story-driven development (SDD) insists that stories for acceptance tests
 be written before a single line of code is generated. Domain-driven design (DDD) is
 an improvement on the “system metaphor” concept used in XP. DDD [Eva03] sug
gests the evolutionary creation of a domain model that “accurately represents how
 domain experts think about their subject” [Ker05]. Pairing extends the XP pair
programming concept to include managers and other stakeholders. The intent is to
 improve knowledge sharing among XP team members who may not be directly in
volved in technical development. Iterative usability discourages front-loaded inter
face design in favor of usability design that evolves as software increments are
 delivered and users’ interaction with the software is studied.
 IXP makes smaller modifications to other XP practices and redefines certain roles
 and responsibilities to make them more amenable to significant projects for large
 organizations. For further discussion of IXP, visit http://industrialxp.org.
 3.4.4 The XP Debate
 All new process models and methods spur worthwhile discussion and in some in
stances heated debate. Extreme Programming has done both. In an interesting book
 that examines the efficacy of XP, Stephens and Rosenberg [Ste03] argue that many
 XP practices are worthwhile, but others have been overhyped, and a few are prob
lematic. The authors suggest that the codependent nature of XP practices are both
 its strength and its weakness. Because many organizations adopt only a subset of XP
 practices, they weaken the efficacy of the entire process. Proponents counter that
 XP is continuously evolving and that many of the issues raised by critics have been
79
 CHAPTER 3 AGILE DEVELOPMENT
 addressed as XP practice matures. Among the issues that continue to trouble some
 critics of XP are:10
 ?
 What are
 some of the
 issues that lead to
 an XP debate?
 • Requirements volatility. Because the customer is an active member of the XP
 team, changes to requirements are requested informally. As a consequence,
 the scope of the project can change and earlier work may have to be
 modified to accommodate current needs. Proponents argue that this happens
 regardless of the process that is applied and that XP provides mechanisms for
 controlling scope creep.
 • Conflicting customer needs. Many projects have multiple customers, each with
 his own set of needs. In XP, the team itself is tasked with assimilating the
 needs of different customers, a job that may be beyond their scope of
 authority.
 • Requirements are expressed informally. User stories and acceptance tests are
 the only explicit manifestation of requirements in XP. Critics argue that a
 more formal model or specification is often needed to ensure that omissions,
 inconsistencies, and errors are uncovered before the system is built. Propo
nents counter that the changing nature of requirements makes such models
 and specification obsolete almost as soon as they are developed.
 • Lack of formal design. XP deemphasizes the need for architectural design and
 in many instances, suggests that design of all kinds should be relatively
 informal. Critics argue that when complex systems are built, design must be
 emphasized to ensure that the overall structure of the software will exhibit
 quality and maintainability. XP proponents suggest that the incremental
 nature of the XP process limits complexity (simplicity is a core value) and
 therefore reduces the need for extensive design.
 You should note that every software process has flaws and that many software or
ganizations have used XP successfully. The key is to recognize where a process may
 have weaknesses and to adapt it to the specific needs of your organization.
 SAFEHOME
 Considering Agile Software Development
 The scene: Doug Miller’s office.
 The Players: Doug Miller, software engineering
 manager; Jamie Lazar, software team member; Vinod
 Raman, software team member.
 The conversation:
 (A knock on the door, Jamie and Vinod enter Doug’s office)
 Jamie: Doug, you got a minute?
 10 For a detailed look at some thoughtful criticism that has been leveled at XP, visit
 www.softwarereality.com/ExtremeProgramming.jsp.
3.5 OTHERAGILEPROCESSMODELS
 The history of software engineering is littered with dozens of obsolete process
 descriptions and methodologies, modeling methods and notations, tools, and
 technology. Each flared in notoriety and was then eclipsed by something new and
 (purportedly) better. With the introduction of a wide array of agile process models—
 each contending for acceptance within the software development community—the
 agile movement is following the same historical path.11
 As I noted in the last section, the most widely used of all agile process models
 isExtreme Programming (XP). But many other agile process models have been
 proposed and are in use across the industry. Among the most common are:
 •Adaptive Software Development (ASD)
 •Scrum
 •Dynamic Systems Development Method (DSDM)
 80 PART ONE THE SOFTWARE PROCESS
 Doug: Sure Jamie, what’s up?
 Jamie:We’ve been thinking about our process
 discussion yesterday . . . you know, what process we’re
 going to choose for this new SafeHomeproject.
 Doug:And?
 Vinod: I was talking to a friend at another company,
 and he was telling me about Extreme Programming. It’s
 an agile process model . . . heard of it?
 Doug: Yeah, some good, some bad.
 Jamie:Well, it sounds pretty good to us. Lets you
 develop software really fast, uses something called pair
 programming to do real-time quality checks . . . it’s pretty
 cool, I think.
 Doug: It does have a lot of really good ideas. I like the
 pair-programming concept, for instance, and the idea
 that stakeholders should be part of the team.
 Jamie:Huh? You mean that marketing will work on the
 project team with us?
 Doug (nodding): They’re a stakeholder, aren’t they?
 Jamie: Jeez . . . they’ll be requesting changes every five
 minutes.
 Vinod:Not necessarily. My friend said that there are
 ways to “embrace” changes during an XP project.
 Doug: So you guys think we should use XP?
 Jamie: It’s definitely worth considering.
 Doug: I agree. And even if we choose an incremental
 model as our approach, there’s no reason why we can’t
 incorporate much of what XP has to offer.
 Vinod:Doug, before you said “some good, some bad.”
 What was the “bad”?
 Doug: The thing I don’t like is the way XP downplays
 analysis and design . . . sort of says that writing code is
 where the action is . . . 
(The team members look at one another and smile.)
 Doug: So you agree with the XP approach?
 Jamie (speaking for both):Writing code is what
 we do, Boss!
 Doug (laughing): True, but I’d like to see you spend a
 little less time coding and then recoding and a little more
 time analyzing what has to be done and designing a
 solution that works.
 Vinod:Maybe we can have it both ways, agility with a
 little discipline.
 Doug: I think we can, Vinod. In fact, I’m sure of it.
 uote:
 “Our profession
 goes through
 methodologies like
 a 14-year-old goes
 through clothing.”
 Stephen
 Hawrysh and
 JimRuprecht
 11This is not a bad thing. Before one or more models or methods are accepted as a de facto standard,
 all must contend for the hearts and minds of software engineers. The “winners” evolve into best
 practice, while the “losers” either disappear or merge with the winning models.
81
 CHAPTER 3 AGILE DEVELOPMENT
 • Crystal
 • Feature Drive Development (FDD)
 • Lean Software Development (LSD)
 • Agile Modeling (AM)
 • Agile Unified Process (AUP)
 In the sections that follow, I present a very brief overview of each of these agile
 process models. It is important to note that all agile process models conform (to a
 greater or lesser degree) to the Manifesto for Agile Software Development and the prin
ciples noted in Section 3.3.1. For additional detail, refer to the references noted in
 each subsection or for a survey, examine the “agile software development” entry
 in Wikipedia.12
 3.5.1 Adaptive Software Development (ASD)
 WebRef
 Useful resources for
 ASD can be found at
 www.adaptivesd
 .com.
 Adaptive Software Development (ASD) has been proposed by Jim Highsmith [Hig00] as
 a technique for building complex software and systems. The philosophical under
pinnings of ASD focus on human collaboration and team self-organization.
 Highsmith argues that an agile, adaptive development approach based on collab
oration is “as much a source of order in our complex interactions as discipline and
 engineering.” He defines an ASD “life cycle” (Figure 3.3) that incorporates three
 phases, speculation, collaboration, and learning.
 FIGURE 3.3
 Adaptive
 software
 development
 adaptive cycle planning
 mission statement
 project constraints
 basic requirements
 time-boxed release plan
 Release
 Requirements gathering
 JAD
 mini-specs
 speculation
 software increment
 adjustments for subsequent cycles
 collaboration
 components implemented/tested
 focus groups for feedback
 formal technical reviews
 learning
 postmortems
 12 See http://en.wikipedia.org/wiki/Agile_software_development#Agile_methods.
82
 PART ONE THE SOFTWARE PROCESS
 Effective collaboration
 with your customer will
 only occur if you
 jettison any “us and
 them” attitudes.
 ASD emphasizes
 learning as a key
 element in achieving 
a “self-organizing”
 team.
 WebRef
 Useful Scrum
 information and
 resources can be found
 at www
 .controlchaos.com.
 During speculation, the project is initiated and adaptive cycle planning is con
ducted. Adaptive cycle planning uses project initiation information—the customer’s
 mission statement, project constraints (e.g., delivery dates or user descriptions), and
 basic requirements—to define the set of release cycles (software increments) that
 will be required for the project.
 No matter how complete and farsighted the cycle plan, it will invariably change.
 Based on information obtained at the completion of the first cycle, the plan is re
viewed and adjusted so that planned work better fits the reality in which an ASD
 team is working.
 Motivated people use collaboration in a way that multiplies their talent and cre
ative output beyond their absolute numbers. This approach is a recurring theme in
 all agile methods. But collaboration is not easy. It encompasses communication and
 teamwork, but it also emphasizes individualism, because individual creativity plays
 an important role in collaborative thinking. It is, above all, a matter of trust. People
 working together must trust one another to (1) criticize without animosity, (2) assist
 without resentment, (3) work as hard as or harder than they do, (4) have the skill set
 to contribute to the work at hand, and (5) communicate problems or concerns in a
 way that leads to effective action.
 As members of an ASD team begin to develop the components that are part of an
 adaptive cycle, the emphasis is on “learning” as much as it is on progress toward
 a completed cycle. In fact, Highsmith [Hig00] argues that software developers often
 overestimate their own understanding (of the technology, the process, and the proj
ect) and that learning will help them to improve their level of real understanding.
 ASD teams learn in three ways: focus groups (Chapter 5), technical reviews (Chap
ter 14), and project postmortems.
 The ASD philosophy has merit regardless of the process model that is used. ASD’s
 overall emphasis on the dynamics of self-organizing teams, interpersonal collabo
ration, and individual and team learning yield software project teams that have a
 much higher likelihood of success.
 3.5.2 Scrum
 Scrum (the name is derived from an activity that occurs during a rugby match13) is
 an agile software development method that was conceived by Jeff Sutherland and his
 development team in the early 1990s. In recent years, further development on the
 Scrum methods has been performed by Schwaber and Beedle [Sch01a].
 Scrum principles are consistent with the agile manifesto and are used to guide
 development activities within a process that incorporates the following framework
 activities: requirements, analysis, design, evolution, and delivery. Within each
 13 A group of players forms around the ball and the teammates work together (sometimes violently!)
 to move the ball downfield.
every 24
 hours
 30 days
 Scrum: 15 minute daily meeting.
 Team members respond to basics:
 1) What did you do since last Scrum
 meeting?
 2) Do you have any obstacles?
 3) What will you do before next
 meeting?
 Sprint Backlog:
 Feature(s)
 assigned
 to sprint
 Product Backlog:
 Prioritized product features desired by the customer
 Backlog
 items
 expanded
 by team
 New functionality
 is demonstrated
 at end of sprint
 framework activity, work tasks occur within a process pattern (discussed in the fol
lowing paragraph) called a sprint.The work conducted within a sprint (the number
 of sprints required for each framework activity will vary depending on product com
plexity and size) is adapted to the problem at hand and is defined and often modified
 in real time by the Scrum team. The overall flow of the Scrum process is illustrated
 in Figure 3.4.
 Scrum emphasizes the use of a set of software process patterns [Noy02] that have
 proven effective for projects with tight timelines, changing requirements, and business
 criticality. Each of these process patterns defines a set of development actions:
 Backlog—a prioritized list of project requirements or features that provide busi
ness value for the customer. Items can be added to the backlog at any time (this is
 how changes are introduced). The product manager assesses the backlog and
 updates priorities as required.
 Sprints—consist of work units that are required to achieve a requirement de
fined in the backlog that must be fit into a predefined time-box14(typically 30 days).
 CHAPTER 3 AGILE DEVELOPMENT 83
 14A time-boxis a project management term (see Part 4 of this book) that indicates a period of time
 that has been allocated to accomplish some task.
 FIGURE3.4
 Scrum process
 flow
 Scrum incorporates a
 set of process patterns
 that emphasize project
 priorities,
 compartmentalized
 work units,
 communication, and
 frequent customer
 feedback.
84
 PART ONE THE SOFTWARE PROCESS
 Changes (e.g., backlog work items) are not introduced during the sprint. Hence, the
 sprint allows team members to work in a short-term, but stable environment.
 Scrum meetings—are short (typically 15 minutes) meetings held daily by the Scrum
 team. Three key questions are asked and answered by all team members [Noy02]:
 • What did you do since the last team meeting?
 • What obstacles are you encountering?
 • What do you plan to accomplish by the next team meeting?
 A team leader, called a Scrum master, leads the meeting and assesses the responses
 from each person. The Scrum meeting helps the team to uncover potential problems
 as early as possible. Also, these daily meetings lead to “knowledge socialization”
 [Bee99] and thereby promote a self-organizing team structure.
 Demos—deliver the software increment to the customer so that functionality that
 has been implemented can be demonstrated and evaluated by the customer. It is im
portant to note that the demo may not contain all planned functionality, but rather
 those functions that can be delivered within the time-box that was established.
 Beedle and his colleagues [Bee99] present a comprehensive discussion of these pat
terns in which they state: “Scrum assumes up-front the existence of chaos. . . . ” The
 Scrum process patterns enable a software team to work successfully in a world
 where the elimination of uncertainty is impossible.
 3.5.3 Dynamic Systems Development Method (DSDM)
 WebRef
 Useful resources for
 DSSD can be found at
 www.dsdm.org.
 The Dynamic Systems Development Method (DSDM) [Sta97] is an agile software devel
opment approach that “provides a framework for building and maintaining systems
 which meet tight time constraints through the use of incremental prototyping in a con
trolled project environment” [CCS02]. The DSDM philosophy is borrowed from a mod
ified version of the Pareto principle—80 percent of an application can be delivered in
 20 percent of the time it would take to deliver the complete (100 percent) application.
 DSDM is an iterative software process in which each iteration follows the 80 per
cent rule. That is, only enough work is required for each increment to facilitate
 movement to the next increment. The remaining detail can be completed later when
 more business requirements are known or changes have been requested and
 accommodated.
 The DSDM Consortium (www.dsdm.org) is a worldwide group of member com
panies that collectively take on the role of “keeper” of the method. The consortium
 has defined an agile process model, called the DSDM life cycle that defines three dif
ferent iterative cycles, preceded by two additional life cycle activities:
 Feasibility study—establishes the basic business requirements and constraints
 associated with the application to be built and then assesses whether the applica
tion is a viable candidate for the DSDM process.
85
 CHAPTER 3 AGILE DEVELOPMENT
 DSDM is a process
 framework that can
 adopt the tactics of
 another agile approach
 such as XP.
 Crystal is a family of
 process models with
 the same “genetic
 code” but different
 methods for adapting
 to project
 characteristics.
 Business study—establishes the functional and information requirements that
 will allow the application to provide business value; also, defines the basic
 application architecture and identifies the maintainability requirements for the
 application.
 Functional model iteration—produces a set of incremental prototypes that
 demonstrate functionality for the customer. (Note: All DSDM prototypes are in
tended to evolve into the deliverable application.) The intent during this iterative
 cycle is to gather additional requirements by eliciting feedback from users as they
 exercise the prototype.
 Design and build iteration—revisits prototypes built during functional model
 iteration to ensure that each has been engineered in a manner that will enable it to
 provide operational business value for end users. In some cases, functional model
 iteration and design and build iteration occur concurrently.
 Implementation—places the latest software increment (an “operationalized” pro
totype) into the operational environment. It should be noted that (1) the increment
 may not be 100 percent complete or (2) changes may be requested as the incre
ment is put into place. In either case, DSDM development work continues by
 returning to the functional model iteration activity.
 DSDM can be combined with XP (Section 3.4) to provide a combination approach
 that defines a solid process model (the DSDM life cycle) with the nuts and bolts prac
tices (XP) that are required to build software increments. In addition, the ASD con
cepts of collaboration and self-organizing teams can be adapted to a combined
 process model.
 3.5.4 Crystal
 Alistair Cockburn [Coc05] and Jim Highsmith [Hig02b] created the Crystal family of
 agile methods15 in order to achieve a software development approach that puts a
 premium on “maneuverability” during what Cockburn characterizes as “a resource
limited, cooperative game of invention and communication, with a primary goal of
 delivering useful, working software and a secondary goal of setting up for the next
 game” [Coc02].
 To achieve maneuverability, Cockburn and Highsmith have defined a set of
 methodologies, each with core elements that are common to all, and roles, process
 patterns, work products, and practice that are unique to each. The Crystal family is
 actually a set of example agile processes that have been proven effective for differ
ent types of projects. The intent is to allow agile teams to select the member of the
 crystal family that is most appropriate for their project and environment.
 15 The name “crystal” is derived from the characteristics of geological crystals, each with its own
 color, shape, and hardness.
86
 PART ONE THE SOFTWARE PROCESS
 3.5.5 Feature Driven Development (FDD)
 WebRef
 A wide variety of
 articles and
 presentations on FDD
 can be found at:
 www.featuredrive
 ndevelopment
 .com/.
 Feature Driven Development (FDD) was originally conceived by Peter Coad and his
 colleagues [Coa99] as a practical process model for object-oriented software engi
neering. Stephen Palmer and John Felsing [Pal02] have extended and improved
 Coad’s work, describing an adaptive, agile process that can be applied to moderately
 sized and larger software projects.
 Like other agile approaches, FDD adopts a philosophy that (1) emphasizes col
laboration among people on an FDD team; (2) manages problem and project
 complexity using feature-based decomposition followed by the integration of
 software increments, and (3) communication of technical detail using verbal,
 graphical, and text-based means. FDD emphasizes software quality assurance
 activities by encouraging an incremental development strategy, the use of design
 and code inspections, the application of software quality assurance audits (Chap
ter 16), the collection of metrics, and the use of patterns (for analysis, design, and
 construction).
 In the context of FDD, a feature “is a client-valued function that can be imple
mented in two weeks or less” [Coa99]. The emphasis on the definition of features
 provides the following benefits:
 • Because features are small blocks of deliverable functionality, users can
 describe them more easily; understand how they relate to one another more
 readily; and better review them for ambiguity, error, or omissions.
 • Features can be organized into a hierarchical business-related grouping.
 • Since a feature is the FDD deliverable software increment, the team develops
 operational features every two weeks.
 • Because features are small, their design and code representations are easier
 to inspect effectively.
 • Project planning, scheduling, and tracking are driven by the feature
 hierarchy, rather than an arbitrarily adopted software engineering 
task set.
 Coad and his colleagues [Coa99] suggest the following template for defining a
 feature:
 <action> the <result> <by for of to> a(n) <object>
 where an <object> is “a person, place, or thing (including roles, moments in time or
 intervals of time, or catalog-entry-like descriptions).” Examples of features for an 
e-commerce application might be:
 Add the product to shopping cart
 Display the technical-specifications of the product
 Store the shipping-information for the customer
87
 CHAPTER 3 AGILE DEVELOPMENT
 FIGURE 3.5
 Feature Driven
 Development
 [Coa99] (with
 permission)
 Develop
 an
 Overall
 Model
 Build a
 Features
 List
 Plan
 By
 Feature
 Design
 By
 Feature
 (more shape
 than content)
 A list of features
 grouped into sets
 and subject areas
 A development plan
 Class owners
 Feature Set Owners
 A design
 package
 (sequences)
 Build
 By
 Feature
 Completed
 client-value
 function
 A feature set groups related features into business-related categories and is defined
 [Coa99] as:
 <action><-ing> a(n) <object>
 For example: Making a product sale is a feature set that would encompass the fea
tures noted earlier and others.
 The FDD approach defines five “collaborating” [Coa99] framework activities (in
 FDD these are called “processes”) as shown in Figure 3.5.
 FDD provides greater emphasis on project management guidelines and tech
niques than many other agile methods. As projects grow in size and complexity,
 ad hoc project management is often inadequate. It is essential for developers, their
 managers, and other stakeholders to understand project status—what accomplish
ments have been made and problems have been encountered. If deadline pressure
 is significant, it is critical to determine if software increments (features) are properly
 scheduled. To accomplish this, FDD defines six milestones during the design and
 implementation of a feature: “design walkthrough, design, design inspection, code,
 code inspection, promote to build” [Coa99].
 3.5.6 Lean Software Development (LSD)
 Lean Software Development (LSD) has adapted the principles of lean manufacturing
 to the world of software engineering. The lean principles that inspire the LSD process
 can be summarized ([Pop03], [Pop06a]) as eliminate waste, build quality in, create
 knowledge, defer commitment, deliver fast, respect people, and optimize the whole.
 Each of these principles can be adapted to the software process. For example,
 eliminate waste within the context of an agile software project can be interpreted
 to mean [Das05]: (1) adding no extraneous features or functions, (2) assessing the
 cost and schedule impact of any newly requested requirement, (3) removing any
 superfluous process steps, (4) establishing mechanisms to improve the way team
 members find information, (5) ensuring the testing finds as many errors as possible,
88
 PART ONE THE SOFTWARE PROCESS
 (6) reducing the time required to request and get a decision that affects the software
 or the process that is applied to create it, and (7) streamlining the manner in which
 information is transmitted to all stakeholders involved in the process.
 For a detailed discussion of LSD and pragmatic guidelines for implementing the
 process, you should examine [Pop06a] and [Pop06b].
 3.5.7 Agile Modeling (AM)
 WebRef
 Comprehensive
 information on agile
 modeling can be found
 at: www
 .agilemodeling.com.
 uote:
 “I was in the drug
 store the other day
 trying to get a cold
 medication . . . not
 easy. There’s an
 entire wall of
 products you need.
 You stand there
 going, Well, this
 one is quick acting
 but this is long
 lasting. . . . Which
 is more important,
 the present or the
 future?”
 Jerry Seinfeld
 There are many situations in which software engineers must build large, business
critical systems. The scope and complexity of such systems must be modeled so that
 (1) all constituencies can better understand what needs to be accomplished, (2) the
 problem can be partitioned effectively among the people who must solve it, and
 (3) quality can be assessed as the system is being engineered and built.
 Over the past 30 years, a wide variety of software engineering modeling methods
 and notation have been proposed for analysis and design (both architectural and
 component-level). These methods have merit, but they have proven to be difficult
 to apply and challenging to sustain (over many projects). Part of the problem is the
 “weight” of these modeling methods. By this I mean the volume of notation required,
 the degree of formalism suggested, the sheer size of the models for large projects,
 and the difficulty in maintaining the model(s) as changes occur. Yet analysis and de
sign modeling have substantial benefit for large projects—if for no other reason than
 to make these projects intellectually manageable. Is there an agile approach to soft
ware engineering modeling that might provide an alternative?
 At “The Official Agile Modeling Site,” Scott Ambler [Amb02a] describes agile mod
eling (AM) in the following manner:
 Agile Modeling (AM) is a practice-based methodology for effective modeling and documen
tation of software-based systems. Simply put, Agile Modeling (AM) is a collection of values,
 principles, and practices for modeling software that can be applied on a software develop
ment project in an effective and light-weight manner. Agile models are more effective than
 traditional models because they are just barely good, they don’t have to be perfect.
 Agile modeling adopts all of the values that are consistent with the agile manifesto.
 The agile modeling philosophy recognizes that an agile team must have the courage
 to make decisions that may cause it to reject a design and refactor. The team must
 also have the humility to recognize that technologists do not have all the answers and
 that business experts and other stakeholders should be respected and embraced.
 Although AM suggests a wide array of “core” and “supplementary” modeling prin
ciples, those that make AM unique are [Amb02a]:
 Model with a purpose. A developer who uses AM should have a specific
 goal (e.g., to communicate information to the customer or to help better un
derstand some aspect of the software) in mind before creating the model.
 Once the goal for the model is identified, the type of notation to be used and
 level of detail required will be more obvious.
89
 CHAPTER 3 AGILE DEVELOPMENT
 Use multiple models. There are many different models and notations that
 can be used to describe software. Only a small subset is essential for most
 projects. AM suggests that to provide needed insight, each model should
 present a different aspect of the system and only those models that provide
 value to their intended audience should be used.
 “Traveling light” is an
 appropriate philosophy
 for all software engi
neering work. Build
 only those models that
 provide value … no
 more, no less.
 Travel light. As software engineering work proceeds, keep only those mod
els that will provide long-term value and jettison the rest. Every work product
 that is kept must be maintained as changes occur. This represents work that
 slows the team down. Ambler [Amb02a] notes that “Every time you decide to
 keep a model you trade-off agility for the convenience of having that informa
tion available to your team in an abstract manner (hence potentially enhanc
ing communication within your team as well as with project stakeholders).”
 Content is more important than representation. Modeling should im
part information to its intended audience. A syntactically perfect model that
 imparts little useful content is not as valuable as a model with flawed nota
tion that nevertheless provides valuable content for its audience.
 Know the models and the tools you use to create them. Understand
 the strengths and weaknesses of each model and the tools that are used to
 create it.
 Adapt locally. The modeling approach should be adapted to the needs of
 the agile team.
 A major segment of the software engineering community has adopted the Unified
 Modeling Language (UML)16 as the preferred method for representing analysis and
 design models. The Unified Process (Chapter 2) has been developed to provide a
 framework for the application of UML. Scott Ambler [Amb06] has developed a sim
plified version of the UP that integrates his agile modeling philosophy.
 3.5.8 Agile Unified Process (AUP)
 The Agile Unified Process (AUP) adopts a “serial in the large” and “iterative in the
 small” [Amb06] philosophy for building computer-based systems. By adopting the
 classic UP phased activities—inception, elaboration, construction, and transition—AUP
 provides a serial overlay (i.e., a linear sequence of software engineering activities)
 that enables a team to visualize the overall process flow for a software project. How
ever, within each of the activities, the team iterates to achieve agility and to deliver
 meaningful software increments to end users as rapidly as possible. Each AUP iter
ation addresses the following activities [Amb06]: 
• Modeling. UML representations of the business and problem domains are
 created. However, to stay agile, these models should be “just barely good
 enough” [Amb06] to allow the team to proceed.
 16 A brief tutorial on UML is presented in Appendix 1.
90
 PART ONE THE SOFTWARE PROCESS
 • Implementation. Models are translated into source code.
 • Testing. Like XP, the team designs and executes a series of tests to uncover
 errors and ensure that the source code meets its requirements.
 • Deployment. Like the generic process activity discussed in Chapters 1 and 2,
 deployment in this context focuses on the delivery of a software increment
 and the acquisition of feedback from end users.
 • Configuration and project management. In the context of AUP, configuration
 management (Chapter 22) addresses change management, risk manage
ment, and the control of any persistent work products17 that are produced by
 the team. Project management tracks and controls the progress of the team
 and coordinates team activities.
 • Environment management. Environment management coordinates a process
 infrastructure that includes standards, tools, and other support technology
 available to the team.
 Although the AUP has historical and technical connections to the Unified Modeling
 Language, it is important to note that UML modeling can be using in conjunction
 with any of the agile process models described in Section 3.5.
 SOFTWARE TOOLS
 Agile Development
 Objective: The objective of agile development
 tools is to assist in one or more aspects of agile
 development with an emphasis on facilitating the rapid
 generation of operational software. These tools can also
 be used when prescriptive process models (Chapter 2) are
 applied.
 Mechanics: Tool mechanics vary. In general, agile tool
 sets encompass automated support for project planning,
 use case development and requirements gathering, rapid
 design, code generation, and testing.
 Representative Tools:18
 Note: Because agile development is a hot topic, most
 software tools vendors purport to sell tools that support 
the agile approach. The tools noted here have
 characteristics that make them particularly useful for
 agile projects.
 OnTime, developed by Axosoft (www.axosoft.com),
 provides agile process management support for
 various technical activities within the process.
 Ideogramic UML, developed by Ideogramic
 (www.ideogramic.com) is a UML tool set
 specifically developed for use within an agile 
process.
 Together Tool Set, distributed by Borland
 (www.borland.com), provides a tools suite that
 supports many technical activities within XP and other
 agile processes.
 17 A persistent work product is a model or document or test case produced by the team that will be kept
 for an indeterminate period of time. It will not be discarded once the software increment is
 delivered.
 18 Tools noted here do not represent an endorsement, but rather a sampling of tools in this category.
 In most cases, tool names are trademarked by their respective developers.
91
 CHAPTER 3 AGILE DEVELOPMENT
 3.6 A TOOL SET FOR THE AGILE PROCESS
 The “tool set” that
 supports agile
 processes focuses
 more on people issues
 than it does on
 technology issues.
 Some proponents of the agile philosophy argue that automated software tools (e.g.,
 design tools) should be viewed as a minor supplement to the team’s activities, and
 not at all pivotal to the success of the team. However, Alistair Cockburn [Coc04] sug
gests that tools can have a benefit and that “agile teams stress using tools that per
mit the rapid flow of understanding. Some of those tools are social, starting even at
 the hiring stage. Some tools are technological, helping distributed teams simulate
 being physically present. Many tools are physical, allowing people to manipulate
 them in workshops.”
 Because acquiring the right people (hiring), team collaboration, stakeholder com
munication, and indirect management are key elements in virtually all agile process
 models, Cockburn argues that “tools” that address these issues are critical success
 factors for agility. For example, a hiring “tool” might be the requirement to have a
 prospective team member spend a few hours pair programming with an existing
 member of the team. The “fit” can be assessed immediately.
 Collaborative and communication “tools” are generally low tech and incorporate
 any mechanism (“physical proximity, whiteboards, poster sheets, index cards, and
 sticky notes” [Coc04]) that provides information and coordination among agile de
velopers. Active communication is achieved via the team dynamics (e.g., pair pro
gramming), while passive communication is achieved by “information radiators”
 (e.g., a flat panel display that presents the overall status of different components of
 an increment). Project management tools deemphasize the Gantt chart and replace
 it with earned value charts or “graphs of tests created versus passed . . . other agile
 tools are used to optimize the environment in which the agile team works (e.g., more
 efficient meeting areas), improve the team culture by nurturing social interactions
 (e.g., collocated teams), physical devices (e.g., electronic whiteboards), and process
 enhancement (e.g., pair programming or time-boxing)” [Coc04].
 Are any of these things really tools? They are, if they facilitate the work performed
 by an agile team member and enhance the quality of the end product.
 3.7 SUMMARY
 In a modern economy, market conditions change rapidly, customer and end-user
 needs evolve, and new competitive threats emerge without warning. Practitioners
 must approach software engineering in a manner that allows them to remain agile—
 to define maneuverable, adaptive, lean processes that can accommodate the needs
 of modern business.
 An agile philosophy for software engineering stresses four key issues: the impor
tance of self-organizing teams that have control over the work they perform, com
munication and collaboration between team members and between practitioners
 and their customers, a recognition that change represents an opportunity, and
92
 PART ONE THE SOFTWARE PROCESS
 an emphasis on rapid delivery of software that satisfies the customer. Agile process
 models have been designed to address each of these issues.
 Extreme programming (XP) is the most widely used agile process. Organized as
 four framework activities—planning, design, coding, and testing—XP suggests a
 number of innovative and powerful techniques that allow an agile team to create
 frequent software releases that deliver features and functionality that have been de
scribed and then prioritized by stakeholders.
 Other agile process models also stress human collaboration and team self
organization, but define their own framework activities and select different points of
 emphasis. For example, ASD uses an iterative process that incorporates adaptive
 cycle planning, relatively rigorous requirement gathering methods, and an iterative
 development cycle that incorporates customer focus groups and formal technical re
views as real-time feedback mechanisms. Scrum emphasizes the use of a set of soft
ware process patterns that have proven effective for projects with tight time lines,
 changing requirements, and business criticality. Each process pattern defines a set
 of development tasks and allows the Scrum team to construct a process that is
 adapted to the needs of the project. The Dynamic Systems Development Method
 (DSDM) advocates the use of time-box scheduling and suggests that only enough
 work is required for each software increment to facilitate movement to the next
 increment. Crystal is a family of agile process models that can be adopted to the spe
cific characteristics of a project.
 Feature Driven Development (FDD) is somewhat more “formal” than other agile
 methods, but still maintains agility by focusing the project team on the development
 of features—a client-valued function that can be implemented in two weeks or less.
 Lean Software Development (LSD) has adapted the principles of lean manufacturing
 to the world of software engineering. Agile modeling (AM) suggests that modeling is
 essential for all systems, but that the complexity, type, and size of the model must be
 tuned to the software to be built. The Agile Unified Process (AUP) adopts a “serial in
 the large” and “iterative in the small” philosophy for building software.
 PROBLEMS AND POINTS TO PONDER
 3.1. Reread “The Manifesto for Agile Software Development” at the beginning of this chapter.
 Can you think of a situation in which one or more of the four “values” could get a software team
 into trouble?
 3.2. Describe agility (for software projects) in your own words.
 3.3. Why does an iterative process make it easier to manage change? Is every agile process dis
cussed in this chapter iterative? Is it possible to complete a project in just one iteration and still
 be agile? Explain your answers.
 3.4. Could each of the agile processes be described using the generic framework activities
 noted in Chapter 2? Build a table that maps the generic activities into the activities defined for
 each agile process.
 3.5. Try to come up with one more “agility principle” that would help a software engineering
 team become even more maneuverable.
93
 CHAPTER 3 AGILE DEVELOPMENT
 3.6. Select one agility principle noted in Section 3.3.1 and try to determine whether each of the
 process models presented in this chapter exhibits the principle. [Note: I have presented an
 overview of these process models only, so it may not be possible to determine whether a prin
ciple has been addressed by one or more of the models, unless you do additional research
 (which is not required for this problem).]
 3.7. Why do requirements change so much? After all, don’t people know what they want?
 3.8. Most agile process models recommend face-to-face communication. Yet today, members
 of a software team and their customers may be geographically separated from one another. Do
 you think this implies that geographical separation is something to avoid? Can you think of ways
 to overcome this problem?
 3.9. Write an XP user story that describes the “favorite places” or “bookmarks” feature avail
able on most Web browsers.
 3.10. What is a spike solution in XP?
 3.11. Describe the XP concepts of refactoring and pair programming in your own words.
 3.12. Do a bit more reading and describe what a time-box is. How does this assist an ASD team
 in delivering software increments in a short time period?
 3.13. Do the 80 percent rule in DSDM and the time-boxing approach defined for ASD achieve
 the same result?
 3.14. Using the process pattern template presented in Chapter 2, develop a process pattern for
 any one of the Scrum patterns presented in Section 3.5.2.
 3.15. Why is Crystal called a family of agile methods?
 3.16. Using the FDD feature template described in Section 3.5.5, define a feature set for a Web
 browser. Now develop a set of features for the feature set.
 3.17. Visit the Official Agile Modeling Site and make a complete list of all core and supple
mentary AM principles.
 3.18. The tool set proposed in Section 3.6 supports many of the “soft” aspects of agile meth
ods. Since communication is so important, recommend an actual tool set that might be used to
 enhance communication among stakeholders on an agile team.
 FURTHER READINGS AND INFORMATION SOURCES
 The overall philosophy and underlying principles of agile software development are considered
 in depth in many of the books referenced in the body of this chapter. In addition, books by Shaw
 and Warden (The Art of Agile Development, O’Reilly Media, Inc., 2008), Hunt (Agile Software Con
struction, Springer, 2005), and Carmichael and Haywood (Better Software Faster, Prentice-Hall,
 2002) present useful discussions of the subject. Aguanno (Managing Agile Projects, Multi
Media Publications, 2005), Highsmith (Agile Project Management: Creating Innovative Products,
 Addison-Wesley, 2004), and Larman (Agile and Iterative Development: A Manager’s Guide,
 Addison-Wesley, 2003) present a management overview and consider project management
 issues. Highsmith (Agile Software Development Ecosystems, Addison-Wesley, 2002) presents a
 survey of agile principles, processes, and practices. A worthwhile discussion of the delicate bal
ance between agility and discipline is presented by Booch and his colleagues (Balancing Agility
 and Discipline, Addison-Wesley, 2004).
 Martin (Clean Code: A Handbook of Agile Software Craftsmanship, Prentice-Hall, 2009) pres
ents the principles, patterns, and practices required to develop “clean code” in an agile software
 engineering environment. Leffingwell (Scaling Software Agility: Best Practices for Large Enter
prises, Addison-Wesley, 2007) discusses strategies for scaling up agile practices for large proj
ects. Lippert and Rook (Refactoring in Large Software Projects: Performing Complex Restructurings
 Successfully, Wiley, 2006) discuss the use of refactoring when applied in large, complex systems.
94
 PART ONE THE SOFTWARE PROCESS
 Stamelos and Sfetsos (Agile Software Development Quality Assurance, IGI Global, 2007) discuss
 SQA techniques that conform to the agile philosophy.
 Dozens of books have been written about Extreme Programming over the past decade. Beck
 (Extreme Programming Explained: Embrace Change, 2d ed., Addison-Wesley, 2004) remains the
 definitive treatment of the subject. In addition, Jeffries and his colleagues (Extreme Programming
 Installed, Addison-Wesley, 2000), Succi and Marchesi (Extreme Programming Examined,
 Addison-Wesley, 2001), Newkirk and Martin (Extreme Programming in Practice, Addison-Wesley,
 2001), and Auer and his colleagues (Extreme Programming Applied: Play to Win, Addison-Wesley,
 2001) provide a nuts-and-bolts discussion of XP along with guidance on how best to apply it.
 McBreen (Questioning Extreme Programming, Addison-Wesley, 2003) takes a critical look at XP,
 defining when and where it is appropriate. An in-depth consideration of pair programming is
 presented by McBreen (Pair Programming Illuminated, Addison-Wesley, 2003).
 ASD is addressed in depth by Highsmith [Hig00]. Schwaber (The Enterprise and Scrum,
 Microsoft Press, 2007) discusses the use of Scrum for projects that have a major business
 impact. The nuts and bolts of Scrum are discussed by Schwaber and Beedle (Agile Software
 Development with SCRUM, Prentice-Hall, 2001). Worthwhile treatments of DSDM have been
 written by the DSDM Consortium (DSDM: Business Focused Development, 2d ed., Pearson Edu
cation, 2003) and Stapleton (DSDM: The Method in Practice, Addison-Wesley, 1997). Cockburn
 (Crystal Clear, Addison-Wesley, 2005) presents an excellent overview of the Crystal family of
 processes. Palmer and Felsing [Pal02] present a detailed treatment of FDD. Carmichael and
 Haywood (Better Software Faster, Prentice-Hall, 2002) provides another useful treatment of FDD
 that includes a step-by-step journey through the mechanics of the process. Poppendieck and 
Poppendieck (Lean Development: An Agile Toolkit for Software Development Managers, Addison
Wesley, 2003) provide guidelines for managing and controlling agile projects. Ambler and
 Jeffries (Agile Modeling, Wiley, 2002) discuss AM in some depth.
 A wide variety of information sources on agile software development are available on the
 Internet. An up-to-date list of World Wide Web references that are relevant to the agile process
 can be found at the SEPA website: www.mhhe.com/engcs/compsci/pressman/
 professional/olc/ser.htm.
In 2001, Kent Beck and 16 other noted software developers, writers, and con
sultants [Bec01a] (referred to as the “Agile Alliance”) signed the “Manifesto for
 Agile Software Development.” It stated:
 We are uncovering better ways of developing software by doing it and helping others
 do it. Through this work we have come to value: 
Individuals and interactions over processes and tools
 Working software over comprehensive documentation
 Customer collaboration over contract negotiation
 Responding to change over following a plan
 That is, while there is value in the items on the right, we value the items on the 
left more.
 QUICK
 LOOK
 What is it? Agile software engi
neering combines a philosophy and
 a set of development guidelines. The
 philosophy encourages customer
 satisfaction and early incremental delivery of
 software; small, highly motivated project teams;
 informal methods; minimal software engineer
ing work products; and overall development
 simplicity. The development guidelines stress
 delivery over analysis and design (although
 these activities are not discouraged), and active
 and continuous communication between devel
opers and customers.
 Who does it? Software engineers and other
 project stakeholders (managers, customers, end
 users) work together on an agile team—a team
 that is self-organizing and in control of its own
 destiny. An agile team fosters communication
 and collaboration among all who serve on it.
 Why is it important? The modern business envi
ronment that spawns computer-based systems
 and software products is fast-paced and ever
changing. Agile software engineering repre
sents a reasonable alternative to conventional
 software engineering for certain classes of soft
ware and certain types of software projects. It
 has been demonstrated to deliver successful sys
tems quickly.
 Whatarethesteps? Agiledevelopmentmightbest
 be termed “software engineering lite.” The basic
 framework activities—communication, planning,
 modeling, construction, and deployment—
 remain. But they morph into a minimal task set
 that pushes the project team toward construction
 and delivery (some would argue that this is
 done at the expense of problem analysis and
 solution design).
 What is the work product? Both the customer
 and the software engineer have the same
 view—the only really important work product
 is an operational “software increment” that is
 delivered to the customer on the appropriate
 commitment date.
 How do I ensure that I’ve done it right? If the
 agile team agrees that the process works, and
 the team produces deliverable software
 increments that satisfy the customer, you’ve
 done it right.
 65
66
 PART ONE THE SOFTWARE PROCESS
 FDD . . . . . . . . . .86
 Industrial XP . . .77
 Lean Software
 Development . . .87
 pair 
programming . . .76
 project 
velocity . . . . . . .74
 refactoring . . . . .75
 Scrum . . . . . . . .82
 stories . . . . . . . .74
 XP process . . . . .73
 uote:
 “Agility: 1,
 everything else: 0.”
 Tom DeMarco
 A manifesto is normally associated with an emerging political movement—one
 that attacks the old guard and suggests revolutionary change (hopefully for the
 better). In some ways, that’s exactly what agile development is all about.
 Although the underlying ideas that guide agile development have been with us for
 many years, it has been less than two decades since these ideas have crystallized
 into a “movement.” In essence, agile1 methods were developed in an effort to over
come perceived and actual weaknesses in conventional software engineering. Agile
 development can provide important benefits, but it is not applicable to all projects,
 all products, all people, and all situations. It is also not antithetical to solid software
 engineering practice and can be applied as an overriding philosophy for all software
 work.
 In the modern economy, it is often difficult or impossible to predict how a
 computer-based system (e.g., a Web-based application) will evolve as time passes.
 Market conditions change rapidly, end-user needs evolve, and new competitive
 threats emerge without warning. In many situations, you won’t be able to define
 requirements fully before the project begins. You must be agile enough to respond to
 a fluid business environment.
 Fluidity implies change, and change is expensive. Particularly if it is uncontrolled
 or poorly managed. One of the most compelling characteristics of the agile approach
 is its ability to reduce the costs of change throughout the software process.
 Does this mean that a recognition of challenges posed by modern realities causes
 you to discard valuable software engineering principles, concepts, methods, and
 tools? Absolutely not! Like all engineering disciplines, software engineering contin
ues to evolve. It can be adapted easily to meet the challenges posed by a demand for
 agility.
 In a thought-provoking book on agile software development, Alistair Cockburn
 [Coc02] argues that the prescriptive process models introduced in Chapter 2 have a
 major failing: they forget the frailties of the people who build computer software. Software
 engineers are not robots. They exhibit great variation in working styles; significant dif
ferences in skill level, creativity, orderliness, consistency, and spontaneity. Some com
municate well in written form, others do not. Cockburn argues that process models
 can “deal with people’s common weaknesses with [either] discipline or tolerance” and
 that most prescriptive process models choose discipline. He states: “Because consis
tency in action is a human weakness, high discipline methodologies are fragile.”
 If process models are to work, they must provide a realistic mechanism for en
couraging the discipline that is necessary, or they must be characterized in a man
ner that shows “tolerance” for the people who do software engineering work.
 Invariably, tolerant practices are easier for software people to adopt and sustain, but
 (as Cockburn admits) they may be less productive. Like most things in life, trade-offs
 must be considered.
 1 Agile methods are sometimes referred to as light methods or lean methods.
67
 CHAPTER 3 AGILE DEVELOPMENT
 3.1 WHAT IS AGILITY?
 Just what is agility in the context of software engineering work? Ivar Jacobson
 [Jac02a] provides a useful discussion:
 Agility has become today’s buzzword when describing a modern software process. Every
one is agile. An agile team is a nimble team able to appropriately respond to changes.
 Change is what software development is very much about. Changes in the software be
ing built, changes to the team members, changes because of new technology, changes of
 all kinds that may have an impact on the product they build or the project that creates the
 product. Support for changes should be built-in everything we do in software, something
 we embrace because it is the heart and soul of software. An agile team recognizes that
 software is developed by individuals working in teams and that the skills of these people,
 their ability to collaborate is at the core for the success of the project.
 Don’t make the
 mistake of assuming
 that agility gives you
 license to hack out
 solutions. A process is
 required and discipline
 is essential.
 In Jacobson’s view, the pervasiveness of change is the primary driver for agility. Soft
ware engineers must be quick on their feet if they are to accommodate the rapid
 changes that Jacobson describes.
 But agility is more than an effective response to change. It also encompasses the
 philosophy espoused in the manifesto noted at the beginning of this chapter. It
 encourages team structures and attitudes that make communication (among team
 members, between technologists and business people, between software engineers
 and their managers) more facile. It emphasizes rapid delivery of operational soft
ware and de-emphasizes the importance of intermediate work products (not always
 a good thing); it adopts the customer as a part of the development team and works
 to eliminate the “us and them” attitude that continues to pervade many software
 projects; it recognizes that planning in an uncertain world has its limits and that a
 project plan must be flexible.
 Agility can be applied to any software process. However, to accomplish this, it is
 essential that the process be designed in a way that allows the project team to adapt
 tasks and to streamline them, conduct planning in a way that understands the fluid
ity of an agile development approach, eliminate all but the most essential work prod
ucts and keep them lean, and emphasize an incremental delivery strategy that gets
 working software to the customer as rapidly as feasible for the product type and
 operational environment.
 3.2 AGILITY AND THE COST OF CHANGE
 The conventional wisdom in software development (supported by decades of expe
rience) is that the cost of change increases nonlinearly as a project progresses
 (Figure 3.1, solid black curve). It is relatively easy to accommodate a change when a
 software team is gathering requirements (early in a project). A usage scenario might
 have to be modified, a list of functions may be extended, or a written specification
 can be edited. The costs of doing this work are minimal, and the time required will
68
 PART ONE THE SOFTWARE PROCESS
 FIGURE 3.1
 Change costs
 as a function
 of time in
 development
 uote:
 Development cost
 Cost of change
 using conventional
 software processes
 Cost of change
 using agile processes
 “Agility is dynamic,
 content specific,
 aggressively
 change embracing,
 and growth
 oriented.”
 Idealized cost of change
 using agile process
 Development schedule progress–Steven
 Goldman et al.
 An agile process
 reduces the cost of
 change because
 software is released in
 increments and change
 can be better
 controlled within an
 increment.
 not adversely affect the outcome of the project. But what if we fast-forward a num
ber of months? The team is in the middle of validation testing (something that occurs
 relatively late in the project), and an important stakeholder is requesting a major
 functional change. The change requires a modification to the architectural design of
 the software, the design and construction of three new components, modifications
 to another five components, the design of new tests, and so on. Costs escalate
 quickly, and the time and cost required to ensure that the change is made without
 unintended side effects is nontrivial.
 Proponents of agility (e.g., [Bec00], [Amb04]) argue that a well-designed agile
 process “flattens” the cost of change curve (Figure 3.1, shaded, solid curve), allowing
 a software team to accommodate changes late in a software project without dramatic
 cost and time impact. You’ve already learned that the agile process encompasses in
cremental delivery. When incremental delivery is coupled with other agile practices
 such as continuous unit testing and pair programming (discussed later in this chap
ter), the cost of making a change is attenuated. Although debate about the degree to
 which the cost curve flattens is ongoing, there is evidence [Coc01a] to suggest that a
 significant reduction in the cost of change can be achieved.
 3.3 WHAT IS ANAGILE PROCESS?
 Any agile software process is characterized in a manner that addresses a number of
 key assumptions [Fow02] about the majority of software projects: 
1. It is difficult to predict in advance which software requirements will persist
 and which will change. It is equally difficult to predict how customer
 priorities will change as the project proceeds.
69
 CHAPTER 3 AGILE DEVELOPMENT
 WebRef
 A comprehensive
 collection of articles on
 the agile process 
can be found at
 www.aanpo.org/
 articles/index.
 Although agile
 processes embrace
 change, it is still
 important to examine
 the reasons for
 change.
 Working software is
 important, but don’t
 forget that it must also
 exhibit a variety of
 quality attributes
 including reliability,
 usability, and 
maintainability.
 2. For many types of software, design and construction are interleaved. That is,
 both activities should be performed in tandem so that design models are
 proven as they are created. It is difficult to predict how much design is
 necessary before construction is used to prove the design.
 3. Analysis, design, construction, and testing are not as predictable (from a
 planning point of view) as we might like.
 Given these three assumptions, an important question arises: How do we create a
 process that can manage unpredictability? The answer, as I have already noted, lies
 in process adaptability (to rapidly changing project and technical conditions). An
 agile process, therefore, must be adaptable.
 But continual adaptation without forward progress accomplishes little. Therefore,
 an agile software process must adapt incrementally. To accomplish incremental adap
tation, an agile team requires customer feedback (so that the appropriate adaptations
 can be made). An effective catalyst for customer feedback is an operational prototype
 or a portion of an operational system. Hence, an incremental development strategy
 should be instituted. Software increments (executable prototypes or portions of an op
erational system) must be delivered in short time periods so that adaptation keeps pace
 with change (unpredictability). This iterative approach enables the customer to evalu
ate the software increment regularly, provide necessary feedback to the software team,
 and influence the process adaptations that are made to accommodate the feedback.
 3.3.1 Agility Principles
 The Agile Alliance (see [Agi03], [Fow01]) defines 12 agility principles for those who
 want to achieve agility: 
1. Our highest priority is to satisfy the customer through early and continuous
 delivery of valuable software.
 2. Welcome changing requirements, even late in development. Agile processes
 harness change for the customer’s competitive advantage.
 3. Deliver working software frequently, from a couple of weeks to a couple of
 months, with a preference to the shorter timescale.
 4. Business people and developers must work together daily throughout the
 project.
 5. Build projects around motivated individuals. Give them the environment and
 support they need, and trust them to get the job done.
 6. The most efficient and effective method of conveying information to and
 within a development team is face-to-face conversation.
 7. Working software is the primary measure of progress.
 8. Agile processes promote sustainable development. The sponsors, developers,
 and users should be able to maintain a constant pace indefinitely.
70
 PART ONE THE SOFTWARE PROCESS
 9. Continuous attention to technical excellence and good design enhances
 agility.
 10. Simplicity—the art of maximizing the amount of work not done—is 
essential.
 11. The best architectures, requirements, and designs emerge from self
organizing teams.
 12. At regular intervals, the team reflects on how to become more effective, then
 tunes and adjusts its behavior accordingly.
 Not every agile process model applies these 12 principles with equal weight, and
 some models choose to ignore (or at least downplay) the importance of one or more
 of the principles. However, the principles define an agile spirit that is maintained in
 each of the process models presented in this chapter.
 3.3.2 The Politics of Agile Development
 You don’t have to
 choose between agility
 and software engi
neering. Rather, define
 a software engineering
 approach that is agile.
 There is considerable debate (sometimes strident) about the benefits and applicabil
ity of agile software development as opposed to more conventional software engi
neering processes. Jim Highsmith [Hig02a] (facetiously) states the extremes when he
 characterizes the feeling of the pro-agility camp (“agilists”). “Traditional methodolo
gists are a bunch of stick-in-the-muds who’d rather produce flawless documentation
 than a working system that meets business needs.” As a counterpoint, he states
 (again, facetiously) the position of the traditional software engineering camp: “Light
weight, er, ‘agile’ methodologists are a bunch of glorified hackers who are going to
 be in for a heck of a surprise when they try to scale up their toys into enterprise-wide
 software.”
 Like all software technology arguments, this methodology debate risks degener
ating into a religious war. If warfare breaks out, rational thought disappears and
 beliefs rather than facts guide decision making.
 No one is against agility. The real question is: What is the best way to achieve it?
 As important, how do you build software that meets customers’ needs today and
 exhibits the quality characteristics that will enable it to be extended and scaled to
 meet customers’ needs over the long term?
 There are no absolute answers to either of these questions. Even within the agile
 school itself, there are many proposed process models (Section 3.4), each with a
 subtly different approach to the agility problem. Within each model there is a set of
 “ideas” (agilists are loath to call them “work tasks”) that represent a significant
 departure from traditional software engineering. And yet, many agile concepts are
 simply adaptations of good software engineering concepts. Bottom line: there is
 much that can be gained by considering the best of both schools and virtually
 nothing to be gained by denigrating either approach.
 If you have further interest, see [Hig01], [Hig02a], and [DeM02] for an entertain
ing summary of other important technical and political issues.
71
 CHAPTER 3 AGILE DEVELOPMENT
 uote:
 “Agile methods
 derive much of
 their agility by
 relying on the
 tacit knowledge
 embodied in the
 team, rather than
 writing the
 knowledge down
 in plans.”
 Barry Boehm
 ?
 What key
 traits must
 exist among the
 people on an
 effective software
 team?
 uote:
 “What counts as
 barely sufficient
 for one team is
 either overly
 sufficient or
 insufficient for
 another.”
 Alistair
 Cockburn
 3.3.3 Human Factors
 Proponents of agile software development take great pains to emphasize the impor
tance of “people factors.” As Cockburn and Highsmith [Coc01a] state, “Agile devel
opment focuses on the talents and skills of individuals, molding the process to
 specific people and teams.” The key point in this statement is that the process molds
 to the needs of the people and team, not the other way around.2
 If members of the software team are to drive the characteristics of the process that
 is applied to build software, a number of key traits must exist among the people on
 an agile team and the team itself:
 Competence. In an agile development (as well as software engineering)
 context, “competence” encompasses innate talent, specific software-related
 skills, and overall knowledge of the process that the team has chosen to
 apply. Skill and knowledge of process can and should be taught to all people
 who serve as agile team members.
 Common focus. Although members of the agile team may perform differ
ent tasks and bring different skills to the project, all should be focused on one
 goal—to deliver a working software increment to the customer within the
 time promised. To achieve this goal, the team will also focus on continual
 adaptations (small and large) that will make the process fit the needs of the
 team.
 Collaboration. Software engineering (regardless of process) is about as
sessing, analyzing, and using information that is communicated to the soft
ware team; creating information that will help all stakeholders understand
 the work of the team; and building information (computer software and rele
vant databases) that provides business value for the customer. To accomplish
 these tasks, team members must collaborate—with one another and all other
 stakeholders.
 Decision-making ability. Any good software team (including agile teams)
 must be allowed the freedom to control its own destiny. This implies that the
 team is given autonomy—decision-making authority for both technical and
 project issues.
 Fuzzy problem-solving ability. Software managers must recognize that
 the agile team will continually have to deal with ambiguity and will continu
ally be buffeted by change. In some cases, the team must accept the fact that
 the problem they are solving today may not be the problem that needs to be
 solved tomorrow. However, lessons learned from any problem-solving
 2 Successful software engineering organizations recognize this reality regardless of the process
 model they choose.
72
 PART ONE THE SOFTWARE PROCESS
 A self-organizing team
 is in control of the
 work it performs. The
 team makes its own
 commitments and
 defines plans to
 achieve them.
 activity (including those that solve the wrong problem) may be of benefit to
 the team later in the project.
 Mutual trust and respect. The agile team must become what DeMarco
 and Lister [DeM98] call a “jelled” team (Chapter 24). A jelled team exhibits
 the trust and respect that are necessary to make them “so strongly knit that
 the whole is greater than the sum of the parts.” [DeM98]
 Self-organization. In the context of agile development, self-organization
 implies three things: (1) the agile team organizes itself for the work to be
 done, (2) the team organizes the process to best accommodate its local envi
ronment, (3) the team organizes the work schedule to best achieve delivery
 of the software increment. Self-organization has a number of technical bene
fits, but more importantly, it serves to improve collaboration and boost team
 morale. In essence, the team serves as its own management. Ken Schwaber
 [Sch02] addresses these issues when he writes: “The team selects how much
 work it believes it can perform within the iteration, and the team commits to
 the work. Nothing demotivates a team as much as someone else making
 commitments for it. Nothing motivates a team as much as accepting the
 responsibility for fulfilling commitments that it made itself.”
 3.4 EXTREME PROGRAMMING (XP)
 In order to illustrate an agile process in a bit more detail, I’ll provide you with an
 overview of Extreme Programming (XP), the most widely used approach to agile soft
ware development. Although early work on the ideas and methods associated with
 XP occurred during the late 1980s, the seminal work on the subject has been written
 by Kent Beck [Bec04a]. More recently, a variant of XP, called Industrial XP (IXP) has
 been proposed [Ker05]. IXP refines XP and targets the agile process specifically for
 use within large organizations.
 3.4.1 XP Values
 Beck [Bec04a] defines a set of five values that establish a foundation for all work per
formed as part of XP—communication, simplicity, feedback, courage, and respect. Each
 of these values is used as a driver for specific XP activities, actions, and tasks.
 In order to achieve effective communication between software engineers and
 other stakeholders (e.g., to establish required features and functions for the soft
ware), XP emphasizes close, yet informal (verbal) collaboration between customers
 and developers, the establishment of effective metaphors3 for communicating
 important concepts, continuous feedback, and the avoidance of voluminous docu
mentation as a communication medium.
 3 In the XP context, a metaphor is “a story that everyone—customers, programmers, and managers—
 can tell about how the system works” [Bec04a].
73
 CHAPTER 3 AGILE DEVELOPMENT
 Keep it simple
 whenever you can, but
 recognize that
 continual “refactoring”
 can absorb significant
 time and resources.
 uote:
 “XP is the answer
 to the question,
 ‘How little can we
 do and still build
 great software?’“
 Anonymous
 WebRef
 An excellent overview
 of “rules” for XP can
 be found at www
 .extremeprogramm
 ing.org/rules.html.
 To achieve simplicity, XP restricts developers to design only for immediate needs,
 rather than consider future needs. The intent is to create a simple design that can be
 easily implemented in code). If the design must be improved, it can be refactored4 at
 a later time.
 Feedback is derived from three sources: the implemented software itself, the
 customer, and other software team members. By designing and implementing an
 effective testing strategy (Chapters 17 through 20), the software (via test results) pro
vides the agile team with feedback. XP makes use of the unit test as its primary test
ing tactic. As each class is developed, the team develops a unit test to exercise each
 operation according to its specified functionality. As an increment is delivered to a
 customer, the user stories or use cases (Chapter 5) that are implemented by the
 increment are used as a basis for acceptance tests. The degree to which the software
 implements the output, function, and behavior of the use case is a form of feedback.
 Finally, as new requirements are derived as part of iterative planning, the team pro
vides the customer with rapid feedback regarding cost and schedule impact.
 Beck [Bec04a] argues that strict adherence to certain XP practices demands
 courage. A better word might be discipline. For example, there is often significant
 pressure to design for future requirements. Most software teams succumb, arguing
 that “designing for tomorrow” will save time and effort in the long run. An agile XP
 team must have the discipline (courage) to design for today, recognizing that future
 requirements may change dramatically, thereby demanding substantial rework of
 the design and implemented code.
 By following each of these values, the agile team inculcates respect among it
 members, between other stakeholders and team members, and indirectly, for the
 software itself. As they achieve successful delivery of software increments, the team
 develops growing respect for the XP process.
 3.4.2 The XP Process
 Extreme Programming uses an object-oriented approach (Appendix 2) as its pre
ferred development paradigm and encompasses a set of rules and practices that
 occur within the context of four framework activities: planning, design, coding, and
 testing. Figure 3.2 illustrates the XP process and notes some of the key ideas and
 tasks that are associated with each framework activity. Key XP activities are sum
marized in the paragraphs that follow.
 Planning. The planning activity (also called the planning game) begins with
 listening—a requirements gathering activity that enables the technical members of
 the XP team to understand the business context for the software and to get a broad
 4 Refactoring allows a software engineer to improve the internal structure of a design (or source
 code) without changing its external functionality or behavior. In essence, refactoring can be used
 to improve the efficiency, readability, or performance of a design or the code that implements a
 design.
74
 PART ONE THE SOFTWARE PROCESS
 FIGURE 3.2
 The Extreme
 Programming
 process
 ?
 What is an
 XP “story”?
 WebRef
 A worthwhile XP
 “planning game” can
 be found at:
 c2.com/cgi/
 wiki?planningGame.
 simple design
 CRC cards
 user stories
 values
 acceptance test criteria
 iteration plan
 Release
 spike solutions
 prototypes
 refactoring
 design
 pair programming
 planning
 software increment
 project velocity computed
 unit test
 continuous integration
 acceptance testing
 test
 coding
 feel for required output and major features and functionality. Listening leads to the
 creation of a set of “stories” (also called user stories) that describe required output,
 features, and functionality for software to be built. Each story (similar to use cases
 described in Chapter 5) is written by the customer and is placed on an index card.
 The customer assigns a value (i.e., a priority) to the story based on the overall busi
ness value of the feature or function.5 Members of the XP team then assess each
 story and assign a cost—measured in development weeks—to it. If the story is esti
mated to require more than three development weeks, the customer is asked to split
 the story into smaller stories and the assignment of value and cost occurs again. It
 is important to note that new stories can be written at any time.
 Customers and developers work together to decide how to group stories into the
 next release (the next software increment) to be developed by the XP team. Once a
 basic commitment (agreement on stories to be included, delivery date, and other
 project matters) is made for a release, the XP team orders the stories that will be de
veloped in one of three ways: (1) all stories will be implemented immediately (within
 a few weeks), (2) the stories with highest value will be moved up in the schedule and
 implemented first, or (3) the riskiest stories will be moved up in the schedule and
 implemented first.
 After the first project release (also called a software increment) has been deliv
ered, the XP team computes project velocity. Stated simply, project velocity is the
 5 The value of a story may also be dependent on the presence of another story.
75
 CHAPTER 3 AGILE DEVELOPMENT
 Project velocity is a
 subtle measure of
 team productivity.
 XP deemphasizes the
 importance of design.
 Not everyone agrees.
 In fact, there are times
 when design should be
 emphasized.
 WebRef
 Refactoring techniques
 and tools can be
 found at:
 www.refactoring
 .com.
 number of customer stories implemented during the first release. Project velocity can
 then be used to (1) help estimate delivery dates and schedule for subsequent releases
 and (2) determine whether an overcommitment has been made for all stories across
 the entire development project. If an overcommitment occurs, the content of releases
 is modified or end delivery dates are changed.
 As development work proceeds, the customer can add stories, change the value
 of an existing story, split stories, or eliminate them. The XP team then reconsiders all
 remaining releases and modifies its plans accordingly.
 Design. XP design rigorously follows the KIS (keep it simple) principle. A simple
 design is always preferred over a more complex representation. In addition, the de
sign provides implementation guidance for a story as it is written—nothing less,
 nothing more. The design of extra functionality (because the developer assumes it
 will be required later) is discouraged.6
 XP encourages the use of CRC cards (Chapter 7) as an effective mechanism for
 thinking about the software in an object-oriented context. CRC (class-responsibility
collaborator) cards identify and organize the object-oriented classes7 that are rele
vant to the current software increment. The XP team conducts the design exercise
 using a process similar to the one described in Chapter 8. The CRC cards are the only
 design work product produced as part of the XP process.
 If a difficult design problem is encountered as part of the design of a story, XP rec
ommends the immediate creation of an operational prototype of that portion of the
 design. Called a spike solution, the design prototype is implemented and evaluated.
 The intent is to lower risk when true implementation starts and to validate the orig
inal estimates for the story containing the design problem.
 In the preceding section, we noted that XP encourages refactoring—a construction
 technique that is also a method for design optimization. Fowler [Fow00] describes
 refactoring in the following manner:
 Refactoring is the process of changing a software system in such a way that it does not
 alter the external behavior of the code yet improves the internal structure. It is a disci
plined way to clean up code [and modify/simplify the internal design] that minimizes the
 chances of introducing bugs. In essence, when you refactor you are improving the design
 of the code after it has been written.
 Because XP design uses virtually no notation and produces few, if any, work prod
ucts other than CRC cards and spike solutions, design is viewed as a transient arti
fact that can and should be continually modified as construction proceeds. The intent
 of refactoring is to control these modifications by suggesting small design changes
 6 These design guidelines should be followed in every software engineering method, although there
 are times when sophisticated design notation and terminology may get in the way of simplicity.
 7 Object-oriented classes are discussed in Appendix 2, in Chapter 8, and throughout Part 2 of this
 book.
76
 PART ONE THE SOFTWARE PROCESS
 Refactoring improves
 the internal structure of
 a design (or source
 code) without
 changing its external
 functionality or
 behavior.
 WebRef
 Useful information on
 XP can be obtained 
at www
 .xprogramming.
 com.
 ?
 What is 
pair
 programming?
 Many software teams
 are populated by indi
vidualists. You’ll have
 to work to change that
 culture if pair program
ming is to work effec
tively.
 ?
 XP?
 How are unit
 tests used in
 that “can radically improve the design” [Fow00]. It should be noted, however, that
 the effort required for refactoring can grow dramatically as the size of an application
 grows.
 A central notion in XP is that design occurs both before and after coding com
mences. Refactoring means that design occurs continuously as the system is con
structed. In fact, the construction activity itself will provide the XP team with
 guidance on how to improve the design.
 Coding. After stories are developed and preliminary design work is done, the team
 does not move to code, but rather develops a series of unit tests that will exercise
 each of the stories that is to be included in the current release (software increment).8
 Once the unit test9 has been created, the developer is better able to focus on what
 must be implemented to pass the test. Nothing extraneous is added (KIS). Once the
 code is complete, it can be unit-tested immediately, thereby providing instantaneous
 feedback to the developers.
 A key concept during the coding activity (and one of the most talked about aspects
 of XP) is pair programming. XP recommends that two people work together at one
 computer workstation to create code for a story. This provides a mechanism for real
time problem solving (two heads are often better than one) and real-time quality as
surance (the code is reviewed as it is created). It also keeps the developers focused
 on the problem at hand. In practice, each person takes on a slightly different role. For
 example, one person might think about the coding details of a particular portion of
 the design while the other ensures that coding standards (a required part of XP) are
 being followed or that the code for the story will satisfy the unit test that has been
 developed to validate the code against the story.
 As pair programmers complete their work, the code they develop is integrated
 with the work of others. In some cases this is performed on a daily basis by an inte
gration team. In other cases, the pair programmers have integration responsibility.
 This “continuous integration” strategy helps to avoid compatibility and interfacing
 problems and provides a “smoke testing” environment (Chapter 17) that helps to
 uncover errors early.
 Testing. I have already noted that the creation of unit tests before coding com
mences is a key element of the XP approach. The unit tests that are created should
 be implemented using a framework that enables them to be automated (hence, they
 can be executed easily and repeatedly). This encourages a regression testing strat
egy (Chapter 17) whenever code is modified (which is often, given the XP refactor
ing philosophy).
 8 This approach is analogous to knowing the exam questions before you begin to study. It makes
 studying much easier by focusing attention only on the questions that will be asked.
 9 Unit testing, discussed in detail in Chapter 17, focuses on an individual software component, exer
cising the component’s interface, data structures, and functionality in an effort to uncover errors
 that are local to the component.
77
 CHAPTER 3 AGILE DEVELOPMENT
 XP acceptance tests
 are derived from user
 stories.
 ?
 What new
 practices are
 appended to XP
 to create IXP?
 uote:
 “Ability is what
 you’re capable of
 doing. Motivation
 determines what
 you do. Attitude
 determines how
 well you do it.”
 Lou Holtz
 As the individual unit tests are organized into a “universal testing suite” [Wel99],
 integration and validation testing of the system can occur on a daily basis. This pro
vides the XP team with a continual indication of progress and also can raise warn
ing flags early if things go awry. Wells [Wel99] states: “Fixing small problems every
 few hours takes less time than fixing huge problems just before the deadline.”
 XP acceptance tests, also called customer tests, are specified by the customer and
 focus on overall system features and functionality that are visible and reviewable by
 the customer. Acceptance tests are derived from user stories that have been imple
mented as part of a software release.
 3.4.3 Industrial XP
 Joshua Kerievsky [Ker05] describes Industrial Extreme Programming (IXP) in the fol
lowing manner: “IXP is an organic evolution of XP. It is imbued with XP’s minimal
ist, customer-centric, test-driven spirit. IXP differs most from the original XP in its
 greater inclusion of management, its expanded role for customers, and its upgraded
 technical practices.” IXP incorporates six new practices that are designed to help
 ensure that an XP project works successfully for significant projects within a large
 organization.
 Readiness assessment. Prior to the initiation of an IXP project, the organ
ization should conduct a readiness assessment. The assessment ascertains
 whether (1) an appropriate development environment exists to support IXP,
 (2) the team will be populated by the proper set of stakeholders, (3) the or
ganization has a distinct quality program and supports continuous improve
ment, (4) the organizational culture will support the new values of an agile
 team, and (5) the broader project community will be populated appropriately.
 Project community. Classic XP suggests that the right people be used to
 populate the agile team to ensure success. The implication is that people on
 the team must be well-trained, adaptable and skilled, and have the proper
 temperament to contribute to a self-organizing team. When XP is to be
 applied for a significant project in a large organization, the concept of the
 “team” should morph into that of a community. A community may have a
 technologist and customers who are central to the success of a project as
 well as many other stakeholders (e.g., legal staff, quality auditors, manufac
turing or sales types) who “are often at the periphery of an IXP project yet
 they may play important roles on the project” [Ker05]. In IXP, the community
 members and their roles should be explicitly defined and mechanisms for
 communication and coordination between community members should be
 established.
 Project chartering. The IXP team assesses the project itself to determine
 whether an appropriate business justification for the project exists and
 whether the project will further the overall goals and objectives of the
78
 PART ONE THE SOFTWARE PROCESS
 organization. Chartering also examines the context of the project to deter
mine how it complements, extends, or replaces existing systems or
 processes.
 Test-driven management. An IXP project requires measurable criteria for
 assessing the state of the project and the progress that has been made to
 date. Test-driven management establishes a series of measurable “destina
tions” [Ker05] and then defines mechanisms for determining whether or not
 these destinations have been reached.
 Retrospectives. An IXP team conducts a specialized technical review
 (Chapter 15) after a software increment is delivered. Called a retrospective,
 the review examines “issues, events, and lessons-learned” [Ker05] across a
 software increment and/or the entire software release. The intent is to
 improve the IXP process.
 Continuous learning. Because learning is a vital part of continuous
 process improvement, members of the XP team are encouraged (and possi
bly, incented) to learn new methods and techniques that can lead to a higher
quality product.
 In addition to the six new practices discussed, IXP modifies a number of existing
 XP practices. Story-driven development (SDD) insists that stories for acceptance tests
 be written before a single line of code is generated. Domain-driven design (DDD) is
 an improvement on the “system metaphor” concept used in XP. DDD [Eva03] sug
gests the evolutionary creation of a domain model that “accurately represents how
 domain experts think about their subject” [Ker05]. Pairing extends the XP pair
programming concept to include managers and other stakeholders. The intent is to
 improve knowledge sharing among XP team members who may not be directly in
volved in technical development. Iterative usability discourages front-loaded inter
face design in favor of usability design that evolves as software increments are
 delivered and users’ interaction with the software is studied.
 IXP makes smaller modifications to other XP practices and redefines certain roles
 and responsibilities to make them more amenable to significant projects for large
 organizations. For further discussion of IXP, visit http://industrialxp.org.
 3.4.4 The XP Debate
 All new process models and methods spur worthwhile discussion and in some in
stances heated debate. Extreme Programming has done both. In an interesting book
 that examines the efficacy of XP, Stephens and Rosenberg [Ste03] argue that many
 XP practices are worthwhile, but others have been overhyped, and a few are prob
lematic. The authors suggest that the codependent nature of XP practices are both
 its strength and its weakness. Because many organizations adopt only a subset of XP
 practices, they weaken the efficacy of the entire process. Proponents counter that
 XP is continuously evolving and that many of the issues raised by critics have been
79
 CHAPTER 3 AGILE DEVELOPMENT
 addressed as XP practice matures. Among the issues that continue to trouble some
 critics of XP are:10
 ?
 What are
 some of the
 issues that lead to
 an XP debate?
 • Requirements volatility. Because the customer is an active member of the XP
 team, changes to requirements are requested informally. As a consequence,
 the scope of the project can change and earlier work may have to be
 modified to accommodate current needs. Proponents argue that this happens
 regardless of the process that is applied and that XP provides mechanisms for
 controlling scope creep.
 • Conflicting customer needs. Many projects have multiple customers, each with
 his own set of needs. In XP, the team itself is tasked with assimilating the
 needs of different customers, a job that may be beyond their scope of
 authority.
 • Requirements are expressed informally. User stories and acceptance tests are
 the only explicit manifestation of requirements in XP. Critics argue that a
 more formal model or specification is often needed to ensure that omissions,
 inconsistencies, and errors are uncovered before the system is built. Propo
nents counter that the changing nature of requirements makes such models
 and specification obsolete almost as soon as they are developed.
 • Lack of formal design. XP deemphasizes the need for architectural design and
 in many instances, suggests that design of all kinds should be relatively
 informal. Critics argue that when complex systems are built, design must be
 emphasized to ensure that the overall structure of the software will exhibit
 quality and maintainability. XP proponents suggest that the incremental
 nature of the XP process limits complexity (simplicity is a core value) and
 therefore reduces the need for extensive design.
 You should note that every software process has flaws and that many software or
ganizations have used XP successfully. The key is to recognize where a process may
 have weaknesses and to adapt it to the specific needs of your organization.
 SAFEHOME
 Considering Agile Software Development
 The scene: Doug Miller’s office.
 The Players: Doug Miller, software engineering
 manager; Jamie Lazar, software team member; Vinod
 Raman, software team member.
 The conversation:
 (A knock on the door, Jamie and Vinod enter Doug’s office)
 Jamie: Doug, you got a minute?
 10 For a detailed look at some thoughtful criticism that has been leveled at XP, visit
 www.softwarereality.com/ExtremeProgramming.jsp.
3.5 OTHERAGILEPROCESSMODELS
 The history of software engineering is littered with dozens of obsolete process
 descriptions and methodologies, modeling methods and notations, tools, and
 technology. Each flared in notoriety and was then eclipsed by something new and
 (purportedly) better. With the introduction of a wide array of agile process models—
 each contending for acceptance within the software development community—the
 agile movement is following the same historical path.11
 As I noted in the last section, the most widely used of all agile process models
 isExtreme Programming (XP). But many other agile process models have been
 proposed and are in use across the industry. Among the most common are:
 •Adaptive Software Development (ASD)
 •Scrum
 •Dynamic Systems Development Method (DSDM)
 80 PART ONE THE SOFTWARE PROCESS
 Doug: Sure Jamie, what’s up?
 Jamie:We’ve been thinking about our process
 discussion yesterday . . . you know, what process we’re
 going to choose for this new SafeHomeproject.
 Doug:And?
 Vinod: I was talking to a friend at another company,
 and he was telling me about Extreme Programming. It’s
 an agile process model . . . heard of it?
 Doug: Yeah, some good, some bad.
 Jamie:Well, it sounds pretty good to us. Lets you
 develop software really fast, uses something called pair
 programming to do real-time quality checks . . . it’s pretty
 cool, I think.
 Doug: It does have a lot of really good ideas. I like the
 pair-programming concept, for instance, and the idea
 that stakeholders should be part of the team.
 Jamie:Huh? You mean that marketing will work on the
 project team with us?
 Doug (nodding): They’re a stakeholder, aren’t they?
 Jamie: Jeez . . . they’ll be requesting changes every five
 minutes.
 Vinod:Not necessarily. My friend said that there are
 ways to “embrace” changes during an XP project.
 Doug: So you guys think we should use XP?
 Jamie: It’s definitely worth considering.
 Doug: I agree. And even if we choose an incremental
 model as our approach, there’s no reason why we can’t
 incorporate much of what XP has to offer.
 Vinod:Doug, before you said “some good, some bad.”
 What was the “bad”?
 Doug: The thing I don’t like is the way XP downplays
 analysis and design . . . sort of says that writing code is
 where the action is . . . 
(The team members look at one another and smile.)
 Doug: So you agree with the XP approach?
 Jamie (speaking for both):Writing code is what
 we do, Boss!
 Doug (laughing): True, but I’d like to see you spend a
 little less time coding and then recoding and a little more
 time analyzing what has to be done and designing a
 solution that works.
 Vinod:Maybe we can have it both ways, agility with a
 little discipline.
 Doug: I think we can, Vinod. In fact, I’m sure of it.
 uote:
 “Our profession
 goes through
 methodologies like
 a 14-year-old goes
 through clothing.”
 Stephen
 Hawrysh and
 JimRuprecht
 11This is not a bad thing. Before one or more models or methods are accepted as a de facto standard,
 all must contend for the hearts and minds of software engineers. The “winners” evolve into best
 practice, while the “losers” either disappear or merge with the winning models.
81
 CHAPTER 3 AGILE DEVELOPMENT
 • Crystal
 • Feature Drive Development (FDD)
 • Lean Software Development (LSD)
 • Agile Modeling (AM)
 • Agile Unified Process (AUP)
 In the sections that follow, I present a very brief overview of each of these agile
 process models. It is important to note that all agile process models conform (to a
 greater or lesser degree) to the Manifesto for Agile Software Development and the prin
ciples noted in Section 3.3.1. For additional detail, refer to the references noted in
 each subsection or for a survey, examine the “agile software development” entry
 in Wikipedia.12
 3.5.1 Adaptive Software Development (ASD)
 WebRef
 Useful resources for
 ASD can be found at
 www.adaptivesd
 .com.
 Adaptive Software Development (ASD) has been proposed by Jim Highsmith [Hig00] as
 a technique for building complex software and systems. The philosophical under
pinnings of ASD focus on human collaboration and team self-organization.
 Highsmith argues that an agile, adaptive development approach based on collab
oration is “as much a source of order in our complex interactions as discipline and
 engineering.” He defines an ASD “life cycle” (Figure 3.3) that incorporates three
 phases, speculation, collaboration, and learning.
 FIGURE 3.3
 Adaptive
 software
 development
 adaptive cycle planning
 mission statement
 project constraints
 basic requirements
 time-boxed release plan
 Release
 Requirements gathering
 JAD
 mini-specs
 speculation
 software increment
 adjustments for subsequent cycles
 collaboration
 components implemented/tested
 focus groups for feedback
 formal technical reviews
 learning
 postmortems
 12 See http://en.wikipedia.org/wiki/Agile_software_development#Agile_methods.
82
 PART ONE THE SOFTWARE PROCESS
 Effective collaboration
 with your customer will
 only occur if you
 jettison any “us and
 them” attitudes.
 ASD emphasizes
 learning as a key
 element in achieving 
a “self-organizing”
 team.
 WebRef
 Useful Scrum
 information and
 resources can be found
 at www
 .controlchaos.com.
 During speculation, the project is initiated and adaptive cycle planning is con
ducted. Adaptive cycle planning uses project initiation information—the customer’s
 mission statement, project constraints (e.g., delivery dates or user descriptions), and
 basic requirements—to define the set of release cycles (software increments) that
 will be required for the project.
 No matter how complete and farsighted the cycle plan, it will invariably change.
 Based on information obtained at the completion of the first cycle, the plan is re
viewed and adjusted so that planned work better fits the reality in which an ASD
 team is working.
 Motivated people use collaboration in a way that multiplies their talent and cre
ative output beyond their absolute numbers. This approach is a recurring theme in
 all agile methods. But collaboration is not easy. It encompasses communication and
 teamwork, but it also emphasizes individualism, because individual creativity plays
 an important role in collaborative thinking. It is, above all, a matter of trust. People
 working together must trust one another to (1) criticize without animosity, (2) assist
 without resentment, (3) work as hard as or harder than they do, (4) have the skill set
 to contribute to the work at hand, and (5) communicate problems or concerns in a
 way that leads to effective action.
 As members of an ASD team begin to develop the components that are part of an
 adaptive cycle, the emphasis is on “learning” as much as it is on progress toward
 a completed cycle. In fact, Highsmith [Hig00] argues that software developers often
 overestimate their own understanding (of the technology, the process, and the proj
ect) and that learning will help them to improve their level of real understanding.
 ASD teams learn in three ways: focus groups (Chapter 5), technical reviews (Chap
ter 14), and project postmortems.
 The ASD philosophy has merit regardless of the process model that is used. ASD’s
 overall emphasis on the dynamics of self-organizing teams, interpersonal collabo
ration, and individual and team learning yield software project teams that have a
 much higher likelihood of success.
 3.5.2 Scrum
 Scrum (the name is derived from an activity that occurs during a rugby match13) is
 an agile software development method that was conceived by Jeff Sutherland and his
 development team in the early 1990s. In recent years, further development on the
 Scrum methods has been performed by Schwaber and Beedle [Sch01a].
 Scrum principles are consistent with the agile manifesto and are used to guide
 development activities within a process that incorporates the following framework
 activities: requirements, analysis, design, evolution, and delivery. Within each
 13 A group of players forms around the ball and the teammates work together (sometimes violently!)
 to move the ball downfield.
every 24
 hours
 30 days
 Scrum: 15 minute daily meeting.
 Team members respond to basics:
 1) What did you do since last Scrum
 meeting?
 2) Do you have any obstacles?
 3) What will you do before next
 meeting?
 Sprint Backlog:
 Feature(s)
 assigned
 to sprint
 Product Backlog:
 Prioritized product features desired by the customer
 Backlog
 items
 expanded
 by team
 New functionality
 is demonstrated
 at end of sprint
 framework activity, work tasks occur within a process pattern (discussed in the fol
lowing paragraph) called a sprint.The work conducted within a sprint (the number
 of sprints required for each framework activity will vary depending on product com
plexity and size) is adapted to the problem at hand and is defined and often modified
 in real time by the Scrum team. The overall flow of the Scrum process is illustrated
 in Figure 3.4.
 Scrum emphasizes the use of a set of software process patterns [Noy02] that have
 proven effective for projects with tight timelines, changing requirements, and business
 criticality. Each of these process patterns defines a set of development actions:
 Backlog—a prioritized list of project requirements or features that provide busi
ness value for the customer. Items can be added to the backlog at any time (this is
 how changes are introduced). The product manager assesses the backlog and
 updates priorities as required.
 Sprints—consist of work units that are required to achieve a requirement de
fined in the backlog that must be fit into a predefined time-box14(typically 30 days).
 CHAPTER 3 AGILE DEVELOPMENT 83
 14A time-boxis a project management term (see Part 4 of this book) that indicates a period of time
 that has been allocated to accomplish some task.
 FIGURE3.4
 Scrum process
 flow
 Scrum incorporates a
 set of process patterns
 that emphasize project
 priorities,
 compartmentalized
 work units,
 communication, and
 frequent customer
 feedback.
84
 PART ONE THE SOFTWARE PROCESS
 Changes (e.g., backlog work items) are not introduced during the sprint. Hence, the
 sprint allows team members to work in a short-term, but stable environment.
 Scrum meetings—are short (typically 15 minutes) meetings held daily by the Scrum
 team. Three key questions are asked and answered by all team members [Noy02]:
 • What did you do since the last team meeting?
 • What obstacles are you encountering?
 • What do you plan to accomplish by the next team meeting?
 A team leader, called a Scrum master, leads the meeting and assesses the responses
 from each person. The Scrum meeting helps the team to uncover potential problems
 as early as possible. Also, these daily meetings lead to “knowledge socialization”
 [Bee99] and thereby promote a self-organizing team structure.
 Demos—deliver the software increment to the customer so that functionality that
 has been implemented can be demonstrated and evaluated by the customer. It is im
portant to note that the demo may not contain all planned functionality, but rather
 those functions that can be delivered within the time-box that was established.
 Beedle and his colleagues [Bee99] present a comprehensive discussion of these pat
terns in which they state: “Scrum assumes up-front the existence of chaos. . . . ” The
 Scrum process patterns enable a software team to work successfully in a world
 where the elimination of uncertainty is impossible.
 3.5.3 Dynamic Systems Development Method (DSDM)
 WebRef
 Useful resources for
 DSSD can be found at
 www.dsdm.org.
 The Dynamic Systems Development Method (DSDM) [Sta97] is an agile software devel
opment approach that “provides a framework for building and maintaining systems
 which meet tight time constraints through the use of incremental prototyping in a con
trolled project environment” [CCS02]. The DSDM philosophy is borrowed from a mod
ified version of the Pareto principle—80 percent of an application can be delivered in
 20 percent of the time it would take to deliver the complete (100 percent) application.
 DSDM is an iterative software process in which each iteration follows the 80 per
cent rule. That is, only enough work is required for each increment to facilitate
 movement to the next increment. The remaining detail can be completed later when
 more business requirements are known or changes have been requested and
 accommodated.
 The DSDM Consortium (www.dsdm.org) is a worldwide group of member com
panies that collectively take on the role of “keeper” of the method. The consortium
 has defined an agile process model, called the DSDM life cycle that defines three dif
ferent iterative cycles, preceded by two additional life cycle activities:
 Feasibility study—establishes the basic business requirements and constraints
 associated with the application to be built and then assesses whether the applica
tion is a viable candidate for the DSDM process.
85
 CHAPTER 3 AGILE DEVELOPMENT
 DSDM is a process
 framework that can
 adopt the tactics of
 another agile approach
 such as XP.
 Crystal is a family of
 process models with
 the same “genetic
 code” but different
 methods for adapting
 to project
 characteristics.
 Business study—establishes the functional and information requirements that
 will allow the application to provide business value; also, defines the basic
 application architecture and identifies the maintainability requirements for the
 application.
 Functional model iteration—produces a set of incremental prototypes that
 demonstrate functionality for the customer. (Note: All DSDM prototypes are in
tended to evolve into the deliverable application.) The intent during this iterative
 cycle is to gather additional requirements by eliciting feedback from users as they
 exercise the prototype.
 Design and build iteration—revisits prototypes built during functional model
 iteration to ensure that each has been engineered in a manner that will enable it to
 provide operational business value for end users. In some cases, functional model
 iteration and design and build iteration occur concurrently.
 Implementation—places the latest software increment (an “operationalized” pro
totype) into the operational environment. It should be noted that (1) the increment
 may not be 100 percent complete or (2) changes may be requested as the incre
ment is put into place. In either case, DSDM development work continues by
 returning to the functional model iteration activity.
 DSDM can be combined with XP (Section 3.4) to provide a combination approach
 that defines a solid process model (the DSDM life cycle) with the nuts and bolts prac
tices (XP) that are required to build software increments. In addition, the ASD con
cepts of collaboration and self-organizing teams can be adapted to a combined
 process model.
 3.5.4 Crystal
 Alistair Cockburn [Coc05] and Jim Highsmith [Hig02b] created the Crystal family of
 agile methods15 in order to achieve a software development approach that puts a
 premium on “maneuverability” during what Cockburn characterizes as “a resource
limited, cooperative game of invention and communication, with a primary goal of
 delivering useful, working software and a secondary goal of setting up for the next
 game” [Coc02].
 To achieve maneuverability, Cockburn and Highsmith have defined a set of
 methodologies, each with core elements that are common to all, and roles, process
 patterns, work products, and practice that are unique to each. The Crystal family is
 actually a set of example agile processes that have been proven effective for differ
ent types of projects. The intent is to allow agile teams to select the member of the
 crystal family that is most appropriate for their project and environment.
 15 The name “crystal” is derived from the characteristics of geological crystals, each with its own
 color, shape, and hardness.
86
 PART ONE THE SOFTWARE PROCESS
 3.5.5 Feature Driven Development (FDD)
 WebRef
 A wide variety of
 articles and
 presentations on FDD
 can be found at:
 www.featuredrive
 ndevelopment
 .com/.
 Feature Driven Development (FDD) was originally conceived by Peter Coad and his
 colleagues [Coa99] as a practical process model for object-oriented software engi
neering. Stephen Palmer and John Felsing [Pal02] have extended and improved
 Coad’s work, describing an adaptive, agile process that can be applied to moderately
 sized and larger software projects.
 Like other agile approaches, FDD adopts a philosophy that (1) emphasizes col
laboration among people on an FDD team; (2) manages problem and project
 complexity using feature-based decomposition followed by the integration of
 software increments, and (3) communication of technical detail using verbal,
 graphical, and text-based means. FDD emphasizes software quality assurance
 activities by encouraging an incremental development strategy, the use of design
 and code inspections, the application of software quality assurance audits (Chap
ter 16), the collection of metrics, and the use of patterns (for analysis, design, and
 construction).
 In the context of FDD, a feature “is a client-valued function that can be imple
mented in two weeks or less” [Coa99]. The emphasis on the definition of features
 provides the following benefits:
 • Because features are small blocks of deliverable functionality, users can
 describe them more easily; understand how they relate to one another more
 readily; and better review them for ambiguity, error, or omissions.
 • Features can be organized into a hierarchical business-related grouping.
 • Since a feature is the FDD deliverable software increment, the team develops
 operational features every two weeks.
 • Because features are small, their design and code representations are easier
 to inspect effectively.
 • Project planning, scheduling, and tracking are driven by the feature
 hierarchy, rather than an arbitrarily adopted software engineering 
task set.
 Coad and his colleagues [Coa99] suggest the following template for defining a
 feature:
 <action> the <result> <by for of to> a(n) <object>
 where an <object> is “a person, place, or thing (including roles, moments in time or
 intervals of time, or catalog-entry-like descriptions).” Examples of features for an 
e-commerce application might be:
 Add the product to shopping cart
 Display the technical-specifications of the product
 Store the shipping-information for the customer
87
 CHAPTER 3 AGILE DEVELOPMENT
 FIGURE 3.5
 Feature Driven
 Development
 [Coa99] (with
 permission)
 Develop
 an
 Overall
 Model
 Build a
 Features
 List
 Plan
 By
 Feature
 Design
 By
 Feature
 (more shape
 than content)
 A list of features
 grouped into sets
 and subject areas
 A development plan
 Class owners
 Feature Set Owners
 A design
 package
 (sequences)
 Build
 By
 Feature
 Completed
 client-value
 function
 A feature set groups related features into business-related categories and is defined
 [Coa99] as:
 <action><-ing> a(n) <object>
 For example: Making a product sale is a feature set that would encompass the fea
tures noted earlier and others.
 The FDD approach defines five “collaborating” [Coa99] framework activities (in
 FDD these are called “processes”) as shown in Figure 3.5.
 FDD provides greater emphasis on project management guidelines and tech
niques than many other agile methods. As projects grow in size and complexity,
 ad hoc project management is often inadequate. It is essential for developers, their
 managers, and other stakeholders to understand project status—what accomplish
ments have been made and problems have been encountered. If deadline pressure
 is significant, it is critical to determine if software increments (features) are properly
 scheduled. To accomplish this, FDD defines six milestones during the design and
 implementation of a feature: “design walkthrough, design, design inspection, code,
 code inspection, promote to build” [Coa99].
 3.5.6 Lean Software Development (LSD)
 Lean Software Development (LSD) has adapted the principles of lean manufacturing
 to the world of software engineering. The lean principles that inspire the LSD process
 can be summarized ([Pop03], [Pop06a]) as eliminate waste, build quality in, create
 knowledge, defer commitment, deliver fast, respect people, and optimize the whole.
 Each of these principles can be adapted to the software process. For example,
 eliminate waste within the context of an agile software project can be interpreted
 to mean [Das05]: (1) adding no extraneous features or functions, (2) assessing the
 cost and schedule impact of any newly requested requirement, (3) removing any
 superfluous process steps, (4) establishing mechanisms to improve the way team
 members find information, (5) ensuring the testing finds as many errors as possible,
88
 PART ONE THE SOFTWARE PROCESS
 (6) reducing the time required to request and get a decision that affects the software
 or the process that is applied to create it, and (7) streamlining the manner in which
 information is transmitted to all stakeholders involved in the process.
 For a detailed discussion of LSD and pragmatic guidelines for implementing the
 process, you should examine [Pop06a] and [Pop06b].
 3.5.7 Agile Modeling (AM)
 WebRef
 Comprehensive
 information on agile
 modeling can be found
 at: www
 .agilemodeling.com.
 uote:
 “I was in the drug
 store the other day
 trying to get a cold
 medication . . . not
 easy. There’s an
 entire wall of
 products you need.
 You stand there
 going, Well, this
 one is quick acting
 but this is long
 lasting. . . . Which
 is more important,
 the present or the
 future?”
 Jerry Seinfeld
 There are many situations in which software engineers must build large, business
critical systems. The scope and complexity of such systems must be modeled so that
 (1) all constituencies can better understand what needs to be accomplished, (2) the
 problem can be partitioned effectively among the people who must solve it, and
 (3) quality can be assessed as the system is being engineered and built.
 Over the past 30 years, a wide variety of software engineering modeling methods
 and notation have been proposed for analysis and design (both architectural and
 component-level). These methods have merit, but they have proven to be difficult
 to apply and challenging to sustain (over many projects). Part of the problem is the
 “weight” of these modeling methods. By this I mean the volume of notation required,
 the degree of formalism suggested, the sheer size of the models for large projects,
 and the difficulty in maintaining the model(s) as changes occur. Yet analysis and de
sign modeling have substantial benefit for large projects—if for no other reason than
 to make these projects intellectually manageable. Is there an agile approach to soft
ware engineering modeling that might provide an alternative?
 At “The Official Agile Modeling Site,” Scott Ambler [Amb02a] describes agile mod
eling (AM) in the following manner:
 Agile Modeling (AM) is a practice-based methodology for effective modeling and documen
tation of software-based systems. Simply put, Agile Modeling (AM) is a collection of values,
 principles, and practices for modeling software that can be applied on a software develop
ment project in an effective and light-weight manner. Agile models are more effective than
 traditional models because they are just barely good, they don’t have to be perfect.
 Agile modeling adopts all of the values that are consistent with the agile manifesto.
 The agile modeling philosophy recognizes that an agile team must have the courage
 to make decisions that may cause it to reject a design and refactor. The team must
 also have the humility to recognize that technologists do not have all the answers and
 that business experts and other stakeholders should be respected and embraced.
 Although AM suggests a wide array of “core” and “supplementary” modeling prin
ciples, those that make AM unique are [Amb02a]:
 Model with a purpose. A developer who uses AM should have a specific
 goal (e.g., to communicate information to the customer or to help better un
derstand some aspect of the software) in mind before creating the model.
 Once the goal for the model is identified, the type of notation to be used and
 level of detail required will be more obvious.
89
 CHAPTER 3 AGILE DEVELOPMENT
 Use multiple models. There are many different models and notations that
 can be used to describe software. Only a small subset is essential for most
 projects. AM suggests that to provide needed insight, each model should
 present a different aspect of the system and only those models that provide
 value to their intended audience should be used.
 “Traveling light” is an
 appropriate philosophy
 for all software engi
neering work. Build
 only those models that
 provide value … no
 more, no less.
 Travel light. As software engineering work proceeds, keep only those mod
els that will provide long-term value and jettison the rest. Every work product
 that is kept must be maintained as changes occur. This represents work that
 slows the team down. Ambler [Amb02a] notes that “Every time you decide to
 keep a model you trade-off agility for the convenience of having that informa
tion available to your team in an abstract manner (hence potentially enhanc
ing communication within your team as well as with project stakeholders).”
 Content is more important than representation. Modeling should im
part information to its intended audience. A syntactically perfect model that
 imparts little useful content is not as valuable as a model with flawed nota
tion that nevertheless provides valuable content for its audience.
 Know the models and the tools you use to create them. Understand
 the strengths and weaknesses of each model and the tools that are used to
 create it.
 Adapt locally. The modeling approach should be adapted to the needs of
 the agile team.
 A major segment of the software engineering community has adopted the Unified
 Modeling Language (UML)16 as the preferred method for representing analysis and
 design models. The Unified Process (Chapter 2) has been developed to provide a
 framework for the application of UML. Scott Ambler [Amb06] has developed a sim
plified version of the UP that integrates his agile modeling philosophy.
 3.5.8 Agile Unified Process (AUP)
 The Agile Unified Process (AUP) adopts a “serial in the large” and “iterative in the
 small” [Amb06] philosophy for building computer-based systems. By adopting the
 classic UP phased activities—inception, elaboration, construction, and transition—AUP
 provides a serial overlay (i.e., a linear sequence of software engineering activities)
 that enables a team to visualize the overall process flow for a software project. How
ever, within each of the activities, the team iterates to achieve agility and to deliver
 meaningful software increments to end users as rapidly as possible. Each AUP iter
ation addresses the following activities [Amb06]: 
• Modeling. UML representations of the business and problem domains are
 created. However, to stay agile, these models should be “just barely good
 enough” [Amb06] to allow the team to proceed.
 16 A brief tutorial on UML is presented in Appendix 1.
90
 PART ONE THE SOFTWARE PROCESS
 • Implementation. Models are translated into source code.
 • Testing. Like XP, the team designs and executes a series of tests to uncover
 errors and ensure that the source code meets its requirements.
 • Deployment. Like the generic process activity discussed in Chapters 1 and 2,
 deployment in this context focuses on the delivery of a software increment
 and the acquisition of feedback from end users.
 • Configuration and project management. In the context of AUP, configuration
 management (Chapter 22) addresses change management, risk manage
ment, and the control of any persistent work products17 that are produced by
 the team. Project management tracks and controls the progress of the team
 and coordinates team activities.
 • Environment management. Environment management coordinates a process
 infrastructure that includes standards, tools, and other support technology
 available to the team.
 Although the AUP has historical and technical connections to the Unified Modeling
 Language, it is important to note that UML modeling can be using in conjunction
 with any of the agile process models described in Section 3.5.
 SOFTWARE TOOLS
 Agile Development
 Objective: The objective of agile development
 tools is to assist in one or more aspects of agile
 development with an emphasis on facilitating the rapid
 generation of operational software. These tools can also
 be used when prescriptive process models (Chapter 2) are
 applied.
 Mechanics: Tool mechanics vary. In general, agile tool
 sets encompass automated support for project planning,
 use case development and requirements gathering, rapid
 design, code generation, and testing.
 Representative Tools:18
 Note: Because agile development is a hot topic, most
 software tools vendors purport to sell tools that support 
the agile approach. The tools noted here have
 characteristics that make them particularly useful for
 agile projects.
 OnTime, developed by Axosoft (www.axosoft.com),
 provides agile process management support for
 various technical activities within the process.
 Ideogramic UML, developed by Ideogramic
 (www.ideogramic.com) is a UML tool set
 specifically developed for use within an agile 
process.
 Together Tool Set, distributed by Borland
 (www.borland.com), provides a tools suite that
 supports many technical activities within XP and other
 agile processes.
 17 A persistent work product is a model or document or test case produced by the team that will be kept
 for an indeterminate period of time. It will not be discarded once the software increment is
 delivered.
 18 Tools noted here do not represent an endorsement, but rather a sampling of tools in this category.
 In most cases, tool names are trademarked by their respective developers.
91
 CHAPTER 3 AGILE DEVELOPMENT
 3.6 A TOOL SET FOR THE AGILE PROCESS
 The “tool set” that
 supports agile
 processes focuses
 more on people issues
 than it does on
 technology issues.
 Some proponents of the agile philosophy argue that automated software tools (e.g.,
 design tools) should be viewed as a minor supplement to the team’s activities, and
 not at all pivotal to the success of the team. However, Alistair Cockburn [Coc04] sug
gests that tools can have a benefit and that “agile teams stress using tools that per
mit the rapid flow of understanding. Some of those tools are social, starting even at
 the hiring stage. Some tools are technological, helping distributed teams simulate
 being physically present. Many tools are physical, allowing people to manipulate
 them in workshops.”
 Because acquiring the right people (hiring), team collaboration, stakeholder com
munication, and indirect management are key elements in virtually all agile process
 models, Cockburn argues that “tools” that address these issues are critical success
 factors for agility. For example, a hiring “tool” might be the requirement to have a
 prospective team member spend a few hours pair programming with an existing
 member of the team. The “fit” can be assessed immediately.
 Collaborative and communication “tools” are generally low tech and incorporate
 any mechanism (“physical proximity, whiteboards, poster sheets, index cards, and
 sticky notes” [Coc04]) that provides information and coordination among agile de
velopers. Active communication is achieved via the team dynamics (e.g., pair pro
gramming), while passive communication is achieved by “information radiators”
 (e.g., a flat panel display that presents the overall status of different components of
 an increment). Project management tools deemphasize the Gantt chart and replace
 it with earned value charts or “graphs of tests created versus passed . . . other agile
 tools are used to optimize the environment in which the agile team works (e.g., more
 efficient meeting areas), improve the team culture by nurturing social interactions
 (e.g., collocated teams), physical devices (e.g., electronic whiteboards), and process
 enhancement (e.g., pair programming or time-boxing)” [Coc04].
 Are any of these things really tools? They are, if they facilitate the work performed
 by an agile team member and enhance the quality of the end product.
 3.7 SUMMARY
 In a modern economy, market conditions change rapidly, customer and end-user
 needs evolve, and new competitive threats emerge without warning. Practitioners
 must approach software engineering in a manner that allows them to remain agile—
 to define maneuverable, adaptive, lean processes that can accommodate the needs
 of modern business.
 An agile philosophy for software engineering stresses four key issues: the impor
tance of self-organizing teams that have control over the work they perform, com
munication and collaboration between team members and between practitioners
 and their customers, a recognition that change represents an opportunity, and
92
 PART ONE THE SOFTWARE PROCESS
 an emphasis on rapid delivery of software that satisfies the customer. Agile process
 models have been designed to address each of these issues.
 Extreme programming (XP) is the most widely used agile process. Organized as
 four framework activities—planning, design, coding, and testing—XP suggests a
 number of innovative and powerful techniques that allow an agile team to create
 frequent software releases that deliver features and functionality that have been de
scribed and then prioritized by stakeholders.
 Other agile process models also stress human collaboration and team self
organization, but define their own framework activities and select different points of
 emphasis. For example, ASD uses an iterative process that incorporates adaptive
 cycle planning, relatively rigorous requirement gathering methods, and an iterative
 development cycle that incorporates customer focus groups and formal technical re
views as real-time feedback mechanisms. Scrum emphasizes the use of a set of soft
ware process patterns that have proven effective for projects with tight time lines,
 changing requirements, and business criticality. Each process pattern defines a set
 of development tasks and allows the Scrum team to construct a process that is
 adapted to the needs of the project. The Dynamic Systems Development Method
 (DSDM) advocates the use of time-box scheduling and suggests that only enough
 work is required for each software increment to facilitate movement to the next
 increment. Crystal is a family of agile process models that can be adopted to the spe
cific characteristics of a project.
 Feature Driven Development (FDD) is somewhat more “formal” than other agile
 methods, but still maintains agility by focusing the project team on the development
 of features—a client-valued function that can be implemented in two weeks or less.
 Lean Software Development (LSD) has adapted the principles of lean manufacturing
 to the world of software engineering. Agile modeling (AM) suggests that modeling is
 essential for all systems, but that the complexity, type, and size of the model must be
 tuned to the software to be built. The Agile Unified Process (AUP) adopts a “serial in
 the large” and “iterative in the small” philosophy for building software.
 PROBLEMS AND POINTS TO PONDER
 3.1. Reread “The Manifesto for Agile Software Development” at the beginning of this chapter.
 Can you think of a situation in which one or more of the four “values” could get a software team
 into trouble?
 3.2. Describe agility (for software projects) in your own words.
 3.3. Why does an iterative process make it easier to manage change? Is every agile process dis
cussed in this chapter iterative? Is it possible to complete a project in just one iteration and still
 be agile? Explain your answers.
 3.4. Could each of the agile processes be described using the generic framework activities
 noted in Chapter 2? Build a table that maps the generic activities into the activities defined for
 each agile process.
 3.5. Try to come up with one more “agility principle” that would help a software engineering
 team become even more maneuverable.
93
 CHAPTER 3 AGILE DEVELOPMENT
 3.6. Select one agility principle noted in Section 3.3.1 and try to determine whether each of the
 process models presented in this chapter exhibits the principle. [Note: I have presented an
 overview of these process models only, so it may not be possible to determine whether a prin
ciple has been addressed by one or more of the models, unless you do additional research
 (which is not required for this problem).]
 3.7. Why do requirements change so much? After all, don’t people know what they want?
 3.8. Most agile process models recommend face-to-face communication. Yet today, members
 of a software team and their customers may be geographically separated from one another. Do
 you think this implies that geographical separation is something to avoid? Can you think of ways
 to overcome this problem?
 3.9. Write an XP user story that describes the “favorite places” or “bookmarks” feature avail
able on most Web browsers.
 3.10. What is a spike solution in XP?
 3.11. Describe the XP concepts of refactoring and pair programming in your own words.
 3.12. Do a bit more reading and describe what a time-box is. How does this assist an ASD team
 in delivering software increments in a short time period?
 3.13. Do the 80 percent rule in DSDM and the time-boxing approach defined for ASD achieve
 the same result?
 3.14. Using the process pattern template presented in Chapter 2, develop a process pattern for
 any one of the Scrum patterns presented in Section 3.5.2.
 3.15. Why is Crystal called a family of agile methods?
 3.16. Using the FDD feature template described in Section 3.5.5, define a feature set for a Web
 browser. Now develop a set of features for the feature set.
 3.17. Visit the Official Agile Modeling Site and make a complete list of all core and supple
mentary AM principles.
 3.18. The tool set proposed in Section 3.6 supports many of the “soft” aspects of agile meth
ods. Since communication is so important, recommend an actual tool set that might be used to
 enhance communication among stakeholders on an agile team.
 FURTHER READINGS AND INFORMATION SOURCES
 The overall philosophy and underlying principles of agile software development are considered
 in depth in many of the books referenced in the body of this chapter. In addition, books by Shaw
 and Warden (The Art of Agile Development, O’Reilly Media, Inc., 2008), Hunt (Agile Software Con
struction, Springer, 2005), and Carmichael and Haywood (Better Software Faster, Prentice-Hall,
 2002) present useful discussions of the subject. Aguanno (Managing Agile Projects, Multi
Media Publications, 2005), Highsmith (Agile Project Management: Creating Innovative Products,
 Addison-Wesley, 2004), and Larman (Agile and Iterative Development: A Manager’s Guide,
 Addison-Wesley, 2003) present a management overview and consider project management
 issues. Highsmith (Agile Software Development Ecosystems, Addison-Wesley, 2002) presents a
 survey of agile principles, processes, and practices. A worthwhile discussion of the delicate bal
ance between agility and discipline is presented by Booch and his colleagues (Balancing Agility
 and Discipline, Addison-Wesley, 2004).
 Martin (Clean Code: A Handbook of Agile Software Craftsmanship, Prentice-Hall, 2009) pres
ents the principles, patterns, and practices required to develop “clean code” in an agile software
 engineering environment. Leffingwell (Scaling Software Agility: Best Practices for Large Enter
prises, Addison-Wesley, 2007) discusses strategies for scaling up agile practices for large proj
ects. Lippert and Rook (Refactoring in Large Software Projects: Performing Complex Restructurings
 Successfully, Wiley, 2006) discuss the use of refactoring when applied in large, complex systems.
94
 PART ONE THE SOFTWARE PROCESS
 Stamelos and Sfetsos (Agile Software Development Quality Assurance, IGI Global, 2007) discuss
 SQA techniques that conform to the agile philosophy.
 Dozens of books have been written about Extreme Programming over the past decade. Beck
 (Extreme Programming Explained: Embrace Change, 2d ed., Addison-Wesley, 2004) remains the
 definitive treatment of the subject. In addition, Jeffries and his colleagues (Extreme Programming
 Installed, Addison-Wesley, 2000), Succi and Marchesi (Extreme Programming Examined,
 Addison-Wesley, 2001), Newkirk and Martin (Extreme Programming in Practice, Addison-Wesley,
 2001), and Auer and his colleagues (Extreme Programming Applied: Play to Win, Addison-Wesley,
 2001) provide a nuts-and-bolts discussion of XP along with guidance on how best to apply it.
 McBreen (Questioning Extreme Programming, Addison-Wesley, 2003) takes a critical look at XP,
 defining when and where it is appropriate. An in-depth consideration of pair programming is
 presented by McBreen (Pair Programming Illuminated, Addison-Wesley, 2003).
 ASD is addressed in depth by Highsmith [Hig00]. Schwaber (The Enterprise and Scrum,
 Microsoft Press, 2007) discusses the use of Scrum for projects that have a major business
 impact. The nuts and bolts of Scrum are discussed by Schwaber and Beedle (Agile Software
 Development with SCRUM, Prentice-Hall, 2001). Worthwhile treatments of DSDM have been
 written by the DSDM Consortium (DSDM: Business Focused Development, 2d ed., Pearson Edu
cation, 2003) and Stapleton (DSDM: The Method in Practice, Addison-Wesley, 1997). Cockburn
 (Crystal Clear, Addison-Wesley, 2005) presents an excellent overview of the Crystal family of
 processes. Palmer and Felsing [Pal02] present a detailed treatment of FDD. Carmichael and
 Haywood (Better Software Faster, Prentice-Hall, 2002) provides another useful treatment of FDD
 that includes a step-by-step journey through the mechanics of the process. Poppendieck and 
Poppendieck (Lean Development: An Agile Toolkit for Software Development Managers, Addison
Wesley, 2003) provide guidelines for managing and controlling agile projects. Ambler and
 Jeffries (Agile Modeling, Wiley, 2002) discuss AM in some depth.
 A wide variety of information sources on agile software development are available on the
 Internet. An up-to-date list of World Wide Web references that are relevant to the agile process
 can be found at the SEPA website: www.mhhe.com/engcs/compsci/pressman/
 professional/olc/ser.htm.
In 2001, Kent Beck and 16 other noted software developers, writers, and con
sultants [Bec01a] (referred to as the “Agile Alliance”) signed the “Manifesto for
 Agile Software Development.” It stated:
 We are uncovering better ways of developing software by doing it and helping others
 do it. Through this work we have come to value: 
Individuals and interactions over processes and tools
 Working software over comprehensive documentation
 Customer collaboration over contract negotiation
 Responding to change over following a plan
 That is, while there is value in the items on the right, we value the items on the 
left more.
 QUICK
 LOOK
 What is it? Agile software engi
neering combines a philosophy and
 a set of development guidelines. The
 philosophy encourages customer
 satisfaction and early incremental delivery of
 software; small, highly motivated project teams;
 informal methods; minimal software engineer
ing work products; and overall development
 simplicity. The development guidelines stress
 delivery over analysis and design (although
 these activities are not discouraged), and active
 and continuous communication between devel
opers and customers.
 Who does it? Software engineers and other
 project stakeholders (managers, customers, end
 users) work together on an agile team—a team
 that is self-organizing and in control of its own
 destiny. An agile team fosters communication
 and collaboration among all who serve on it.
 Why is it important? The modern business envi
ronment that spawns computer-based systems
 and software products is fast-paced and ever
changing. Agile software engineering repre
sents a reasonable alternative to conventional
 software engineering for certain classes of soft
ware and certain types of software projects. It
 has been demonstrated to deliver successful sys
tems quickly.
 Whatarethesteps? Agiledevelopmentmightbest
 be termed “software engineering lite.” The basic
 framework activities—communication, planning,
 modeling, construction, and deployment—
 remain. But they morph into a minimal task set
 that pushes the project team toward construction
 and delivery (some would argue that this is
 done at the expense of problem analysis and
 solution design).
 What is the work product? Both the customer
 and the software engineer have the same
 view—the only really important work product
 is an operational “software increment” that is
 delivered to the customer on the appropriate
 commitment date.
 How do I ensure that I’ve done it right? If the
 agile team agrees that the process works, and
 the team produces deliverable software
 increments that satisfy the customer, you’ve
 done it right.
 65
66
 PART ONE THE SOFTWARE PROCESS
 FDD . . . . . . . . . .86
 Industrial XP . . .77
 Lean Software
 Development . . .87
 pair 
programming . . .76
 project 
velocity . . . . . . .74
 refactoring . . . . .75
 Scrum . . . . . . . .82
 stories . . . . . . . .74
 XP process . . . . .73
 uote:
 “Agility: 1,
 everything else: 0.”
 Tom DeMarco
 A manifesto is normally associated with an emerging political movement—one
 that attacks the old guard and suggests revolutionary change (hopefully for the
 better). In some ways, that’s exactly what agile development is all about.
 Although the underlying ideas that guide agile development have been with us for
 many years, it has been less than two decades since these ideas have crystallized
 into a “movement.” In essence, agile1 methods were developed in an effort to over
come perceived and actual weaknesses in conventional software engineering. Agile
 development can provide important benefits, but it is not applicable to all projects,
 all products, all people, and all situations. It is also not antithetical to solid software
 engineering practice and can be applied as an overriding philosophy for all software
 work.
 In the modern economy, it is often difficult or impossible to predict how a
 computer-based system (e.g., a Web-based application) will evolve as time passes.
 Market conditions change rapidly, end-user needs evolve, and new competitive
 threats emerge without warning. In many situations, you won’t be able to define
 requirements fully before the project begins. You must be agile enough to respond to
 a fluid business environment.
 Fluidity implies change, and change is expensive. Particularly if it is uncontrolled
 or poorly managed. One of the most compelling characteristics of the agile approach
 is its ability to reduce the costs of change throughout the software process.
 Does this mean that a recognition of challenges posed by modern realities causes
 you to discard valuable software engineering principles, concepts, methods, and
 tools? Absolutely not! Like all engineering disciplines, software engineering contin
ues to evolve. It can be adapted easily to meet the challenges posed by a demand for
 agility.
 In a thought-provoking book on agile software development, Alistair Cockburn
 [Coc02] argues that the prescriptive process models introduced in Chapter 2 have a
 major failing: they forget the frailties of the people who build computer software. Software
 engineers are not robots. They exhibit great variation in working styles; significant dif
ferences in skill level, creativity, orderliness, consistency, and spontaneity. Some com
municate well in written form, others do not. Cockburn argues that process models
 can “deal with people’s common weaknesses with [either] discipline or tolerance” and
 that most prescriptive process models choose discipline. He states: “Because consis
tency in action is a human weakness, high discipline methodologies are fragile.”
 If process models are to work, they must provide a realistic mechanism for en
couraging the discipline that is necessary, or they must be characterized in a man
ner that shows “tolerance” for the people who do software engineering work.
 Invariably, tolerant practices are easier for software people to adopt and sustain, but
 (as Cockburn admits) they may be less productive. Like most things in life, trade-offs
 must be considered.
 1 Agile methods are sometimes referred to as light methods or lean methods.
67
 CHAPTER 3 AGILE DEVELOPMENT
 3.1 WHAT IS AGILITY?
 Just what is agility in the context of software engineering work? Ivar Jacobson
 [Jac02a] provides a useful discussion:
 Agility has become today’s buzzword when describing a modern software process. Every
one is agile. An agile team is a nimble team able to appropriately respond to changes.
 Change is what software development is very much about. Changes in the software be
ing built, changes to the team members, changes because of new technology, changes of
 all kinds that may have an impact on the product they build or the project that creates the
 product. Support for changes should be built-in everything we do in software, something
 we embrace because it is the heart and soul of software. An agile team recognizes that
 software is developed by individuals working in teams and that the skills of these people,
 their ability to collaborate is at the core for the success of the project.
 Don’t make the
 mistake of assuming
 that agility gives you
 license to hack out
 solutions. A process is
 required and discipline
 is essential.
 In Jacobson’s view, the pervasiveness of change is the primary driver for agility. Soft
ware engineers must be quick on their feet if they are to accommodate the rapid
 changes that Jacobson describes.
 But agility is more than an effective response to change. It also encompasses the
 philosophy espoused in the manifesto noted at the beginning of this chapter. It
 encourages team structures and attitudes that make communication (among team
 members, between technologists and business people, between software engineers
 and their managers) more facile. It emphasizes rapid delivery of operational soft
ware and de-emphasizes the importance of intermediate work products (not always
 a good thing); it adopts the customer as a part of the development team and works
 to eliminate the “us and them” attitude that continues to pervade many software
 projects; it recognizes that planning in an uncertain world has its limits and that a
 project plan must be flexible.
 Agility can be applied to any software process. However, to accomplish this, it is
 essential that the process be designed in a way that allows the project team to adapt
 tasks and to streamline them, conduct planning in a way that understands the fluid
ity of an agile development approach, eliminate all but the most essential work prod
ucts and keep them lean, and emphasize an incremental delivery strategy that gets
 working software to the customer as rapidly as feasible for the product type and
 operational environment.
 3.2 AGILITY AND THE COST OF CHANGE
 The conventional wisdom in software development (supported by decades of expe
rience) is that the cost of change increases nonlinearly as a project progresses
 (Figure 3.1, solid black curve). It is relatively easy to accommodate a change when a
 software team is gathering requirements (early in a project). A usage scenario might
 have to be modified, a list of functions may be extended, or a written specification
 can be edited. The costs of doing this work are minimal, and the time required will
68
 PART ONE THE SOFTWARE PROCESS
 FIGURE 3.1
 Change costs
 as a function
 of time in
 development
 uote:
 Development cost
 Cost of change
 using conventional
 software processes
 Cost of change
 using agile processes
 “Agility is dynamic,
 content specific,
 aggressively
 change embracing,
 and growth
 oriented.”
 Idealized cost of change
 using agile process
 Development schedule progress–Steven
 Goldman et al.
 An agile process
 reduces the cost of
 change because
 software is released in
 increments and change
 can be better
 controlled within an
 increment.
 not adversely affect the outcome of the project. But what if we fast-forward a num
ber of months? The team is in the middle of validation testing (something that occurs
 relatively late in the project), and an important stakeholder is requesting a major
 functional change. The change requires a modification to the architectural design of
 the software, the design and construction of three new components, modifications
 to another five components, the design of new tests, and so on. Costs escalate
 quickly, and the time and cost required to ensure that the change is made without
 unintended side effects is nontrivial.
 Proponents of agility (e.g., [Bec00], [Amb04]) argue that a well-designed agile
 process “flattens” the cost of change curve (Figure 3.1, shaded, solid curve), allowing
 a software team to accommodate changes late in a software project without dramatic
 cost and time impact. You’ve already learned that the agile process encompasses in
cremental delivery. When incremental delivery is coupled with other agile practices
 such as continuous unit testing and pair programming (discussed later in this chap
ter), the cost of making a change is attenuated. Although debate about the degree to
 which the cost curve flattens is ongoing, there is evidence [Coc01a] to suggest that a
 significant reduction in the cost of change can be achieved.
 3.3 WHAT IS ANAGILE PROCESS?
 Any agile software process is characterized in a manner that addresses a number of
 key assumptions [Fow02] about the majority of software projects: 
1. It is difficult to predict in advance which software requirements will persist
 and which will change. It is equally difficult to predict how customer
 priorities will change as the project proceeds.
69
 CHAPTER 3 AGILE DEVELOPMENT
 WebRef
 A comprehensive
 collection of articles on
 the agile process 
can be found at
 www.aanpo.org/
 articles/index.
 Although agile
 processes embrace
 change, it is still
 important to examine
 the reasons for
 change.
 Working software is
 important, but don’t
 forget that it must also
 exhibit a variety of
 quality attributes
 including reliability,
 usability, and 
maintainability.
 2. For many types of software, design and construction are interleaved. That is,
 both activities should be performed in tandem so that design models are
 proven as they are created. It is difficult to predict how much design is
 necessary before construction is used to prove the design.
 3. Analysis, design, construction, and testing are not as predictable (from a
 planning point of view) as we might like.
 Given these three assumptions, an important question arises: How do we create a
 process that can manage unpredictability? The answer, as I have already noted, lies
 in process adaptability (to rapidly changing project and technical conditions). An
 agile process, therefore, must be adaptable.
 But continual adaptation without forward progress accomplishes little. Therefore,
 an agile software process must adapt incrementally. To accomplish incremental adap
tation, an agile team requires customer feedback (so that the appropriate adaptations
 can be made). An effective catalyst for customer feedback is an operational prototype
 or a portion of an operational system. Hence, an incremental development strategy
 should be instituted. Software increments (executable prototypes or portions of an op
erational system) must be delivered in short time periods so that adaptation keeps pace
 with change (unpredictability). This iterative approach enables the customer to evalu
ate the software increment regularly, provide necessary feedback to the software team,
 and influence the process adaptations that are made to accommodate the feedback.
 3.3.1 Agility Principles
 The Agile Alliance (see [Agi03], [Fow01]) defines 12 agility principles for those who
 want to achieve agility: 
1. Our highest priority is to satisfy the customer through early and continuous
 delivery of valuable software.
 2. Welcome changing requirements, even late in development. Agile processes
 harness change for the customer’s competitive advantage.
 3. Deliver working software frequently, from a couple of weeks to a couple of
 months, with a preference to the shorter timescale.
 4. Business people and developers must work together daily throughout the
 project.
 5. Build projects around motivated individuals. Give them the environment and
 support they need, and trust them to get the job done.
 6. The most efficient and effective method of conveying information to and
 within a development team is face-to-face conversation.
 7. Working software is the primary measure of progress.
 8. Agile processes promote sustainable development. The sponsors, developers,
 and users should be able to maintain a constant pace indefinitely.
70
 PART ONE THE SOFTWARE PROCESS
 9. Continuous attention to technical excellence and good design enhances
 agility.
 10. Simplicity—the art of maximizing the amount of work not done—is 
essential.
 11. The best architectures, requirements, and designs emerge from self
organizing teams.
 12. At regular intervals, the team reflects on how to become more effective, then
 tunes and adjusts its behavior accordingly.
 Not every agile process model applies these 12 principles with equal weight, and
 some models choose to ignore (or at least downplay) the importance of one or more
 of the principles. However, the principles define an agile spirit that is maintained in
 each of the process models presented in this chapter.
 3.3.2 The Politics of Agile Development
 You don’t have to
 choose between agility
 and software engi
neering. Rather, define
 a software engineering
 approach that is agile.
 There is considerable debate (sometimes strident) about the benefits and applicabil
ity of agile software development as opposed to more conventional software engi
neering processes. Jim Highsmith [Hig02a] (facetiously) states the extremes when he
 characterizes the feeling of the pro-agility camp (“agilists”). “Traditional methodolo
gists are a bunch of stick-in-the-muds who’d rather produce flawless documentation
 than a working system that meets business needs.” As a counterpoint, he states
 (again, facetiously) the position of the traditional software engineering camp: “Light
weight, er, ‘agile’ methodologists are a bunch of glorified hackers who are going to
 be in for a heck of a surprise when they try to scale up their toys into enterprise-wide
 software.”
 Like all software technology arguments, this methodology debate risks degener
ating into a religious war. If warfare breaks out, rational thought disappears and
 beliefs rather than facts guide decision making.
 No one is against agility. The real question is: What is the best way to achieve it?
 As important, how do you build software that meets customers’ needs today and
 exhibits the quality characteristics that will enable it to be extended and scaled to
 meet customers’ needs over the long term?
 There are no absolute answers to either of these questions. Even within the agile
 school itself, there are many proposed process models (Section 3.4), each with a
 subtly different approach to the agility problem. Within each model there is a set of
 “ideas” (agilists are loath to call them “work tasks”) that represent a significant
 departure from traditional software engineering. And yet, many agile concepts are
 simply adaptations of good software engineering concepts. Bottom line: there is
 much that can be gained by considering the best of both schools and virtually
 nothing to be gained by denigrating either approach.
 If you have further interest, see [Hig01], [Hig02a], and [DeM02] for an entertain
ing summary of other important technical and political issues.
71
 CHAPTER 3 AGILE DEVELOPMENT
 uote:
 “Agile methods
 derive much of
 their agility by
 relying on the
 tacit knowledge
 embodied in the
 team, rather than
 writing the
 knowledge down
 in plans.”
 Barry Boehm
 ?
 What key
 traits must
 exist among the
 people on an
 effective software
 team?
 uote:
 “What counts as
 barely sufficient
 for one team is
 either overly
 sufficient or
 insufficient for
 another.”
 Alistair
 Cockburn
 3.3.3 Human Factors
 Proponents of agile software development take great pains to emphasize the impor
tance of “people factors.” As Cockburn and Highsmith [Coc01a] state, “Agile devel
opment focuses on the talents and skills of individuals, molding the process to
 specific people and teams.” The key point in this statement is that the process molds
 to the needs of the people and team, not the other way around.2
 If members of the software team are to drive the characteristics of the process that
 is applied to build software, a number of key traits must exist among the people on
 an agile team and the team itself:
 Competence. In an agile development (as well as software engineering)
 context, “competence” encompasses innate talent, specific software-related
 skills, and overall knowledge of the process that the team has chosen to
 apply. Skill and knowledge of process can and should be taught to all people
 who serve as agile team members.
 Common focus. Although members of the agile team may perform differ
ent tasks and bring different skills to the project, all should be focused on one
 goal—to deliver a working software increment to the customer within the
 time promised. To achieve this goal, the team will also focus on continual
 adaptations (small and large) that will make the process fit the needs of the
 team.
 Collaboration. Software engineering (regardless of process) is about as
sessing, analyzing, and using information that is communicated to the soft
ware team; creating information that will help all stakeholders understand
 the work of the team; and building information (computer software and rele
vant databases) that provides business value for the customer. To accomplish
 these tasks, team members must collaborate—with one another and all other
 stakeholders.
 Decision-making ability. Any good software team (including agile teams)
 must be allowed the freedom to control its own destiny. This implies that the
 team is given autonomy—decision-making authority for both technical and
 project issues.
 Fuzzy problem-solving ability. Software managers must recognize that
 the agile team will continually have to deal with ambiguity and will continu
ally be buffeted by change. In some cases, the team must accept the fact that
 the problem they are solving today may not be the problem that needs to be
 solved tomorrow. However, lessons learned from any problem-solving
 2 Successful software engineering organizations recognize this reality regardless of the process
 model they choose.
72
 PART ONE THE SOFTWARE PROCESS
 A self-organizing team
 is in control of the
 work it performs. The
 team makes its own
 commitments and
 defines plans to
 achieve them.
 activity (including those that solve the wrong problem) may be of benefit to
 the team later in the project.
 Mutual trust and respect. The agile team must become what DeMarco
 and Lister [DeM98] call a “jelled” team (Chapter 24). A jelled team exhibits
 the trust and respect that are necessary to make them “so strongly knit that
 the whole is greater than the sum of the parts.” [DeM98]
 Self-organization. In the context of agile development, self-organization
 implies three things: (1) the agile team organizes itself for the work to be
 done, (2) the team organizes the process to best accommodate its local envi
ronment, (3) the team organizes the work schedule to best achieve delivery
 of the software increment. Self-organization has a number of technical bene
fits, but more importantly, it serves to improve collaboration and boost team
 morale. In essence, the team serves as its own management. Ken Schwaber
 [Sch02] addresses these issues when he writes: “The team selects how much
 work it believes it can perform within the iteration, and the team commits to
 the work. Nothing demotivates a team as much as someone else making
 commitments for it. Nothing motivates a team as much as accepting the
 responsibility for fulfilling commitments that it made itself.”
 3.4 EXTREME PROGRAMMING (XP)
 In order to illustrate an agile process in a bit more detail, I’ll provide you with an
 overview of Extreme Programming (XP), the most widely used approach to agile soft
ware development. Although early work on the ideas and methods associated with
 XP occurred during the late 1980s, the seminal work on the subject has been written
 by Kent Beck [Bec04a]. More recently, a variant of XP, called Industrial XP (IXP) has
 been proposed [Ker05]. IXP refines XP and targets the agile process specifically for
 use within large organizations.
 3.4.1 XP Values
 Beck [Bec04a] defines a set of five values that establish a foundation for all work per
formed as part of XP—communication, simplicity, feedback, courage, and respect. Each
 of these values is used as a driver for specific XP activities, actions, and tasks.
 In order to achieve effective communication between software engineers and
 other stakeholders (e.g., to establish required features and functions for the soft
ware), XP emphasizes close, yet informal (verbal) collaboration between customers
 and developers, the establishment of effective metaphors3 for communicating
 important concepts, continuous feedback, and the avoidance of voluminous docu
mentation as a communication medium.
 3 In the XP context, a metaphor is “a story that everyone—customers, programmers, and managers—
 can tell about how the system works” [Bec04a].
73
 CHAPTER 3 AGILE DEVELOPMENT
 Keep it simple
 whenever you can, but
 recognize that
 continual “refactoring”
 can absorb significant
 time and resources.
 uote:
 “XP is the answer
 to the question,
 ‘How little can we
 do and still build
 great software?’“
 Anonymous
 WebRef
 An excellent overview
 of “rules” for XP can
 be found at www
 .extremeprogramm
 ing.org/rules.html.
 To achieve simplicity, XP restricts developers to design only for immediate needs,
 rather than consider future needs. The intent is to create a simple design that can be
 easily implemented in code). If the design must be improved, it can be refactored4 at
 a later time.
 Feedback is derived from three sources: the implemented software itself, the
 customer, and other software team members. By designing and implementing an
 effective testing strategy (Chapters 17 through 20), the software (via test results) pro
vides the agile team with feedback. XP makes use of the unit test as its primary test
ing tactic. As each class is developed, the team develops a unit test to exercise each
 operation according to its specified functionality. As an increment is delivered to a
 customer, the user stories or use cases (Chapter 5) that are implemented by the
 increment are used as a basis for acceptance tests. The degree to which the software
 implements the output, function, and behavior of the use case is a form of feedback.
 Finally, as new requirements are derived as part of iterative planning, the team pro
vides the customer with rapid feedback regarding cost and schedule impact.
 Beck [Bec04a] argues that strict adherence to certain XP practices demands
 courage. A better word might be discipline. For example, there is often significant
 pressure to design for future requirements. Most software teams succumb, arguing
 that “designing for tomorrow” will save time and effort in the long run. An agile XP
 team must have the discipline (courage) to design for today, recognizing that future
 requirements may change dramatically, thereby demanding substantial rework of
 the design and implemented code.
 By following each of these values, the agile team inculcates respect among it
 members, between other stakeholders and team members, and indirectly, for the
 software itself. As they achieve successful delivery of software increments, the team
 develops growing respect for the XP process.
 3.4.2 The XP Process
 Extreme Programming uses an object-oriented approach (Appendix 2) as its pre
ferred development paradigm and encompasses a set of rules and practices that
 occur within the context of four framework activities: planning, design, coding, and
 testing. Figure 3.2 illustrates the XP process and notes some of the key ideas and
 tasks that are associated with each framework activity. Key XP activities are sum
marized in the paragraphs that follow.
 Planning. The planning activity (also called the planning game) begins with
 listening—a requirements gathering activity that enables the technical members of
 the XP team to understand the business context for the software and to get a broad
 4 Refactoring allows a software engineer to improve the internal structure of a design (or source
 code) without changing its external functionality or behavior. In essence, refactoring can be used
 to improve the efficiency, readability, or performance of a design or the code that implements a
 design.
74
 PART ONE THE SOFTWARE PROCESS
 FIGURE 3.2
 The Extreme
 Programming
 process
 ?
 What is an
 XP “story”?
 WebRef
 A worthwhile XP
 “planning game” can
 be found at:
 c2.com/cgi/
 wiki?planningGame.
 simple design
 CRC cards
 user stories
 values
 acceptance test criteria
 iteration plan
 Release
 spike solutions
 prototypes
 refactoring
 design
 pair programming
 planning
 software increment
 project velocity computed
 unit test
 continuous integration
 acceptance testing
 test
 coding
 feel for required output and major features and functionality. Listening leads to the
 creation of a set of “stories” (also called user stories) that describe required output,
 features, and functionality for software to be built. Each story (similar to use cases
 described in Chapter 5) is written by the customer and is placed on an index card.
 The customer assigns a value (i.e., a priority) to the story based on the overall busi
ness value of the feature or function.5 Members of the XP team then assess each
 story and assign a cost—measured in development weeks—to it. If the story is esti
mated to require more than three development weeks, the customer is asked to split
 the story into smaller stories and the assignment of value and cost occurs again. It
 is important to note that new stories can be written at any time.
 Customers and developers work together to decide how to group stories into the
 next release (the next software increment) to be developed by the XP team. Once a
 basic commitment (agreement on stories to be included, delivery date, and other
 project matters) is made for a release, the XP team orders the stories that will be de
veloped in one of three ways: (1) all stories will be implemented immediately (within
 a few weeks), (2) the stories with highest value will be moved up in the schedule and
 implemented first, or (3) the riskiest stories will be moved up in the schedule and
 implemented first.
 After the first project release (also called a software increment) has been deliv
ered, the XP team computes project velocity. Stated simply, project velocity is the
 5 The value of a story may also be dependent on the presence of another story.
75
 CHAPTER 3 AGILE DEVELOPMENT
 Project velocity is a
 subtle measure of
 team productivity.
 XP deemphasizes the
 importance of design.
 Not everyone agrees.
 In fact, there are times
 when design should be
 emphasized.
 WebRef
 Refactoring techniques
 and tools can be
 found at:
 www.refactoring
 .com.
 number of customer stories implemented during the first release. Project velocity can
 then be used to (1) help estimate delivery dates and schedule for subsequent releases
 and (2) determine whether an overcommitment has been made for all stories across
 the entire development project. If an overcommitment occurs, the content of releases
 is modified or end delivery dates are changed.
 As development work proceeds, the customer can add stories, change the value
 of an existing story, split stories, or eliminate them. The XP team then reconsiders all
 remaining releases and modifies its plans accordingly.
 Design. XP design rigorously follows the KIS (keep it simple) principle. A simple
 design is always preferred over a more complex representation. In addition, the de
sign provides implementation guidance for a story as it is written—nothing less,
 nothing more. The design of extra functionality (because the developer assumes it
 will be required later) is discouraged.6
 XP encourages the use of CRC cards (Chapter 7) as an effective mechanism for
 thinking about the software in an object-oriented context. CRC (class-responsibility
collaborator) cards identify and organize the object-oriented classes7 that are rele
vant to the current software increment. The XP team conducts the design exercise
 using a process similar to the one described in Chapter 8. The CRC cards are the only
 design work product produced as part of the XP process.
 If a difficult design problem is encountered as part of the design of a story, XP rec
ommends the immediate creation of an operational prototype of that portion of the
 design. Called a spike solution, the design prototype is implemented and evaluated.
 The intent is to lower risk when true implementation starts and to validate the orig
inal estimates for the story containing the design problem.
 In the preceding section, we noted that XP encourages refactoring—a construction
 technique that is also a method for design optimization. Fowler [Fow00] describes
 refactoring in the following manner:
 Refactoring is the process of changing a software system in such a way that it does not
 alter the external behavior of the code yet improves the internal structure. It is a disci
plined way to clean up code [and modify/simplify the internal design] that minimizes the
 chances of introducing bugs. In essence, when you refactor you are improving the design
 of the code after it has been written.
 Because XP design uses virtually no notation and produces few, if any, work prod
ucts other than CRC cards and spike solutions, design is viewed as a transient arti
fact that can and should be continually modified as construction proceeds. The intent
 of refactoring is to control these modifications by suggesting small design changes
 6 These design guidelines should be followed in every software engineering method, although there
 are times when sophisticated design notation and terminology may get in the way of simplicity.
 7 Object-oriented classes are discussed in Appendix 2, in Chapter 8, and throughout Part 2 of this
 book.
76
 PART ONE THE SOFTWARE PROCESS
 Refactoring improves
 the internal structure of
 a design (or source
 code) without
 changing its external
 functionality or
 behavior.
 WebRef
 Useful information on
 XP can be obtained 
at www
 .xprogramming.
 com.
 ?
 What is 
pair
 programming?
 Many software teams
 are populated by indi
vidualists. You’ll have
 to work to change that
 culture if pair program
ming is to work effec
tively.
 ?
 XP?
 How are unit
 tests used in
 that “can radically improve the design” [Fow00]. It should be noted, however, that
 the effort required for refactoring can grow dramatically as the size of an application
 grows.
 A central notion in XP is that design occurs both before and after coding com
mences. Refactoring means that design occurs continuously as the system is con
structed. In fact, the construction activity itself will provide the XP team with
 guidance on how to improve the design.
 Coding. After stories are developed and preliminary design work is done, the team
 does not move to code, but rather develops a series of unit tests that will exercise
 each of the stories that is to be included in the current release (software increment).8
 Once the unit test9 has been created, the developer is better able to focus on what
 must be implemented to pass the test. Nothing extraneous is added (KIS). Once the
 code is complete, it can be unit-tested immediately, thereby providing instantaneous
 feedback to the developers.
 A key concept during the coding activity (and one of the most talked about aspects
 of XP) is pair programming. XP recommends that two people work together at one
 computer workstation to create code for a story. This provides a mechanism for real
time problem solving (two heads are often better than one) and real-time quality as
surance (the code is reviewed as it is created). It also keeps the developers focused
 on the problem at hand. In practice, each person takes on a slightly different role. For
 example, one person might think about the coding details of a particular portion of
 the design while the other ensures that coding standards (a required part of XP) are
 being followed or that the code for the story will satisfy the unit test that has been
 developed to validate the code against the story.
 As pair programmers complete their work, the code they develop is integrated
 with the work of others. In some cases this is performed on a daily basis by an inte
gration team. In other cases, the pair programmers have integration responsibility.
 This “continuous integration” strategy helps to avoid compatibility and interfacing
 problems and provides a “smoke testing” environment (Chapter 17) that helps to
 uncover errors early.
 Testing. I have already noted that the creation of unit tests before coding com
mences is a key element of the XP approach. The unit tests that are created should
 be implemented using a framework that enables them to be automated (hence, they
 can be executed easily and repeatedly). This encourages a regression testing strat
egy (Chapter 17) whenever code is modified (which is often, given the XP refactor
ing philosophy).
 8 This approach is analogous to knowing the exam questions before you begin to study. It makes
 studying much easier by focusing attention only on the questions that will be asked.
 9 Unit testing, discussed in detail in Chapter 17, focuses on an individual software component, exer
cising the component’s interface, data structures, and functionality in an effort to uncover errors
 that are local to the component.
77
 CHAPTER 3 AGILE DEVELOPMENT
 XP acceptance tests
 are derived from user
 stories.
 ?
 What new
 practices are
 appended to XP
 to create IXP?
 uote:
 “Ability is what
 you’re capable of
 doing. Motivation
 determines what
 you do. Attitude
 determines how
 well you do it.”
 Lou Holtz
 As the individual unit tests are organized into a “universal testing suite” [Wel99],
 integration and validation testing of the system can occur on a daily basis. This pro
vides the XP team with a continual indication of progress and also can raise warn
ing flags early if things go awry. Wells [Wel99] states: “Fixing small problems every
 few hours takes less time than fixing huge problems just before the deadline.”
 XP acceptance tests, also called customer tests, are specified by the customer and
 focus on overall system features and functionality that are visible and reviewable by
 the customer. Acceptance tests are derived from user stories that have been imple
mented as part of a software release.
 3.4.3 Industrial XP
 Joshua Kerievsky [Ker05] describes Industrial Extreme Programming (IXP) in the fol
lowing manner: “IXP is an organic evolution of XP. It is imbued with XP’s minimal
ist, customer-centric, test-driven spirit. IXP differs most from the original XP in its
 greater inclusion of management, its expanded role for customers, and its upgraded
 technical practices.” IXP incorporates six new practices that are designed to help
 ensure that an XP project works successfully for significant projects within a large
 organization.
 Readiness assessment. Prior to the initiation of an IXP project, the organ
ization should conduct a readiness assessment. The assessment ascertains
 whether (1) an appropriate development environment exists to support IXP,
 (2) the team will be populated by the proper set of stakeholders, (3) the or
ganization has a distinct quality program and supports continuous improve
ment, (4) the organizational culture will support the new values of an agile
 team, and (5) the broader project community will be populated appropriately.
 Project community. Classic XP suggests that the right people be used to
 populate the agile team to ensure success. The implication is that people on
 the team must be well-trained, adaptable and skilled, and have the proper
 temperament to contribute to a self-organizing team. When XP is to be
 applied for a significant project in a large organization, the concept of the
 “team” should morph into that of a community. A community may have a
 technologist and customers who are central to the success of a project as
 well as many other stakeholders (e.g., legal staff, quality auditors, manufac
turing or sales types) who “are often at the periphery of an IXP project yet
 they may play important roles on the project” [Ker05]. In IXP, the community
 members and their roles should be explicitly defined and mechanisms for
 communication and coordination between community members should be
 established.
 Project chartering. The IXP team assesses the project itself to determine
 whether an appropriate business justification for the project exists and
 whether the project will further the overall goals and objectives of the
78
 PART ONE THE SOFTWARE PROCESS
 organization. Chartering also examines the context of the project to deter
mine how it complements, extends, or replaces existing systems or
 processes.
 Test-driven management. An IXP project requires measurable criteria for
 assessing the state of the project and the progress that has been made to
 date. Test-driven management establishes a series of measurable “destina
tions” [Ker05] and then defines mechanisms for determining whether or not
 these destinations have been reached.
 Retrospectives. An IXP team conducts a specialized technical review
 (Chapter 15) after a software increment is delivered. Called a retrospective,
 the review examines “issues, events, and lessons-learned” [Ker05] across a
 software increment and/or the entire software release. The intent is to
 improve the IXP process.
 Continuous learning. Because learning is a vital part of continuous
 process improvement, members of the XP team are encouraged (and possi
bly, incented) to learn new methods and techniques that can lead to a higher
quality product.
 In addition to the six new practices discussed, IXP modifies a number of existing
 XP practices. Story-driven development (SDD) insists that stories for acceptance tests
 be written before a single line of code is generated. Domain-driven design (DDD) is
 an improvement on the “system metaphor” concept used in XP. DDD [Eva03] sug
gests the evolutionary creation of a domain model that “accurately represents how
 domain experts think about their subject” [Ker05]. Pairing extends the XP pair
programming concept to include managers and other stakeholders. The intent is to
 improve knowledge sharing among XP team members who may not be directly in
volved in technical development. Iterative usability discourages front-loaded inter
face design in favor of usability design that evolves as software increments are
 delivered and users’ interaction with the software is studied.
 IXP makes smaller modifications to other XP practices and redefines certain roles
 and responsibilities to make them more amenable to significant projects for large
 organizations. For further discussion of IXP, visit http://industrialxp.org.
 3.4.4 The XP Debate
 All new process models and methods spur worthwhile discussion and in some in
stances heated debate. Extreme Programming has done both. In an interesting book
 that examines the efficacy of XP, Stephens and Rosenberg [Ste03] argue that many
 XP practices are worthwhile, but others have been overhyped, and a few are prob
lematic. The authors suggest that the codependent nature of XP practices are both
 its strength and its weakness. Because many organizations adopt only a subset of XP
 practices, they weaken the efficacy of the entire process. Proponents counter that
 XP is continuously evolving and that many of the issues raised by critics have been
79
 CHAPTER 3 AGILE DEVELOPMENT
 addressed as XP practice matures. Among the issues that continue to trouble some
 critics of XP are:10
 ?
 What are
 some of the
 issues that lead to
 an XP debate?
 • Requirements volatility. Because the customer is an active member of the XP
 team, changes to requirements are requested informally. As a consequence,
 the scope of the project can change and earlier work may have to be
 modified to accommodate current needs. Proponents argue that this happens
 regardless of the process that is applied and that XP provides mechanisms for
 controlling scope creep.
 • Conflicting customer needs. Many projects have multiple customers, each with
 his own set of needs. In XP, the team itself is tasked with assimilating the
 needs of different customers, a job that may be beyond their scope of
 authority.
 • Requirements are expressed informally. User stories and acceptance tests are
 the only explicit manifestation of requirements in XP. Critics argue that a
 more formal model or specification is often needed to ensure that omissions,
 inconsistencies, and errors are uncovered before the system is built. Propo
nents counter that the changing nature of requirements makes such models
 and specification obsolete almost as soon as they are developed.
 • Lack of formal design. XP deemphasizes the need for architectural design and
 in many instances, suggests that design of all kinds should be relatively
 informal. Critics argue that when complex systems are built, design must be
 emphasized to ensure that the overall structure of the software will exhibit
 quality and maintainability. XP proponents suggest that the incremental
 nature of the XP process limits complexity (simplicity is a core value) and
 therefore reduces the need for extensive design.
 You should note that every software process has flaws and that many software or
ganizations have used XP successfully. The key is to recognize where a process may
 have weaknesses and to adapt it to the specific needs of your organization.
 SAFEHOME
 Considering Agile Software Development
 The scene: Doug Miller’s office.
 The Players: Doug Miller, software engineering
 manager; Jamie Lazar, software team member; Vinod
 Raman, software team member.
 The conversation:
 (A knock on the door, Jamie and Vinod enter Doug’s office)
 Jamie: Doug, you got a minute?
 10 For a detailed look at some thoughtful criticism that has been leveled at XP, visit
 www.softwarereality.com/ExtremeProgramming.jsp.
3.5 OTHERAGILEPROCESSMODELS
 The history of software engineering is littered with dozens of obsolete process
 descriptions and methodologies, modeling methods and notations, tools, and
 technology. Each flared in notoriety and was then eclipsed by something new and
 (purportedly) better. With the introduction of a wide array of agile process models—
 each contending for acceptance within the software development community—the
 agile movement is following the same historical path.11
 As I noted in the last section, the most widely used of all agile process models
 isExtreme Programming (XP). But many other agile process models have been
 proposed and are in use across the industry. Among the most common are:
 •Adaptive Software Development (ASD)
 •Scrum
 •Dynamic Systems Development Method (DSDM)
 80 PART ONE THE SOFTWARE PROCESS
 Doug: Sure Jamie, what’s up?
 Jamie:We’ve been thinking about our process
 discussion yesterday . . . you know, what process we’re
 going to choose for this new SafeHomeproject.
 Doug:And?
 Vinod: I was talking to a friend at another company,
 and he was telling me about Extreme Programming. It’s
 an agile process model . . . heard of it?
 Doug: Yeah, some good, some bad.
 Jamie:Well, it sounds pretty good to us. Lets you
 develop software really fast, uses something called pair
 programming to do real-time quality checks . . . it’s pretty
 cool, I think.
 Doug: It does have a lot of really good ideas. I like the
 pair-programming concept, for instance, and the idea
 that stakeholders should be part of the team.
 Jamie:Huh? You mean that marketing will work on the
 project team with us?
 Doug (nodding): They’re a stakeholder, aren’t they?
 Jamie: Jeez . . . they’ll be requesting changes every five
 minutes.
 Vinod:Not necessarily. My friend said that there are
 ways to “embrace” changes during an XP project.
 Doug: So you guys think we should use XP?
 Jamie: It’s definitely worth considering.
 Doug: I agree. And even if we choose an incremental
 model as our approach, there’s no reason why we can’t
 incorporate much of what XP has to offer.
 Vinod:Doug, before you said “some good, some bad.”
 What was the “bad”?
 Doug: The thing I don’t like is the way XP downplays
 analysis and design . . . sort of says that writing code is
 where the action is . . . 
(The team members look at one another and smile.)
 Doug: So you agree with the XP approach?
 Jamie (speaking for both):Writing code is what
 we do, Boss!
 Doug (laughing): True, but I’d like to see you spend a
 little less time coding and then recoding and a little more
 time analyzing what has to be done and designing a
 solution that works.
 Vinod:Maybe we can have it both ways, agility with a
 little discipline.
 Doug: I think we can, Vinod. In fact, I’m sure of it.
 uote:
 “Our profession
 goes through
 methodologies like
 a 14-year-old goes
 through clothing.”
 Stephen
 Hawrysh and
 JimRuprecht
 11This is not a bad thing. Before one or more models or methods are accepted as a de facto standard,
 all must contend for the hearts and minds of software engineers. The “winners” evolve into best
 practice, while the “losers” either disappear or merge with the winning models.
81
 CHAPTER 3 AGILE DEVELOPMENT
 • Crystal
 • Feature Drive Development (FDD)
 • Lean Software Development (LSD)
 • Agile Modeling (AM)
 • Agile Unified Process (AUP)
 In the sections that follow, I present a very brief overview of each of these agile
 process models. It is important to note that all agile process models conform (to a
 greater or lesser degree) to the Manifesto for Agile Software Development and the prin
ciples noted in Section 3.3.1. For additional detail, refer to the references noted in
 each subsection or for a survey, examine the “agile software development” entry
 in Wikipedia.12
 3.5.1 Adaptive Software Development (ASD)
 WebRef
 Useful resources for
 ASD can be found at
 www.adaptivesd
 .com.
 Adaptive Software Development (ASD) has been proposed by Jim Highsmith [Hig00] as
 a technique for building complex software and systems. The philosophical under
pinnings of ASD focus on human collaboration and team self-organization.
 Highsmith argues that an agile, adaptive development approach based on collab
oration is “as much a source of order in our complex interactions as discipline and
 engineering.” He defines an ASD “life cycle” (Figure 3.3) that incorporates three
 phases, speculation, collaboration, and learning.
 FIGURE 3.3
 Adaptive
 software
 development
 adaptive cycle planning
 mission statement
 project constraints
 basic requirements
 time-boxed release plan
 Release
 Requirements gathering
 JAD
 mini-specs
 speculation
 software increment
 adjustments for subsequent cycles
 collaboration
 components implemented/tested
 focus groups for feedback
 formal technical reviews
 learning
 postmortems
 12 See http://en.wikipedia.org/wiki/Agile_software_development#Agile_methods.
82
 PART ONE THE SOFTWARE PROCESS
 Effective collaboration
 with your customer will
 only occur if you
 jettison any “us and
 them” attitudes.
 ASD emphasizes
 learning as a key
 element in achieving 
a “self-organizing”
 team.
 WebRef
 Useful Scrum
 information and
 resources can be found
 at www
 .controlchaos.com.
 During speculation, the project is initiated and adaptive cycle planning is con
ducted. Adaptive cycle planning uses project initiation information—the customer’s
 mission statement, project constraints (e.g., delivery dates or user descriptions), and
 basic requirements—to define the set of release cycles (software increments) that
 will be required for the project.
 No matter how complete and farsighted the cycle plan, it will invariably change.
 Based on information obtained at the completion of the first cycle, the plan is re
viewed and adjusted so that planned work better fits the reality in which an ASD
 team is working.
 Motivated people use collaboration in a way that multiplies their talent and cre
ative output beyond their absolute numbers. This approach is a recurring theme in
 all agile methods. But collaboration is not easy. It encompasses communication and
 teamwork, but it also emphasizes individualism, because individual creativity plays
 an important role in collaborative thinking. It is, above all, a matter of trust. People
 working together must trust one another to (1) criticize without animosity, (2) assist
 without resentment, (3) work as hard as or harder than they do, (4) have the skill set
 to contribute to the work at hand, and (5) communicate problems or concerns in a
 way that leads to effective action.
 As members of an ASD team begin to develop the components that are part of an
 adaptive cycle, the emphasis is on “learning” as much as it is on progress toward
 a completed cycle. In fact, Highsmith [Hig00] argues that software developers often
 overestimate their own understanding (of the technology, the process, and the proj
ect) and that learning will help them to improve their level of real understanding.
 ASD teams learn in three ways: focus groups (Chapter 5), technical reviews (Chap
ter 14), and project postmortems.
 The ASD philosophy has merit regardless of the process model that is used. ASD’s
 overall emphasis on the dynamics of self-organizing teams, interpersonal collabo
ration, and individual and team learning yield software project teams that have a
 much higher likelihood of success.
 3.5.2 Scrum
 Scrum (the name is derived from an activity that occurs during a rugby match13) is
 an agile software development method that was conceived by Jeff Sutherland and his
 development team in the early 1990s. In recent years, further development on the
 Scrum methods has been performed by Schwaber and Beedle [Sch01a].
 Scrum principles are consistent with the agile manifesto and are used to guide
 development activities within a process that incorporates the following framework
 activities: requirements, analysis, design, evolution, and delivery. Within each
 13 A group of players forms around the ball and the teammates work together (sometimes violently!)
 to move the ball downfield.
every 24
 hours
 30 days
 Scrum: 15 minute daily meeting.
 Team members respond to basics:
 1) What did you do since last Scrum
 meeting?
 2) Do you have any obstacles?
 3) What will you do before next
 meeting?
 Sprint Backlog:
 Feature(s)
 assigned
 to sprint
 Product Backlog:
 Prioritized product features desired by the customer
 Backlog
 items
 expanded
 by team
 New functionality
 is demonstrated
 at end of sprint
 framework activity, work tasks occur within a process pattern (discussed in the fol
lowing paragraph) called a sprint.The work conducted within a sprint (the number
 of sprints required for each framework activity will vary depending on product com
plexity and size) is adapted to the problem at hand and is defined and often modified
 in real time by the Scrum team. The overall flow of the Scrum process is illustrated
 in Figure 3.4.
 Scrum emphasizes the use of a set of software process patterns [Noy02] that have
 proven effective for projects with tight timelines, changing requirements, and business
 criticality. Each of these process patterns defines a set of development actions:
 Backlog—a prioritized list of project requirements or features that provide busi
ness value for the customer. Items can be added to the backlog at any time (this is
 how changes are introduced). The product manager assesses the backlog and
 updates priorities as required.
 Sprints—consist of work units that are required to achieve a requirement de
fined in the backlog that must be fit into a predefined time-box14(typically 30 days).
 CHAPTER 3 AGILE DEVELOPMENT 83
 14A time-boxis a project management term (see Part 4 of this book) that indicates a period of time
 that has been allocated to accomplish some task.
 FIGURE3.4
 Scrum process
 flow
 Scrum incorporates a
 set of process patterns
 that emphasize project
 priorities,
 compartmentalized
 work units,
 communication, and
 frequent customer
 feedback.
84
 PART ONE THE SOFTWARE PROCESS
 Changes (e.g., backlog work items) are not introduced during the sprint. Hence, the
 sprint allows team members to work in a short-term, but stable environment.
 Scrum meetings—are short (typically 15 minutes) meetings held daily by the Scrum
 team. Three key questions are asked and answered by all team members [Noy02]:
 • What did you do since the last team meeting?
 • What obstacles are you encountering?
 • What do you plan to accomplish by the next team meeting?
 A team leader, called a Scrum master, leads the meeting and assesses the responses
 from each person. The Scrum meeting helps the team to uncover potential problems
 as early as possible. Also, these daily meetings lead to “knowledge socialization”
 [Bee99] and thereby promote a self-organizing team structure.
 Demos—deliver the software increment to the customer so that functionality that
 has been implemented can be demonstrated and evaluated by the customer. It is im
portant to note that the demo may not contain all planned functionality, but rather
 those functions that can be delivered within the time-box that was established.
 Beedle and his colleagues [Bee99] present a comprehensive discussion of these pat
terns in which they state: “Scrum assumes up-front the existence of chaos. . . . ” The
 Scrum process patterns enable a software team to work successfully in a world
 where the elimination of uncertainty is impossible.
 3.5.3 Dynamic Systems Development Method (DSDM)
 WebRef
 Useful resources for
 DSSD can be found at
 www.dsdm.org.
 The Dynamic Systems Development Method (DSDM) [Sta97] is an agile software devel
opment approach that “provides a framework for building and maintaining systems
 which meet tight time constraints through the use of incremental prototyping in a con
trolled project environment” [CCS02]. The DSDM philosophy is borrowed from a mod
ified version of the Pareto principle—80 percent of an application can be delivered in
 20 percent of the time it would take to deliver the complete (100 percent) application.
 DSDM is an iterative software process in which each iteration follows the 80 per
cent rule. That is, only enough work is required for each increment to facilitate
 movement to the next increment. The remaining detail can be completed later when
 more business requirements are known or changes have been requested and
 accommodated.
 The DSDM Consortium (www.dsdm.org) is a worldwide group of member com
panies that collectively take on the role of “keeper” of the method. The consortium
 has defined an agile process model, called the DSDM life cycle that defines three dif
ferent iterative cycles, preceded by two additional life cycle activities:
 Feasibility study—establishes the basic business requirements and constraints
 associated with the application to be built and then assesses whether the applica
tion is a viable candidate for the DSDM process.
85
 CHAPTER 3 AGILE DEVELOPMENT
 DSDM is a process
 framework that can
 adopt the tactics of
 another agile approach
 such as XP.
 Crystal is a family of
 process models with
 the same “genetic
 code” but different
 methods for adapting
 to project
 characteristics.
 Business study—establishes the functional and information requirements that
 will allow the application to provide business value; also, defines the basic
 application architecture and identifies the maintainability requirements for the
 application.
 Functional model iteration—produces a set of incremental prototypes that
 demonstrate functionality for the customer. (Note: All DSDM prototypes are in
tended to evolve into the deliverable application.) The intent during this iterative
 cycle is to gather additional requirements by eliciting feedback from users as they
 exercise the prototype.
 Design and build iteration—revisits prototypes built during functional model
 iteration to ensure that each has been engineered in a manner that will enable it to
 provide operational business value for end users. In some cases, functional model
 iteration and design and build iteration occur concurrently.
 Implementation—places the latest software increment (an “operationalized” pro
totype) into the operational environment. It should be noted that (1) the increment
 may not be 100 percent complete or (2) changes may be requested as the incre
ment is put into place. In either case, DSDM development work continues by
 returning to the functional model iteration activity.
 DSDM can be combined with XP (Section 3.4) to provide a combination approach
 that defines a solid process model (the DSDM life cycle) with the nuts and bolts prac
tices (XP) that are required to build software increments. In addition, the ASD con
cepts of collaboration and self-organizing teams can be adapted to a combined
 process model.
 3.5.4 Crystal
 Alistair Cockburn [Coc05] and Jim Highsmith [Hig02b] created the Crystal family of
 agile methods15 in order to achieve a software development approach that puts a
 premium on “maneuverability” during what Cockburn characterizes as “a resource
limited, cooperative game of invention and communication, with a primary goal of
 delivering useful, working software and a secondary goal of setting up for the next
 game” [Coc02].
 To achieve maneuverability, Cockburn and Highsmith have defined a set of
 methodologies, each with core elements that are common to all, and roles, process
 patterns, work products, and practice that are unique to each. The Crystal family is
 actually a set of example agile processes that have been proven effective for differ
ent types of projects. The intent is to allow agile teams to select the member of the
 crystal family that is most appropriate for their project and environment.
 15 The name “crystal” is derived from the characteristics of geological crystals, each with its own
 color, shape, and hardness.
86
 PART ONE THE SOFTWARE PROCESS
 3.5.5 Feature Driven Development (FDD)
 WebRef
 A wide variety of
 articles and
 presentations on FDD
 can be found at:
 www.featuredrive
 ndevelopment
 .com/.
 Feature Driven Development (FDD) was originally conceived by Peter Coad and his
 colleagues [Coa99] as a practical process model for object-oriented software engi
neering. Stephen Palmer and John Felsing [Pal02] have extended and improved
 Coad’s work, describing an adaptive, agile process that can be applied to moderately
 sized and larger software projects.
 Like other agile approaches, FDD adopts a philosophy that (1) emphasizes col
laboration among people on an FDD team; (2) manages problem and project
 complexity using feature-based decomposition followed by the integration of
 software increments, and (3) communication of technical detail using verbal,
 graphical, and text-based means. FDD emphasizes software quality assurance
 activities by encouraging an incremental development strategy, the use of design
 and code inspections, the application of software quality assurance audits (Chap
ter 16), the collection of metrics, and the use of patterns (for analysis, design, and
 construction).
 In the context of FDD, a feature “is a client-valued function that can be imple
mented in two weeks or less” [Coa99]. The emphasis on the definition of features
 provides the following benefits:
 • Because features are small blocks of deliverable functionality, users can
 describe them more easily; understand how they relate to one another more
 readily; and better review them for ambiguity, error, or omissions.
 • Features can be organized into a hierarchical business-related grouping.
 • Since a feature is the FDD deliverable software increment, the team develops
 operational features every two weeks.
 • Because features are small, their design and code representations are easier
 to inspect effectively.
 • Project planning, scheduling, and tracking are driven by the feature
 hierarchy, rather than an arbitrarily adopted software engineering 
task set.
 Coad and his colleagues [Coa99] suggest the following template for defining a
 feature:
 <action> the <result> <by for of to> a(n) <object>
 where an <object> is “a person, place, or thing (including roles, moments in time or
 intervals of time, or catalog-entry-like descriptions).” Examples of features for an 
e-commerce application might be:
 Add the product to shopping cart
 Display the technical-specifications of the product
 Store the shipping-information for the customer
87
 CHAPTER 3 AGILE DEVELOPMENT
 FIGURE 3.5
 Feature Driven
 Development
 [Coa99] (with
 permission)
 Develop
 an
 Overall
 Model
 Build a
 Features
 List
 Plan
 By
 Feature
 Design
 By
 Feature
 (more shape
 than content)
 A list of features
 grouped into sets
 and subject areas
 A development plan
 Class owners
 Feature Set Owners
 A design
 package
 (sequences)
 Build
 By
 Feature
 Completed
 client-value
 function
 A feature set groups related features into business-related categories and is defined
 [Coa99] as:
 <action><-ing> a(n) <object>
 For example: Making a product sale is a feature set that would encompass the fea
tures noted earlier and others.
 The FDD approach defines five “collaborating” [Coa99] framework activities (in
 FDD these are called “processes”) as shown in Figure 3.5.
 FDD provides greater emphasis on project management guidelines and tech
niques than many other agile methods. As projects grow in size and complexity,
 ad hoc project management is often inadequate. It is essential for developers, their
 managers, and other stakeholders to understand project status—what accomplish
ments have been made and problems have been encountered. If deadline pressure
 is significant, it is critical to determine if software increments (features) are properly
 scheduled. To accomplish this, FDD defines six milestones during the design and
 implementation of a feature: “design walkthrough, design, design inspection, code,
 code inspection, promote to build” [Coa99].
 3.5.6 Lean Software Development (LSD)
 Lean Software Development (LSD) has adapted the principles of lean manufacturing
 to the world of software engineering. The lean principles that inspire the LSD process
 can be summarized ([Pop03], [Pop06a]) as eliminate waste, build quality in, create
 knowledge, defer commitment, deliver fast, respect people, and optimize the whole.
 Each of these principles can be adapted to the software process. For example,
 eliminate waste within the context of an agile software project can be interpreted
 to mean [Das05]: (1) adding no extraneous features or functions, (2) assessing the
 cost and schedule impact of any newly requested requirement, (3) removing any
 superfluous process steps, (4) establishing mechanisms to improve the way team
 members find information, (5) ensuring the testing finds as many errors as possible,
88
 PART ONE THE SOFTWARE PROCESS
 (6) reducing the time required to request and get a decision that affects the software
 or the process that is applied to create it, and (7) streamlining the manner in which
 information is transmitted to all stakeholders involved in the process.
 For a detailed discussion of LSD and pragmatic guidelines for implementing the
 process, you should examine [Pop06a] and [Pop06b].
 3.5.7 Agile Modeling (AM)
 WebRef
 Comprehensive
 information on agile
 modeling can be found
 at: www
 .agilemodeling.com.
 uote:
 “I was in the drug
 store the other day
 trying to get a cold
 medication . . . not
 easy. There’s an
 entire wall of
 products you need.
 You stand there
 going, Well, this
 one is quick acting
 but this is long
 lasting. . . . Which
 is more important,
 the present or the
 future?”
 Jerry Seinfeld
 There are many situations in which software engineers must build large, business
critical systems. The scope and complexity of such systems must be modeled so that
 (1) all constituencies can better understand what needs to be accomplished, (2) the
 problem can be partitioned effectively among the people who must solve it, and
 (3) quality can be assessed as the system is being engineered and built.
 Over the past 30 years, a wide variety of software engineering modeling methods
 and notation have been proposed for analysis and design (both architectural and
 component-level). These methods have merit, but they have proven to be difficult
 to apply and challenging to sustain (over many projects). Part of the problem is the
 “weight” of these modeling methods. By this I mean the volume of notation required,
 the degree of formalism suggested, the sheer size of the models for large projects,
 and the difficulty in maintaining the model(s) as changes occur. Yet analysis and de
sign modeling have substantial benefit for large projects—if for no other reason than
 to make these projects intellectually manageable. Is there an agile approach to soft
ware engineering modeling that might provide an alternative?
 At “The Official Agile Modeling Site,” Scott Ambler [Amb02a] describes agile mod
eling (AM) in the following manner:
 Agile Modeling (AM) is a practice-based methodology for effective modeling and documen
tation of software-based systems. Simply put, Agile Modeling (AM) is a collection of values,
 principles, and practices for modeling software that can be applied on a software develop
ment project in an effective and light-weight manner. Agile models are more effective than
 traditional models because they are just barely good, they don’t have to be perfect.
 Agile modeling adopts all of the values that are consistent with the agile manifesto.
 The agile modeling philosophy recognizes that an agile team must have the courage
 to make decisions that may cause it to reject a design and refactor. The team must
 also have the humility to recognize that technologists do not have all the answers and
 that business experts and other stakeholders should be respected and embraced.
 Although AM suggests a wide array of “core” and “supplementary” modeling prin
ciples, those that make AM unique are [Amb02a]:
 Model with a purpose. A developer who uses AM should have a specific
 goal (e.g., to communicate information to the customer or to help better un
derstand some aspect of the software) in mind before creating the model.
 Once the goal for the model is identified, the type of notation to be used and
 level of detail required will be more obvious.
89
 CHAPTER 3 AGILE DEVELOPMENT
 Use multiple models. There are many different models and notations that
 can be used to describe software. Only a small subset is essential for most
 projects. AM suggests that to provide needed insight, each model should
 present a different aspect of the system and only those models that provide
 value to their intended audience should be used.
 “Traveling light” is an
 appropriate philosophy
 for all software engi
neering work. Build
 only those models that
 provide value … no
 more, no less.
 Travel light. As software engineering work proceeds, keep only those mod
els that will provide long-term value and jettison the rest. Every work product
 that is kept must be maintained as changes occur. This represents work that
 slows the team down. Ambler [Amb02a] notes that “Every time you decide to
 keep a model you trade-off agility for the convenience of having that informa
tion available to your team in an abstract manner (hence potentially enhanc
ing communication within your team as well as with project stakeholders).”
 Content is more important than representation. Modeling should im
part information to its intended audience. A syntactically perfect model that
 imparts little useful content is not as valuable as a model with flawed nota
tion that nevertheless provides valuable content for its audience.
 Know the models and the tools you use to create them. Understand
 the strengths and weaknesses of each model and the tools that are used to
 create it.
 Adapt locally. The modeling approach should be adapted to the needs of
 the agile team.
 A major segment of the software engineering community has adopted the Unified
 Modeling Language (UML)16 as the preferred method for representing analysis and
 design models. The Unified Process (Chapter 2) has been developed to provide a
 framework for the application of UML. Scott Ambler [Amb06] has developed a sim
plified version of the UP that integrates his agile modeling philosophy.
 3.5.8 Agile Unified Process (AUP)
 The Agile Unified Process (AUP) adopts a “serial in the large” and “iterative in the
 small” [Amb06] philosophy for building computer-based systems. By adopting the
 classic UP phased activities—inception, elaboration, construction, and transition—AUP
 provides a serial overlay (i.e., a linear sequence of software engineering activities)
 that enables a team to visualize the overall process flow for a software project. How
ever, within each of the activities, the team iterates to achieve agility and to deliver
 meaningful software increments to end users as rapidly as possible. Each AUP iter
ation addresses the following activities [Amb06]: 
• Modeling. UML representations of the business and problem domains are
 created. However, to stay agile, these models should be “just barely good
 enough” [Amb06] to allow the team to proceed.
 16 A brief tutorial on UML is presented in Appendix 1.
90
 PART ONE THE SOFTWARE PROCESS
 • Implementation. Models are translated into source code.
 • Testing. Like XP, the team designs and executes a series of tests to uncover
 errors and ensure that the source code meets its requirements.
 • Deployment. Like the generic process activity discussed in Chapters 1 and 2,
 deployment in this context focuses on the delivery of a software increment
 and the acquisition of feedback from end users.
 • Configuration and project management. In the context of AUP, configuration
 management (Chapter 22) addresses change management, risk manage
ment, and the control of any persistent work products17 that are produced by
 the team. Project management tracks and controls the progress of the team
 and coordinates team activities.
 • Environment management. Environment management coordinates a process
 infrastructure that includes standards, tools, and other support technology
 available to the team.
 Although the AUP has historical and technical connections to the Unified Modeling
 Language, it is important to note that UML modeling can be using in conjunction
 with any of the agile process models described in Section 3.5.
 SOFTWARE TOOLS
 Agile Development
 Objective: The objective of agile development
 tools is to assist in one or more aspects of agile
 development with an emphasis on facilitating the rapid
 generation of operational software. These tools can also
 be used when prescriptive process models (Chapter 2) are
 applied.
 Mechanics: Tool mechanics vary. In general, agile tool
 sets encompass automated support for project planning,
 use case development and requirements gathering, rapid
 design, code generation, and testing.
 Representative Tools:18
 Note: Because agile development is a hot topic, most
 software tools vendors purport to sell tools that support 
the agile approach. The tools noted here have
 characteristics that make them particularly useful for
 agile projects.
 OnTime, developed by Axosoft (www.axosoft.com),
 provides agile process management support for
 various technical activities within the process.
 Ideogramic UML, developed by Ideogramic
 (www.ideogramic.com) is a UML tool set
 specifically developed for use within an agile 
process.
 Together Tool Set, distributed by Borland
 (www.borland.com), provides a tools suite that
 supports many technical activities within XP and other
 agile processes.
 17 A persistent work product is a model or document or test case produced by the team that will be kept
 for an indeterminate period of time. It will not be discarded once the software increment is
 delivered.
 18 Tools noted here do not represent an endorsement, but rather a sampling of tools in this category.
 In most cases, tool names are trademarked by their respective developers.
91
 CHAPTER 3 AGILE DEVELOPMENT
 3.6 A TOOL SET FOR THE AGILE PROCESS
 The “tool set” that
 supports agile
 processes focuses
 more on people issues
 than it does on
 technology issues.
 Some proponents of the agile philosophy argue that automated software tools (e.g.,
 design tools) should be viewed as a minor supplement to the team’s activities, and
 not at all pivotal to the success of the team. However, Alistair Cockburn [Coc04] sug
gests that tools can have a benefit and that “agile teams stress using tools that per
mit the rapid flow of understanding. Some of those tools are social, starting even at
 the hiring stage. Some tools are technological, helping distributed teams simulate
 being physically present. Many tools are physical, allowing people to manipulate
 them in workshops.”
 Because acquiring the right people (hiring), team collaboration, stakeholder com
munication, and indirect management are key elements in virtually all agile process
 models, Cockburn argues that “tools” that address these issues are critical success
 factors for agility. For example, a hiring “tool” might be the requirement to have a
 prospective team member spend a few hours pair programming with an existing
 member of the team. The “fit” can be assessed immediately.
 Collaborative and communication “tools” are generally low tech and incorporate
 any mechanism (“physical proximity, whiteboards, poster sheets, index cards, and
 sticky notes” [Coc04]) that provides information and coordination among agile de
velopers. Active communication is achieved via the team dynamics (e.g., pair pro
gramming), while passive communication is achieved by “information radiators”
 (e.g., a flat panel display that presents the overall status of different components of
 an increment). Project management tools deemphasize the Gantt chart and replace
 it with earned value charts or “graphs of tests created versus passed . . . other agile
 tools are used to optimize the environment in which the agile team works (e.g., more
 efficient meeting areas), improve the team culture by nurturing social interactions
 (e.g., collocated teams), physical devices (e.g., electronic whiteboards), and process
 enhancement (e.g., pair programming or time-boxing)” [Coc04].
 Are any of these things really tools? They are, if they facilitate the work performed
 by an agile team member and enhance the quality of the end product.
 3.7 SUMMARY
 In a modern economy, market conditions change rapidly, customer and end-user
 needs evolve, and new competitive threats emerge without warning. Practitioners
 must approach software engineering in a manner that allows them to remain agile—
 to define maneuverable, adaptive, lean processes that can accommodate the needs
 of modern business.
 An agile philosophy for software engineering stresses four key issues: the impor
tance of self-organizing teams that have control over the work they perform, com
munication and collaboration between team members and between practitioners
 and their customers, a recognition that change represents an opportunity, and
92
 PART ONE THE SOFTWARE PROCESS
 an emphasis on rapid delivery of software that satisfies the customer. Agile process
 models have been designed to address each of these issues.
 Extreme programming (XP) is the most widely used agile process. Organized as
 four framework activities—planning, design, coding, and testing—XP suggests a
 number of innovative and powerful techniques that allow an agile team to create
 frequent software releases that deliver features and functionality that have been de
scribed and then prioritized by stakeholders.
 Other agile process models also stress human collaboration and team self
organization, but define their own framework activities and select different points of
 emphasis. For example, ASD uses an iterative process that incorporates adaptive
 cycle planning, relatively rigorous requirement gathering methods, and an iterative
 development cycle that incorporates customer focus groups and formal technical re
views as real-time feedback mechanisms. Scrum emphasizes the use of a set of soft
ware process patterns that have proven effective for projects with tight time lines,
 changing requirements, and business criticality. Each process pattern defines a set
 of development tasks and allows the Scrum team to construct a process that is
 adapted to the needs of the project. The Dynamic Systems Development Method
 (DSDM) advocates the use of time-box scheduling and suggests that only enough
 work is required for each software increment to facilitate movement to the next
 increment. Crystal is a family of agile process models that can be adopted to the spe
cific characteristics of a project.
 Feature Driven Development (FDD) is somewhat more “formal” than other agile
 methods, but still maintains agility by focusing the project team on the development
 of features—a client-valued function that can be implemented in two weeks or less.
 Lean Software Development (LSD) has adapted the principles of lean manufacturing
 to the world of software engineering. Agile modeling (AM) suggests that modeling is
 essential for all systems, but that the complexity, type, and size of the model must be
 tuned to the software to be built. The Agile Unified Process (AUP) adopts a “serial in
 the large” and “iterative in the small” philosophy for building software.
 PROBLEMS AND POINTS TO PONDER
 3.1. Reread “The Manifesto for Agile Software Development” at the beginning of this chapter.
 Can you think of a situation in which one or more of the four “values” could get a software team
 into trouble?
 3.2. Describe agility (for software projects) in your own words.
 3.3. Why does an iterative process make it easier to manage change? Is every agile process dis
cussed in this chapter iterative? Is it possible to complete a project in just one iteration and still
 be agile? Explain your answers.
 3.4. Could each of the agile processes be described using the generic framework activities
 noted in Chapter 2? Build a table that maps the generic activities into the activities defined for
 each agile process.
 3.5. Try to come up with one more “agility principle” that would help a software engineering
 team become even more maneuverable.
93
 CHAPTER 3 AGILE DEVELOPMENT
 3.6. Select one agility principle noted in Section 3.3.1 and try to determine whether each of the
 process models presented in this chapter exhibits the principle. [Note: I have presented an
 overview of these process models only, so it may not be possible to determine whether a prin
ciple has been addressed by one or more of the models, unless you do additional research
 (which is not required for this problem).]
 3.7. Why do requirements change so much? After all, don’t people know what they want?
 3.8. Most agile process models recommend face-to-face communication. Yet today, members
 of a software team and their customers may be geographically separated from one another. Do
 you think this implies that geographical separation is something to avoid? Can you think of ways
 to overcome this problem?
 3.9. Write an XP user story that describes the “favorite places” or “bookmarks” feature avail
able on most Web browsers.
 3.10. What is a spike solution in XP?
 3.11. Describe the XP concepts of refactoring and pair programming in your own words.
 3.12. Do a bit more reading and describe what a time-box is. How does this assist an ASD team
 in delivering software increments in a short time period?
 3.13. Do the 80 percent rule in DSDM and the time-boxing approach defined for ASD achieve
 the same result?
 3.14. Using the process pattern template presented in Chapter 2, develop a process pattern for
 any one of the Scrum patterns presented in Section 3.5.2.
 3.15. Why is Crystal called a family of agile methods?
 3.16. Using the FDD feature template described in Section 3.5.5, define a feature set for a Web
 browser. Now develop a set of features for the feature set.
 3.17. Visit the Official Agile Modeling Site and make a complete list of all core and supple
mentary AM principles.
 3.18. The tool set proposed in Section 3.6 supports many of the “soft” aspects of agile meth
ods. Since communication is so important, recommend an actual tool set that might be used to
 enhance communication among stakeholders on an agile team.
 FURTHER READINGS AND INFORMATION SOURCES
 The overall philosophy and underlying principles of agile software development are considered
 in depth in many of the books referenced in the body of this chapter. In addition, books by Shaw
 and Warden (The Art of Agile Development, O’Reilly Media, Inc., 2008), Hunt (Agile Software Con
struction, Springer, 2005), and Carmichael and Haywood (Better Software Faster, Prentice-Hall,
 2002) present useful discussions of the subject. Aguanno (Managing Agile Projects, Multi
Media Publications, 2005), Highsmith (Agile Project Management: Creating Innovative Products,
 Addison-Wesley, 2004), and Larman (Agile and Iterative Development: A Manager’s Guide,
 Addison-Wesley, 2003) present a management overview and consider project management
 issues. Highsmith (Agile Software Development Ecosystems, Addison-Wesley, 2002) presents a
 survey of agile principles, processes, and practices. A worthwhile discussion of the delicate bal
ance between agility and discipline is presented by Booch and his colleagues (Balancing Agility
 and Discipline, Addison-Wesley, 2004).
 Martin (Clean Code: A Handbook of Agile Software Craftsmanship, Prentice-Hall, 2009) pres
ents the principles, patterns, and practices required to develop “clean code” in an agile software
 engineering environment. Leffingwell (Scaling Software Agility: Best Practices for Large Enter
prises, Addison-Wesley, 2007) discusses strategies for scaling up agile practices for large proj
ects. Lippert and Rook (Refactoring in Large Software Projects: Performing Complex Restructurings
 Successfully, Wiley, 2006) discuss the use of refactoring when applied in large, complex systems.
94
 PART ONE THE SOFTWARE PROCESS
 Stamelos and Sfetsos (Agile Software Development Quality Assurance, IGI Global, 2007) discuss
 SQA techniques that conform to the agile philosophy.
 Dozens of books have been written about Extreme Programming over the past decade. Beck
 (Extreme Programming Explained: Embrace Change, 2d ed., Addison-Wesley, 2004) remains the
 definitive treatment of the subject. In addition, Jeffries and his colleagues (Extreme Programming
 Installed, Addison-Wesley, 2000), Succi and Marchesi (Extreme Programming Examined,
 Addison-Wesley, 2001), Newkirk and Martin (Extreme Programming in Practice, Addison-Wesley,
 2001), and Auer and his colleagues (Extreme Programming Applied: Play to Win, Addison-Wesley,
 2001) provide a nuts-and-bolts discussion of XP along with guidance on how best to apply it.
 McBreen (Questioning Extreme Programming, Addison-Wesley, 2003) takes a critical look at XP,
 defining when and where it is appropriate. An in-depth consideration of pair programming is
 presented by McBreen (Pair Programming Illuminated, Addison-Wesley, 2003).
 ASD is addressed in depth by Highsmith [Hig00]. Schwaber (The Enterprise and Scrum,
 Microsoft Press, 2007) discusses the use of Scrum for projects that have a major business
 impact. The nuts and bolts of Scrum are discussed by Schwaber and Beedle (Agile Software
 Development with SCRUM, Prentice-Hall, 2001). Worthwhile treatments of DSDM have been
 written by the DSDM Consortium (DSDM: Business Focused Development, 2d ed., Pearson Edu
cation, 2003) and Stapleton (DSDM: The Method in Practice, Addison-Wesley, 1997). Cockburn
 (Crystal Clear, Addison-Wesley, 2005) presents an excellent overview of the Crystal family of
 processes. Palmer and Felsing [Pal02] present a detailed treatment of FDD. Carmichael and
 Haywood (Better Software Faster, Prentice-Hall, 2002) provides another useful treatment of FDD
 that includes a step-by-step journey through the mechanics of the process. Poppendieck and 
Poppendieck (Lean Development: An Agile Toolkit for Software Development Managers, Addison
Wesley, 2003) provide guidelines for managing and controlling agile projects. Ambler and
 Jeffries (Agile Modeling, Wiley, 2002) discuss AM in some depth.
 A wide variety of information sources on agile software development are available on the
 Internet. An up-to-date list of World Wide Web references that are relevant to the agile process
 can be found at the SEPA website: www.mhhe.com/engcs/compsci/pressman/
 professional/olc/ser.htm.
In 2001, Kent Beck and 16 other noted software developers, writers, and con
sultants [Bec01a] (referred to as the “Agile Alliance”) signed the “Manifesto for
 Agile Software Development.” It stated:
 We are uncovering better ways of developing software by doing it and helping others
 do it. Through this work we have come to value: 
Individuals and interactions over processes and tools
 Working software over comprehensive documentation
 Customer collaboration over contract negotiation
 Responding to change over following a plan
 That is, while there is value in the items on the right, we value the items on the 
left more.
 QUICK
 LOOK
 What is it? Agile software engi
neering combines a philosophy and
 a set of development guidelines. The
 philosophy encourages customer
 satisfaction and early incremental delivery of
 software; small, highly motivated project teams;
 informal methods; minimal software engineer
ing work products; and overall development
 simplicity. The development guidelines stress
 delivery over analysis and design (although
 these activities are not discouraged), and active
 and continuous communication between devel
opers and customers.
 Who does it? Software engineers and other
 project stakeholders (managers, customers, end
 users) work together on an agile team—a team
 that is self-organizing and in control of its own
 destiny. An agile team fosters communication
 and collaboration among all who serve on it.
 Why is it important? The modern business envi
ronment that spawns computer-based systems
 and software products is fast-paced and ever
changing. Agile software engineering repre
sents a reasonable alternative to conventional
 software engineering for certain classes of soft
ware and certain types of software projects. It
 has been demonstrated to deliver successful sys
tems quickly.
 Whatarethesteps? Agiledevelopmentmightbest
 be termed “software engineering lite.” The basic
 framework activities—communication, planning,
 modeling, construction, and deployment—
 remain. But they morph into a minimal task set
 that pushes the project team toward construction
 and delivery (some would argue that this is
 done at the expense of problem analysis and
 solution design).
 What is the work product? Both the customer
 and the software engineer have the same
 view—the only really important work product
 is an operational “software increment” that is
 delivered to the customer on the appropriate
 commitment date.
 How do I ensure that I’ve done it right? If the
 agile team agrees that the process works, and
 the team produces deliverable software
 increments that satisfy the customer, you’ve
 done it right.
 65
66
 PART ONE THE SOFTWARE PROCESS
 FDD . . . . . . . . . .86
 Industrial XP . . .77
 Lean Software
 Development . . .87
 pair 
programming . . .76
 project 
velocity . . . . . . .74
 refactoring . . . . .75
 Scrum . . . . . . . .82
 stories . . . . . . . .74
 XP process . . . . .73
 uote:
 “Agility: 1,
 everything else: 0.”
 Tom DeMarco
 A manifesto is normally associated with an emerging political movement—one
 that attacks the old guard and suggests revolutionary change (hopefully for the
 better). In some ways, that’s exactly what agile development is all about.
 Although the underlying ideas that guide agile development have been with us for
 many years, it has been less than two decades since these ideas have crystallized
 into a “movement.” In essence, agile1 methods were developed in an effort to over
come perceived and actual weaknesses in conventional software engineering. Agile
 development can provide important benefits, but it is not applicable to all projects,
 all products, all people, and all situations. It is also not antithetical to solid software
 engineering practice and can be applied as an overriding philosophy for all software
 work.
 In the modern economy, it is often difficult or impossible to predict how a
 computer-based system (e.g., a Web-based application) will evolve as time passes.
 Market conditions change rapidly, end-user needs evolve, and new competitive
 threats emerge without warning. In many situations, you won’t be able to define
 requirements fully before the project begins. You must be agile enough to respond to
 a fluid business environment.
 Fluidity implies change, and change is expensive. Particularly if it is uncontrolled
 or poorly managed. One of the most compelling characteristics of the agile approach
 is its ability to reduce the costs of change throughout the software process.
 Does this mean that a recognition of challenges posed by modern realities causes
 you to discard valuable software engineering principles, concepts, methods, and
 tools? Absolutely not! Like all engineering disciplines, software engineering contin
ues to evolve. It can be adapted easily to meet the challenges posed by a demand for
 agility.
 In a thought-provoking book on agile software development, Alistair Cockburn
 [Coc02] argues that the prescriptive process models introduced in Chapter 2 have a
 major failing: they forget the frailties of the people who build computer software. Software
 engineers are not robots. They exhibit great variation in working styles; significant dif
ferences in skill level, creativity, orderliness, consistency, and spontaneity. Some com
municate well in written form, others do not. Cockburn argues that process models
 can “deal with people’s common weaknesses with [either] discipline or tolerance” and
 that most prescriptive process models choose discipline. He states: “Because consis
tency in action is a human weakness, high discipline methodologies are fragile.”
 If process models are to work, they must provide a realistic mechanism for en
couraging the discipline that is necessary, or they must be characterized in a man
ner that shows “tolerance” for the people who do software engineering work.
 Invariably, tolerant practices are easier for software people to adopt and sustain, but
 (as Cockburn admits) they may be less productive. Like most things in life, trade-offs
 must be considered.
 1 Agile methods are sometimes referred to as light methods or lean methods.
67
 CHAPTER 3 AGILE DEVELOPMENT
 3.1 WHAT IS AGILITY?
 Just what is agility in the context of software engineering work? Ivar Jacobson
 [Jac02a] provides a useful discussion:
 Agility has become today’s buzzword when describing a modern software process. Every
one is agile. An agile team is a nimble team able to appropriately respond to changes.
 Change is what software development is very much about. Changes in the software be
ing built, changes to the team members, changes because of new technology, changes of
 all kinds that may have an impact on the product they build or the project that creates the
 product. Support for changes should be built-in everything we do in software, something
 we embrace because it is the heart and soul of software. An agile team recognizes that
 software is developed by individuals working in teams and that the skills of these people,
 their ability to collaborate is at the core for the success of the project.
 Don’t make the
 mistake of assuming
 that agility gives you
 license to hack out
 solutions. A process is
 required and discipline
 is essential.
 In Jacobson’s view, the pervasiveness of change is the primary driver for agility. Soft
ware engineers must be quick on their feet if they are to accommodate the rapid
 changes that Jacobson describes.
 But agility is more than an effective response to change. It also encompasses the
 philosophy espoused in the manifesto noted at the beginning of this chapter. It
 encourages team structures and attitudes that make communication (among team
 members, between technologists and business people, between software engineers
 and their managers) more facile. It emphasizes rapid delivery of operational soft
ware and de-emphasizes the importance of intermediate work products (not always
 a good thing); it adopts the customer as a part of the development team and works
 to eliminate the “us and them” attitude that continues to pervade many software
 projects; it recognizes that planning in an uncertain world has its limits and that a
 project plan must be flexible.
 Agility can be applied to any software process. However, to accomplish this, it is
 essential that the process be designed in a way that allows the project team to adapt
 tasks and to streamline them, conduct planning in a way that understands the fluid
ity of an agile development approach, eliminate all but the most essential work prod
ucts and keep them lean, and emphasize an incremental delivery strategy that gets
 working software to the customer as rapidly as feasible for the product type and
 operational environment.
 3.2 AGILITY AND THE COST OF CHANGE
 The conventional wisdom in software development (supported by decades of expe
rience) is that the cost of change increases nonlinearly as a project progresses
 (Figure 3.1, solid black curve). It is relatively easy to accommodate a change when a
 software team is gathering requirements (early in a project). A usage scenario might
 have to be modified, a list of functions may be extended, or a written specification
 can be edited. The costs of doing this work are minimal, and the time required will
68
 PART ONE THE SOFTWARE PROCESS
 FIGURE 3.1
 Change costs
 as a function
 of time in
 development
 uote:
 Development cost
 Cost of change
 using conventional
 software processes
 Cost of change
 using agile processes
 “Agility is dynamic,
 content specific,
 aggressively
 change embracing,
 and growth
 oriented.”
 Idealized cost of change
 using agile process
 Development schedule progress–Steven
 Goldman et al.
 An agile process
 reduces the cost of
 change because
 software is released in
 increments and change
 can be better
 controlled within an
 increment.
 not adversely affect the outcome of the project. But what if we fast-forward a num
ber of months? The team is in the middle of validation testing (something that occurs
 relatively late in the project), and an important stakeholder is requesting a major
 functional change. The change requires a modification to the architectural design of
 the software, the design and construction of three new components, modifications
 to another five components, the design of new tests, and so on. Costs escalate
 quickly, and the time and cost required to ensure that the change is made without
 unintended side effects is nontrivial.
 Proponents of agility (e.g., [Bec00], [Amb04]) argue that a well-designed agile
 process “flattens” the cost of change curve (Figure 3.1, shaded, solid curve), allowing
 a software team to accommodate changes late in a software project without dramatic
 cost and time impact. You’ve already learned that the agile process encompasses in
cremental delivery. When incremental delivery is coupled with other agile practices
 such as continuous unit testing and pair programming (discussed later in this chap
ter), the cost of making a change is attenuated. Although debate about the degree to
 which the cost curve flattens is ongoing, there is evidence [Coc01a] to suggest that a
 significant reduction in the cost of change can be achieved.
 3.3 WHAT IS ANAGILE PROCESS?
 Any agile software process is characterized in a manner that addresses a number of
 key assumptions [Fow02] about the majority of software projects: 
1. It is difficult to predict in advance which software requirements will persist
 and which will change. It is equally difficult to predict how customer
 priorities will change as the project proceeds.
69
 CHAPTER 3 AGILE DEVELOPMENT
 WebRef
 A comprehensive
 collection of articles on
 the agile process 
can be found at
 www.aanpo.org/
 articles/index.
 Although agile
 processes embrace
 change, it is still
 important to examine
 the reasons for
 change.
 Working software is
 important, but don’t
 forget that it must also
 exhibit a variety of
 quality attributes
 including reliability,
 usability, and 
maintainability.
 2. For many types of software, design and construction are interleaved. That is,
 both activities should be performed in tandem so that design models are
 proven as they are created. It is difficult to predict how much design is
 necessary before construction is used to prove the design.
 3. Analysis, design, construction, and testing are not as predictable (from a
 planning point of view) as we might like.
 Given these three assumptions, an important question arises: How do we create a
 process that can manage unpredictability? The answer, as I have already noted, lies
 in process adaptability (to rapidly changing project and technical conditions). An
 agile process, therefore, must be adaptable.
 But continual adaptation without forward progress accomplishes little. Therefore,
 an agile software process must adapt incrementally. To accomplish incremental adap
tation, an agile team requires customer feedback (so that the appropriate adaptations
 can be made). An effective catalyst for customer feedback is an operational prototype
 or a portion of an operational system. Hence, an incremental development strategy
 should be instituted. Software increments (executable prototypes or portions of an op
erational system) must be delivered in short time periods so that adaptation keeps pace
 with change (unpredictability). This iterative approach enables the customer to evalu
ate the software increment regularly, provide necessary feedback to the software team,
 and influence the process adaptations that are made to accommodate the feedback.
 3.3.1 Agility Principles
 The Agile Alliance (see [Agi03], [Fow01]) defines 12 agility principles for those who
 want to achieve agility: 
1. Our highest priority is to satisfy the customer through early and continuous
 delivery of valuable software.
 2. Welcome changing requirements, even late in development. Agile processes
 harness change for the customer’s competitive advantage.
 3. Deliver working software frequently, from a couple of weeks to a couple of
 months, with a preference to the shorter timescale.
 4. Business people and developers must work together daily throughout the
 project.
 5. Build projects around motivated individuals. Give them the environment and
 support they need, and trust them to get the job done.
 6. The most efficient and effective method of conveying information to and
 within a development team is face-to-face conversation.
 7. Working software is the primary measure of progress.
 8. Agile processes promote sustainable development. The sponsors, developers,
 and users should be able to maintain a constant pace indefinitely.
70
 PART ONE THE SOFTWARE PROCESS
 9. Continuous attention to technical excellence and good design enhances
 agility.
 10. Simplicity—the art of maximizing the amount of work not done—is 
essential.
 11. The best architectures, requirements, and designs emerge from self
organizing teams.
 12. At regular intervals, the team reflects on how to become more effective, then
 tunes and adjusts its behavior accordingly.
 Not every agile process model applies these 12 principles with equal weight, and
 some models choose to ignore (or at least downplay) the importance of one or more
 of the principles. However, the principles define an agile spirit that is maintained in
 each of the process models presented in this chapter.
 3.3.2 The Politics of Agile Development
 You don’t have to
 choose between agility
 and software engi
neering. Rather, define
 a software engineering
 approach that is agile.
 There is considerable debate (sometimes strident) about the benefits and applicabil
ity of agile software development as opposed to more conventional software engi
neering processes. Jim Highsmith [Hig02a] (facetiously) states the extremes when he
 characterizes the feeling of the pro-agility camp (“agilists”). “Traditional methodolo
gists are a bunch of stick-in-the-muds who’d rather produce flawless documentation
 than a working system that meets business needs.” As a counterpoint, he states
 (again, facetiously) the position of the traditional software engineering camp: “Light
weight, er, ‘agile’ methodologists are a bunch of glorified hackers who are going to
 be in for a heck of a surprise when they try to scale up their toys into enterprise-wide
 software.”
 Like all software technology arguments, this methodology debate risks degener
ating into a religious war. If warfare breaks out, rational thought disappears and
 beliefs rather than facts guide decision making.
 No one is against agility. The real question is: What is the best way to achieve it?
 As important, how do you build software that meets customers’ needs today and
 exhibits the quality characteristics that will enable it to be extended and scaled to
 meet customers’ needs over the long term?
 There are no absolute answers to either of these questions. Even within the agile
 school itself, there are many proposed process models (Section 3.4), each with a
 subtly different approach to the agility problem. Within each model there is a set of
 “ideas” (agilists are loath to call them “work tasks”) that represent a significant
 departure from traditional software engineering. And yet, many agile concepts are
 simply adaptations of good software engineering concepts. Bottom line: there is
 much that can be gained by considering the best of both schools and virtually
 nothing to be gained by denigrating either approach.
 If you have further interest, see [Hig01], [Hig02a], and [DeM02] for an entertain
ing summary of other important technical and political issues.
71
 CHAPTER 3 AGILE DEVELOPMENT
 uote:
 “Agile methods
 derive much of
 their agility by
 relying on the
 tacit knowledge
 embodied in the
 team, rather than
 writing the
 knowledge down
 in plans.”
 Barry Boehm
 ?
 What key
 traits must
 exist among the
 people on an
 effective software
 team?
 uote:
 “What counts as
 barely sufficient
 for one team is
 either overly
 sufficient or
 insufficient for
 another.”
 Alistair
 Cockburn
 3.3.3 Human Factors
 Proponents of agile software development take great pains to emphasize the impor
tance of “people factors.” As Cockburn and Highsmith [Coc01a] state, “Agile devel
opment focuses on the talents and skills of individuals, molding the process to
 specific people and teams.” The key point in this statement is that the process molds
 to the needs of the people and team, not the other way around.2
 If members of the software team are to drive the characteristics of the process that
 is applied to build software, a number of key traits must exist among the people on
 an agile team and the team itself:
 Competence. In an agile development (as well as software engineering)
 context, “competence” encompasses innate talent, specific software-related
 skills, and overall knowledge of the process that the team has chosen to
 apply. Skill and knowledge of process can and should be taught to all people
 who serve as agile team members.
 Common focus. Although members of the agile team may perform differ
ent tasks and bring different skills to the project, all should be focused on one
 goal—to deliver a working software increment to the customer within the
 time promised. To achieve this goal, the team will also focus on continual
 adaptations (small and large) that will make the process fit the needs of the
 team.
 Collaboration. Software engineering (regardless of process) is about as
sessing, analyzing, and using information that is communicated to the soft
ware team; creating information that will help all stakeholders understand
 the work of the team; and building information (computer software and rele
vant databases) that provides business value for the customer. To accomplish
 these tasks, team members must collaborate—with one another and all other
 stakeholders.
 Decision-making ability. Any good software team (including agile teams)
 must be allowed the freedom to control its own destiny. This implies that the
 team is given autonomy—decision-making authority for both technical and
 project issues.
 Fuzzy problem-solving ability. Software managers must recognize that
 the agile team will continually have to deal with ambiguity and will continu
ally be buffeted by change. In some cases, the team must accept the fact that
 the problem they are solving today may not be the problem that needs to be
 solved tomorrow. However, lessons learned from any problem-solving
 2 Successful software engineering organizations recognize this reality regardless of the process
 model they choose.
72
 PART ONE THE SOFTWARE PROCESS
 A self-organizing team
 is in control of the
 work it performs. The
 team makes its own
 commitments and
 defines plans to
 achieve them.
 activity (including those that solve the wrong problem) may be of benefit to
 the team later in the project.
 Mutual trust and respect. The agile team must become what DeMarco
 and Lister [DeM98] call a “jelled” team (Chapter 24). A jelled team exhibits
 the trust and respect that are necessary to make them “so strongly knit that
 the whole is greater than the sum of the parts.” [DeM98]
 Self-organization. In the context of agile development, self-organization
 implies three things: (1) the agile team organizes itself for the work to be
 done, (2) the team organizes the process to best accommodate its local envi
ronment, (3) the team organizes the work schedule to best achieve delivery
 of the software increment. Self-organization has a number of technical bene
fits, but more importantly, it serves to improve collaboration and boost team
 morale. In essence, the team serves as its own management. Ken Schwaber
 [Sch02] addresses these issues when he writes: “The team selects how much
 work it believes it can perform within the iteration, and the team commits to
 the work. Nothing demotivates a team as much as someone else making
 commitments for it. Nothing motivates a team as much as accepting the
 responsibility for fulfilling commitments that it made itself.”
 3.4 EXTREME PROGRAMMING (XP)
 In order to illustrate an agile process in a bit more detail, I’ll provide you with an
 overview of Extreme Programming (XP), the most widely used approach to agile soft
ware development. Although early work on the ideas and methods associated with
 XP occurred during the late 1980s, the seminal work on the subject has been written
 by Kent Beck [Bec04a]. More recently, a variant of XP, called Industrial XP (IXP) has
 been proposed [Ker05]. IXP refines XP and targets the agile process specifically for
 use within large organizations.
 3.4.1 XP Values
 Beck [Bec04a] defines a set of five values that establish a foundation for all work per
formed as part of XP—communication, simplicity, feedback, courage, and respect. Each
 of these values is used as a driver for specific XP activities, actions, and tasks.
 In order to achieve effective communication between software engineers and
 other stakeholders (e.g., to establish required features and functions for the soft
ware), XP emphasizes close, yet informal (verbal) collaboration between customers
 and developers, the establishment of effective metaphors3 for communicating
 important concepts, continuous feedback, and the avoidance of voluminous docu
mentation as a communication medium.
 3 In the XP context, a metaphor is “a story that everyone—customers, programmers, and managers—
 can tell about how the system works” [Bec04a].
73
 CHAPTER 3 AGILE DEVELOPMENT
 Keep it simple
 whenever you can, but
 recognize that
 continual “refactoring”
 can absorb significant
 time and resources.
 uote:
 “XP is the answer
 to the question,
 ‘How little can we
 do and still build
 great software?’“
 Anonymous
 WebRef
 An excellent overview
 of “rules” for XP can
 be found at www
 .extremeprogramm
 ing.org/rules.html.
 To achieve simplicity, XP restricts developers to design only for immediate needs,
 rather than consider future needs. The intent is to create a simple design that can be
 easily implemented in code). If the design must be improved, it can be refactored4 at
 a later time.
 Feedback is derived from three sources: the implemented software itself, the
 customer, and other software team members. By designing and implementing an
 effective testing strategy (Chapters 17 through 20), the software (via test results) pro
vides the agile team with feedback. XP makes use of the unit test as its primary test
ing tactic. As each class is developed, the team develops a unit test to exercise each
 operation according to its specified functionality. As an increment is delivered to a
 customer, the user stories or use cases (Chapter 5) that are implemented by the
 increment are used as a basis for acceptance tests. The degree to which the software
 implements the output, function, and behavior of the use case is a form of feedback.
 Finally, as new requirements are derived as part of iterative planning, the team pro
vides the customer with rapid feedback regarding cost and schedule impact.
 Beck [Bec04a] argues that strict adherence to certain XP practices demands
 courage. A better word might be discipline. For example, there is often significant
 pressure to design for future requirements. Most software teams succumb, arguing
 that “designing for tomorrow” will save time and effort in the long run. An agile XP
 team must have the discipline (courage) to design for today, recognizing that future
 requirements may change dramatically, thereby demanding substantial rework of
 the design and implemented code.
 By following each of these values, the agile team inculcates respect among it
 members, between other stakeholders and team members, and indirectly, for the
 software itself. As they achieve successful delivery of software increments, the team
 develops growing respect for the XP process.
 3.4.2 The XP Process
 Extreme Programming uses an object-oriented approach (Appendix 2) as its pre
ferred development paradigm and encompasses a set of rules and practices that
 occur within the context of four framework activities: planning, design, coding, and
 testing. Figure 3.2 illustrates the XP process and notes some of the key ideas and
 tasks that are associated with each framework activity. Key XP activities are sum
marized in the paragraphs that follow.
 Planning. The planning activity (also called the planning game) begins with
 listening—a requirements gathering activity that enables the technical members of
 the XP team to understand the business context for the software and to get a broad
 4 Refactoring allows a software engineer to improve the internal structure of a design (or source
 code) without changing its external functionality or behavior. In essence, refactoring can be used
 to improve the efficiency, readability, or performance of a design or the code that implements a
 design.
74
 PART ONE THE SOFTWARE PROCESS
 FIGURE 3.2
 The Extreme
 Programming
 process
 ?
 What is an
 XP “story”?
 WebRef
 A worthwhile XP
 “planning game” can
 be found at:
 c2.com/cgi/
 wiki?planningGame.
 simple design
 CRC cards
 user stories
 values
 acceptance test criteria
 iteration plan
 Release
 spike solutions
 prototypes
 refactoring
 design
 pair programming
 planning
 software increment
 project velocity computed
 unit test
 continuous integration
 acceptance testing
 test
 coding
 feel for required output and major features and functionality. Listening leads to the
 creation of a set of “stories” (also called user stories) that describe required output,
 features, and functionality for software to be built. Each story (similar to use cases
 described in Chapter 5) is written by the customer and is placed on an index card.
 The customer assigns a value (i.e., a priority) to the story based on the overall busi
ness value of the feature or function.5 Members of the XP team then assess each
 story and assign a cost—measured in development weeks—to it. If the story is esti
mated to require more than three development weeks, the customer is asked to split
 the story into smaller stories and the assignment of value and cost occurs again. It
 is important to note that new stories can be written at any time.
 Customers and developers work together to decide how to group stories into the
 next release (the next software increment) to be developed by the XP team. Once a
 basic commitment (agreement on stories to be included, delivery date, and other
 project matters) is made for a release, the XP team orders the stories that will be de
veloped in one of three ways: (1) all stories will be implemented immediately (within
 a few weeks), (2) the stories with highest value will be moved up in the schedule and
 implemented first, or (3) the riskiest stories will be moved up in the schedule and
 implemented first.
 After the first project release (also called a software increment) has been deliv
ered, the XP team computes project velocity. Stated simply, project velocity is the
 5 The value of a story may also be dependent on the presence of another story.
75
 CHAPTER 3 AGILE DEVELOPMENT
 Project velocity is a
 subtle measure of
 team productivity.
 XP deemphasizes the
 importance of design.
 Not everyone agrees.
 In fact, there are times
 when design should be
 emphasized.
 WebRef
 Refactoring techniques
 and tools can be
 found at:
 www.refactoring
 .com.
 number of customer stories implemented during the first release. Project velocity can
 then be used to (1) help estimate delivery dates and schedule for subsequent releases
 and (2) determine whether an overcommitment has been made for all stories across
 the entire development project. If an overcommitment occurs, the content of releases
 is modified or end delivery dates are changed.
 As development work proceeds, the customer can add stories, change the value
 of an existing story, split stories, or eliminate them. The XP team then reconsiders all
 remaining releases and modifies its plans accordingly.
 Design. XP design rigorously follows the KIS (keep it simple) principle. A simple
 design is always preferred over a more complex representation. In addition, the de
sign provides implementation guidance for a story as it is written—nothing less,
 nothing more. The design of extra functionality (because the developer assumes it
 will be required later) is discouraged.6
 XP encourages the use of CRC cards (Chapter 7) as an effective mechanism for
 thinking about the software in an object-oriented context. CRC (class-responsibility
collaborator) cards identify and organize the object-oriented classes7 that are rele
vant to the current software increment. The XP team conducts the design exercise
 using a process similar to the one described in Chapter 8. The CRC cards are the only
 design work product produced as part of the XP process.
 If a difficult design problem is encountered as part of the design of a story, XP rec
ommends the immediate creation of an operational prototype of that portion of the
 design. Called a spike solution, the design prototype is implemented and evaluated.
 The intent is to lower risk when true implementation starts and to validate the orig
inal estimates for the story containing the design problem.
 In the preceding section, we noted that XP encourages refactoring—a construction
 technique that is also a method for design optimization. Fowler [Fow00] describes
 refactoring in the following manner:
 Refactoring is the process of changing a software system in such a way that it does not
 alter the external behavior of the code yet improves the internal structure. It is a disci
plined way to clean up code [and modify/simplify the internal design] that minimizes the
 chances of introducing bugs. In essence, when you refactor you are improving the design
 of the code after it has been written.
 Because XP design uses virtually no notation and produces few, if any, work prod
ucts other than CRC cards and spike solutions, design is viewed as a transient arti
fact that can and should be continually modified as construction proceeds. The intent
 of refactoring is to control these modifications by suggesting small design changes
 6 These design guidelines should be followed in every software engineering method, although there
 are times when sophisticated design notation and terminology may get in the way of simplicity.
 7 Object-oriented classes are discussed in Appendix 2, in Chapter 8, and throughout Part 2 of this
 book.
76
 PART ONE THE SOFTWARE PROCESS
 Refactoring improves
 the internal structure of
 a design (or source
 code) without
 changing its external
 functionality or
 behavior.
 WebRef
 Useful information on
 XP can be obtained 
at www
 .xprogramming.
 com.
 ?
 What is 
pair
 programming?
 Many software teams
 are populated by indi
vidualists. You’ll have
 to work to change that
 culture if pair program
ming is to work effec
tively.
 ?
 XP?
 How are unit
 tests used in
 that “can radically improve the design” [Fow00]. It should be noted, however, that
 the effort required for refactoring can grow dramatically as the size of an application
 grows.
 A central notion in XP is that design occurs both before and after coding com
mences. Refactoring means that design occurs continuously as the system is con
structed. In fact, the construction activity itself will provide the XP team with
 guidance on how to improve the design.
 Coding. After stories are developed and preliminary design work is done, the team
 does not move to code, but rather develops a series of unit tests that will exercise
 each of the stories that is to be included in the current release (software increment).8
 Once the unit test9 has been created, the developer is better able to focus on what
 must be implemented to pass the test. Nothing extraneous is added (KIS). Once the
 code is complete, it can be unit-tested immediately, thereby providing instantaneous
 feedback to the developers.
 A key concept during the coding activity (and one of the most talked about aspects
 of XP) is pair programming. XP recommends that two people work together at one
 computer workstation to create code for a story. This provides a mechanism for real
time problem solving (two heads are often better than one) and real-time quality as
surance (the code is reviewed as it is created). It also keeps the developers focused
 on the problem at hand. In practice, each person takes on a slightly different role. For
 example, one person might think about the coding details of a particular portion of
 the design while the other ensures that coding standards (a required part of XP) are
 being followed or that the code for the story will satisfy the unit test that has been
 developed to validate the code against the story.
 As pair programmers complete their work, the code they develop is integrated
 with the work of others. In some cases this is performed on a daily basis by an inte
gration team. In other cases, the pair programmers have integration responsibility.
 This “continuous integration” strategy helps to avoid compatibility and interfacing
 problems and provides a “smoke testing” environment (Chapter 17) that helps to
 uncover errors early.
 Testing. I have already noted that the creation of unit tests before coding com
mences is a key element of the XP approach. The unit tests that are created should
 be implemented using a framework that enables them to be automated (hence, they
 can be executed easily and repeatedly). This encourages a regression testing strat
egy (Chapter 17) whenever code is modified (which is often, given the XP refactor
ing philosophy).
 8 This approach is analogous to knowing the exam questions before you begin to study. It makes
 studying much easier by focusing attention only on the questions that will be asked.
 9 Unit testing, discussed in detail in Chapter 17, focuses on an individual software component, exer
cising the component’s interface, data structures, and functionality in an effort to uncover errors
 that are local to the component.
77
 CHAPTER 3 AGILE DEVELOPMENT
 XP acceptance tests
 are derived from user
 stories.
 ?
 What new
 practices are
 appended to XP
 to create IXP?
 uote:
 “Ability is what
 you’re capable of
 doing. Motivation
 determines what
 you do. Attitude
 determines how
 well you do it.”
 Lou Holtz
 As the individual unit tests are organized into a “universal testing suite” [Wel99],
 integration and validation testing of the system can occur on a daily basis. This pro
vides the XP team with a continual indication of progress and also can raise warn
ing flags early if things go awry. Wells [Wel99] states: “Fixing small problems every
 few hours takes less time than fixing huge problems just before the deadline.”
 XP acceptance tests, also called customer tests, are specified by the customer and
 focus on overall system features and functionality that are visible and reviewable by
 the customer. Acceptance tests are derived from user stories that have been imple
mented as part of a software release.
 3.4.3 Industrial XP
 Joshua Kerievsky [Ker05] describes Industrial Extreme Programming (IXP) in the fol
lowing manner: “IXP is an organic evolution of XP. It is imbued with XP’s minimal
ist, customer-centric, test-driven spirit. IXP differs most from the original XP in its
 greater inclusion of management, its expanded role for customers, and its upgraded
 technical practices.” IXP incorporates six new practices that are designed to help
 ensure that an XP project works successfully for significant projects within a large
 organization.
 Readiness assessment. Prior to the initiation of an IXP project, the organ
ization should conduct a readiness assessment. The assessment ascertains
 whether (1) an appropriate development environment exists to support IXP,
 (2) the team will be populated by the proper set of stakeholders, (3) the or
ganization has a distinct quality program and supports continuous improve
ment, (4) the organizational culture will support the new values of an agile
 team, and (5) the broader project community will be populated appropriately.
 Project community. Classic XP suggests that the right people be used to
 populate the agile team to ensure success. The implication is that people on
 the team must be well-trained, adaptable and skilled, and have the proper
 temperament to contribute to a self-organizing team. When XP is to be
 applied for a significant project in a large organization, the concept of the
 “team” should morph into that of a community. A community may have a
 technologist and customers who are central to the success of a project as
 well as many other stakeholders (e.g., legal staff, quality auditors, manufac
turing or sales types) who “are often at the periphery of an IXP project yet
 they may play important roles on the project” [Ker05]. In IXP, the community
 members and their roles should be explicitly defined and mechanisms for
 communication and coordination between community members should be
 established.
 Project chartering. The IXP team assesses the project itself to determine
 whether an appropriate business justification for the project exists and
 whether the project will further the overall goals and objectives of the
78
 PART ONE THE SOFTWARE PROCESS
 organization. Chartering also examines the context of the project to deter
mine how it complements, extends, or replaces existing systems or
 processes.
 Test-driven management. An IXP project requires measurable criteria for
 assessing the state of the project and the progress that has been made to
 date. Test-driven management establishes a series of measurable “destina
tions” [Ker05] and then defines mechanisms for determining whether or not
 these destinations have been reached.
 Retrospectives. An IXP team conducts a specialized technical review
 (Chapter 15) after a software increment is delivered. Called a retrospective,
 the review examines “issues, events, and lessons-learned” [Ker05] across a
 software increment and/or the entire software release. The intent is to
 improve the IXP process.
 Continuous learning. Because learning is a vital part of continuous
 process improvement, members of the XP team are encouraged (and possi
bly, incented) to learn new methods and techniques that can lead to a higher
quality product.
 In addition to the six new practices discussed, IXP modifies a number of existing
 XP practices. Story-driven development (SDD) insists that stories for acceptance tests
 be written before a single line of code is generated. Domain-driven design (DDD) is
 an improvement on the “system metaphor” concept used in XP. DDD [Eva03] sug
gests the evolutionary creation of a domain model that “accurately represents how
 domain experts think about their subject” [Ker05]. Pairing extends the XP pair
programming concept to include managers and other stakeholders. The intent is to
 improve knowledge sharing among XP team members who may not be directly in
volved in technical development. Iterative usability discourages front-loaded inter
face design in favor of usability design that evolves as software increments are
 delivered and users’ interaction with the software is studied.
 IXP makes smaller modifications to other XP practices and redefines certain roles
 and responsibilities to make them more amenable to significant projects for large
 organizations. For further discussion of IXP, visit http://industrialxp.org.
 3.4.4 The XP Debate
 All new process models and methods spur worthwhile discussion and in some in
stances heated debate. Extreme Programming has done both. In an interesting book
 that examines the efficacy of XP, Stephens and Rosenberg [Ste03] argue that many
 XP practices are worthwhile, but others have been overhyped, and a few are prob
lematic. The authors suggest that the codependent nature of XP practices are both
 its strength and its weakness. Because many organizations adopt only a subset of XP
 practices, they weaken the efficacy of the entire process. Proponents counter that
 XP is continuously evolving and that many of the issues raised by critics have been
79
 CHAPTER 3 AGILE DEVELOPMENT
 addressed as XP practice matures. Among the issues that continue to trouble some
 critics of XP are:10
 ?
 What are
 some of the
 issues that lead to
 an XP debate?
 • Requirements volatility. Because the customer is an active member of the XP
 team, changes to requirements are requested informally. As a consequence,
 the scope of the project can change and earlier work may have to be
 modified to accommodate current needs. Proponents argue that this happens
 regardless of the process that is applied and that XP provides mechanisms for
 controlling scope creep.
 • Conflicting customer needs. Many projects have multiple customers, each with
 his own set of needs. In XP, the team itself is tasked with assimilating the
 needs of different customers, a job that may be beyond their scope of
 authority.
 • Requirements are expressed informally. User stories and acceptance tests are
 the only explicit manifestation of requirements in XP. Critics argue that a
 more formal model or specification is often needed to ensure that omissions,
 inconsistencies, and errors are uncovered before the system is built. Propo
nents counter that the changing nature of requirements makes such models
 and specification obsolete almost as soon as they are developed.
 • Lack of formal design. XP deemphasizes the need for architectural design and
 in many instances, suggests that design of all kinds should be relatively
 informal. Critics argue that when complex systems are built, design must be
 emphasized to ensure that the overall structure of the software will exhibit
 quality and maintainability. XP proponents suggest that the incremental
 nature of the XP process limits complexity (simplicity is a core value) and
 therefore reduces the need for extensive design.
 You should note that every software process has flaws and that many software or
ganizations have used XP successfully. The key is to recognize where a process may
 have weaknesses and to adapt it to the specific needs of your organization.
 SAFEHOME
 Considering Agile Software Development
 The scene: Doug Miller’s office.
 The Players: Doug Miller, software engineering
 manager; Jamie Lazar, software team member; Vinod
 Raman, software team member.
 The conversation:
 (A knock on the door, Jamie and Vinod enter Doug’s office)
 Jamie: Doug, you got a minute?
 10 For a detailed look at some thoughtful criticism that has been leveled at XP, visit
 www.softwarereality.com/ExtremeProgramming.jsp.
3.5 OTHERAGILEPROCESSMODELS
 The history of software engineering is littered with dozens of obsolete process
 descriptions and methodologies, modeling methods and notations, tools, and
 technology. Each flared in notoriety and was then eclipsed by something new and
 (purportedly) better. With the introduction of a wide array of agile process models—
 each contending for acceptance within the software development community—the
 agile movement is following the same historical path.11
 As I noted in the last section, the most widely used of all agile process models
 isExtreme Programming (XP). But many other agile process models have been
 proposed and are in use across the industry. Among the most common are:
 •Adaptive Software Development (ASD)
 •Scrum
 •Dynamic Systems Development Method (DSDM)
 80 PART ONE THE SOFTWARE PROCESS
 Doug: Sure Jamie, what’s up?
 Jamie:We’ve been thinking about our process
 discussion yesterday . . . you know, what process we’re
 going to choose for this new SafeHomeproject.
 Doug:And?
 Vinod: I was talking to a friend at another company,
 and he was telling me about Extreme Programming. It’s
 an agile process model . . . heard of it?
 Doug: Yeah, some good, some bad.
 Jamie:Well, it sounds pretty good to us. Lets you
 develop software really fast, uses something called pair
 programming to do real-time quality checks . . . it’s pretty
 cool, I think.
 Doug: It does have a lot of really good ideas. I like the
 pair-programming concept, for instance, and the idea
 that stakeholders should be part of the team.
 Jamie:Huh? You mean that marketing will work on the
 project team with us?
 Doug (nodding): They’re a stakeholder, aren’t they?
 Jamie: Jeez . . . they’ll be requesting changes every five
 minutes.
 Vinod:Not necessarily. My friend said that there are
 ways to “embrace” changes during an XP project.
 Doug: So you guys think we should use XP?
 Jamie: It’s definitely worth considering.
 Doug: I agree. And even if we choose an incremental
 model as our approach, there’s no reason why we can’t
 incorporate much of what XP has to offer.
 Vinod:Doug, before you said “some good, some bad.”
 What was the “bad”?
 Doug: The thing I don’t like is the way XP downplays
 analysis and design . . . sort of says that writing code is
 where the action is . . . 
(The team members look at one another and smile.)
 Doug: So you agree with the XP approach?
 Jamie (speaking for both):Writing code is what
 we do, Boss!
 Doug (laughing): True, but I’d like to see you spend a
 little less time coding and then recoding and a little more
 time analyzing what has to be done and designing a
 solution that works.
 Vinod:Maybe we can have it both ways, agility with a
 little discipline.
 Doug: I think we can, Vinod. In fact, I’m sure of it.
 uote:
 “Our profession
 goes through
 methodologies like
 a 14-year-old goes
 through clothing.”
 Stephen
 Hawrysh and
 JimRuprecht
 11This is not a bad thing. Before one or more models or methods are accepted as a de facto standard,
 all must contend for the hearts and minds of software engineers. The “winners” evolve into best
 practice, while the “losers” either disappear or merge with the winning models.
81
 CHAPTER 3 AGILE DEVELOPMENT
 • Crystal
 • Feature Drive Development (FDD)
 • Lean Software Development (LSD)
 • Agile Modeling (AM)
 • Agile Unified Process (AUP)
 In the sections that follow, I present a very brief overview of each of these agile
 process models. It is important to note that all agile process models conform (to a
 greater or lesser degree) to the Manifesto for Agile Software Development and the prin
ciples noted in Section 3.3.1. For additional detail, refer to the references noted in
 each subsection or for a survey, examine the “agile software development” entry
 in Wikipedia.12
 3.5.1 Adaptive Software Development (ASD)
 WebRef
 Useful resources for
 ASD can be found at
 www.adaptivesd
 .com.
 Adaptive Software Development (ASD) has been proposed by Jim Highsmith [Hig00] as
 a technique for building complex software and systems. The philosophical under
pinnings of ASD focus on human collaboration and team self-organization.
 Highsmith argues that an agile, adaptive development approach based on collab
oration is “as much a source of order in our complex interactions as discipline and
 engineering.” He defines an ASD “life cycle” (Figure 3.3) that incorporates three
 phases, speculation, collaboration, and learning.
 FIGURE 3.3
 Adaptive
 software
 development
 adaptive cycle planning
 mission statement
 project constraints
 basic requirements
 time-boxed release plan
 Release
 Requirements gathering
 JAD
 mini-specs
 speculation
 software increment
 adjustments for subsequent cycles
 collaboration
 components implemented/tested
 focus groups for feedback
 formal technical reviews
 learning
 postmortems
 12 See http://en.wikipedia.org/wiki/Agile_software_development#Agile_methods.
82
 PART ONE THE SOFTWARE PROCESS
 Effective collaboration
 with your customer will
 only occur if you
 jettison any “us and
 them” attitudes.
 ASD emphasizes
 learning as a key
 element in achieving 
a “self-organizing”
 team.
 WebRef
 Useful Scrum
 information and
 resources can be found
 at www
 .controlchaos.com.
 During speculation, the project is initiated and adaptive cycle planning is con
ducted. Adaptive cycle planning uses project initiation information—the customer’s
 mission statement, project constraints (e.g., delivery dates or user descriptions), and
 basic requirements—to define the set of release cycles (software increments) that
 will be required for the project.
 No matter how complete and farsighted the cycle plan, it will invariably change.
 Based on information obtained at the completion of the first cycle, the plan is re
viewed and adjusted so that planned work better fits the reality in which an ASD
 team is working.
 Motivated people use collaboration in a way that multiplies their talent and cre
ative output beyond their absolute numbers. This approach is a recurring theme in
 all agile methods. But collaboration is not easy. It encompasses communication and
 teamwork, but it also emphasizes individualism, because individual creativity plays
 an important role in collaborative thinking. It is, above all, a matter of trust. People
 working together must trust one another to (1) criticize without animosity, (2) assist
 without resentment, (3) work as hard as or harder than they do, (4) have the skill set
 to contribute to the work at hand, and (5) communicate problems or concerns in a
 way that leads to effective action.
 As members of an ASD team begin to develop the components that are part of an
 adaptive cycle, the emphasis is on “learning” as much as it is on progress toward
 a completed cycle. In fact, Highsmith [Hig00] argues that software developers often
 overestimate their own understanding (of the technology, the process, and the proj
ect) and that learning will help them to improve their level of real understanding.
 ASD teams learn in three ways: focus groups (Chapter 5), technical reviews (Chap
ter 14), and project postmortems.
 The ASD philosophy has merit regardless of the process model that is used. ASD’s
 overall emphasis on the dynamics of self-organizing teams, interpersonal collabo
ration, and individual and team learning yield software project teams that have a
 much higher likelihood of success.
 3.5.2 Scrum
 Scrum (the name is derived from an activity that occurs during a rugby match13) is
 an agile software development method that was conceived by Jeff Sutherland and his
 development team in the early 1990s. In recent years, further development on the
 Scrum methods has been performed by Schwaber and Beedle [Sch01a].
 Scrum principles are consistent with the agile manifesto and are used to guide
 development activities within a process that incorporates the following framework
 activities: requirements, analysis, design, evolution, and delivery. Within each
 13 A group of players forms around the ball and the teammates work together (sometimes violently!)
 to move the ball downfield.
every 24
 hours
 30 days
 Scrum: 15 minute daily meeting.
 Team members respond to basics:
 1) What did you do since last Scrum
 meeting?
 2) Do you have any obstacles?
 3) What will you do before next
 meeting?
 Sprint Backlog:
 Feature(s)
 assigned
 to sprint
 Product Backlog:
 Prioritized product features desired by the customer
 Backlog
 items
 expanded
 by team
 New functionality
 is demonstrated
 at end of sprint
 framework activity, work tasks occur within a process pattern (discussed in the fol
lowing paragraph) called a sprint.The work conducted within a sprint (the number
 of sprints required for each framework activity will vary depending on product com
plexity and size) is adapted to the problem at hand and is defined and often modified
 in real time by the Scrum team. The overall flow of the Scrum process is illustrated
 in Figure 3.4.
 Scrum emphasizes the use of a set of software process patterns [Noy02] that have
 proven effective for projects with tight timelines, changing requirements, and business
 criticality. Each of these process patterns defines a set of development actions:
 Backlog—a prioritized list of project requirements or features that provide busi
ness value for the customer. Items can be added to the backlog at any time (this is
 how changes are introduced). The product manager assesses the backlog and
 updates priorities as required.
 Sprints—consist of work units that are required to achieve a requirement de
fined in the backlog that must be fit into a predefined time-box14(typically 30 days).
 CHAPTER 3 AGILE DEVELOPMENT 83
 14A time-boxis a project management term (see Part 4 of this book) that indicates a period of time
 that has been allocated to accomplish some task.
 FIGURE3.4
 Scrum process
 flow
 Scrum incorporates a
 set of process patterns
 that emphasize project
 priorities,
 compartmentalized
 work units,
 communication, and
 frequent customer
 feedback.
84
 PART ONE THE SOFTWARE PROCESS
 Changes (e.g., backlog work items) are not introduced during the sprint. Hence, the
 sprint allows team members to work in a short-term, but stable environment.
 Scrum meetings—are short (typically 15 minutes) meetings held daily by the Scrum
 team. Three key questions are asked and answered by all team members [Noy02]:
 • What did you do since the last team meeting?
 • What obstacles are you encountering?
 • What do you plan to accomplish by the next team meeting?
 A team leader, called a Scrum master, leads the meeting and assesses the responses
 from each person. The Scrum meeting helps the team to uncover potential problems
 as early as possible. Also, these daily meetings lead to “knowledge socialization”
 [Bee99] and thereby promote a self-organizing team structure.
 Demos—deliver the software increment to the customer so that functionality that
 has been implemented can be demonstrated and evaluated by the customer. It is im
portant to note that the demo may not contain all planned functionality, but rather
 those functions that can be delivered within the time-box that was established.
 Beedle and his colleagues [Bee99] present a comprehensive discussion of these pat
terns in which they state: “Scrum assumes up-front the existence of chaos. . . . ” The
 Scrum process patterns enable a software team to work successfully in a world
 where the elimination of uncertainty is impossible.
 3.5.3 Dynamic Systems Development Method (DSDM)
 WebRef
 Useful resources for
 DSSD can be found at
 www.dsdm.org.
 The Dynamic Systems Development Method (DSDM) [Sta97] is an agile software devel
opment approach that “provides a framework for building and maintaining systems
 which meet tight time constraints through the use of incremental prototyping in a con
trolled project environment” [CCS02]. The DSDM philosophy is borrowed from a mod
ified version of the Pareto principle—80 percent of an application can be delivered in
 20 percent of the time it would take to deliver the complete (100 percent) application.
 DSDM is an iterative software process in which each iteration follows the 80 per
cent rule. That is, only enough work is required for each increment to facilitate
 movement to the next increment. The remaining detail can be completed later when
 more business requirements are known or changes have been requested and
 accommodated.
 The DSDM Consortium (www.dsdm.org) is a worldwide group of member com
panies that collectively take on the role of “keeper” of the method. The consortium
 has defined an agile process model, called the DSDM life cycle that defines three dif
ferent iterative cycles, preceded by two additional life cycle activities:
 Feasibility study—establishes the basic business requirements and constraints
 associated with the application to be built and then assesses whether the applica
tion is a viable candidate for the DSDM process.
85
 CHAPTER 3 AGILE DEVELOPMENT
 DSDM is a process
 framework that can
 adopt the tactics of
 another agile approach
 such as XP.
 Crystal is a family of
 process models with
 the same “genetic
 code” but different
 methods for adapting
 to project
 characteristics.
 Business study—establishes the functional and information requirements that
 will allow the application to provide business value; also, defines the basic
 application architecture and identifies the maintainability requirements for the
 application.
 Functional model iteration—produces a set of incremental prototypes that
 demonstrate functionality for the customer. (Note: All DSDM prototypes are in
tended to evolve into the deliverable application.) The intent during this iterative
 cycle is to gather additional requirements by eliciting feedback from users as they
 exercise the prototype.
 Design and build iteration—revisits prototypes built during functional model
 iteration to ensure that each has been engineered in a manner that will enable it to
 provide operational business value for end users. In some cases, functional model
 iteration and design and build iteration occur concurrently.
 Implementation—places the latest software increment (an “operationalized” pro
totype) into the operational environment. It should be noted that (1) the increment
 may not be 100 percent complete or (2) changes may be requested as the incre
ment is put into place. In either case, DSDM development work continues by
 returning to the functional model iteration activity.
 DSDM can be combined with XP (Section 3.4) to provide a combination approach
 that defines a solid process model (the DSDM life cycle) with the nuts and bolts prac
tices (XP) that are required to build software increments. In addition, the ASD con
cepts of collaboration and self-organizing teams can be adapted to a combined
 process model.
 3.5.4 Crystal
 Alistair Cockburn [Coc05] and Jim Highsmith [Hig02b] created the Crystal family of
 agile methods15 in order to achieve a software development approach that puts a
 premium on “maneuverability” during what Cockburn characterizes as “a resource
limited, cooperative game of invention and communication, with a primary goal of
 delivering useful, working software and a secondary goal of setting up for the next
 game” [Coc02].
 To achieve maneuverability, Cockburn and Highsmith have defined a set of
 methodologies, each with core elements that are common to all, and roles, process
 patterns, work products, and practice that are unique to each. The Crystal family is
 actually a set of example agile processes that have been proven effective for differ
ent types of projects. The intent is to allow agile teams to select the member of the
 crystal family that is most appropriate for their project and environment.
 15 The name “crystal” is derived from the characteristics of geological crystals, each with its own
 color, shape, and hardness.
86
 PART ONE THE SOFTWARE PROCESS
 3.5.5 Feature Driven Development (FDD)
 WebRef
 A wide variety of
 articles and
 presentations on FDD
 can be found at:
 www.featuredrive
 ndevelopment
 .com/.
 Feature Driven Development (FDD) was originally conceived by Peter Coad and his
 colleagues [Coa99] as a practical process model for object-oriented software engi
neering. Stephen Palmer and John Felsing [Pal02] have extended and improved
 Coad’s work, describing an adaptive, agile process that can be applied to moderately
 sized and larger software projects.
 Like other agile approaches, FDD adopts a philosophy that (1) emphasizes col
laboration among people on an FDD team; (2) manages problem and project
 complexity using feature-based decomposition followed by the integration of
 software increments, and (3) communication of technical detail using verbal,
 graphical, and text-based means. FDD emphasizes software quality assurance
 activities by encouraging an incremental development strategy, the use of design
 and code inspections, the application of software quality assurance audits (Chap
ter 16), the collection of metrics, and the use of patterns (for analysis, design, and
 construction).
 In the context of FDD, a feature “is a client-valued function that can be imple
mented in two weeks or less” [Coa99]. The emphasis on the definition of features
 provides the following benefits:
 • Because features are small blocks of deliverable functionality, users can
 describe them more easily; understand how they relate to one another more
 readily; and better review them for ambiguity, error, or omissions.
 • Features can be organized into a hierarchical business-related grouping.
 • Since a feature is the FDD deliverable software increment, the team develops
 operational features every two weeks.
 • Because features are small, their design and code representations are easier
 to inspect effectively.
 • Project planning, scheduling, and tracking are driven by the feature
 hierarchy, rather than an arbitrarily adopted software engineering 
task set.
 Coad and his colleagues [Coa99] suggest the following template for defining a
 feature:
 <action> the <result> <by for of to> a(n) <object>
 where an <object> is “a person, place, or thing (including roles, moments in time or
 intervals of time, or catalog-entry-like descriptions).” Examples of features for an 
e-commerce application might be:
 Add the product to shopping cart
 Display the technical-specifications of the product
 Store the shipping-information for the customer
87
 CHAPTER 3 AGILE DEVELOPMENT
 FIGURE 3.5
 Feature Driven
 Development
 [Coa99] (with
 permission)
 Develop
 an
 Overall
 Model
 Build a
 Features
 List
 Plan
 By
 Feature
 Design
 By
 Feature
 (more shape
 than content)
 A list of features
 grouped into sets
 and subject areas
 A development plan
 Class owners
 Feature Set Owners
 A design
 package
 (sequences)
 Build
 By
 Feature
 Completed
 client-value
 function
 A feature set groups related features into business-related categories and is defined
 [Coa99] as:
 <action><-ing> a(n) <object>
 For example: Making a product sale is a feature set that would encompass the fea
tures noted earlier and others.
 The FDD approach defines five “collaborating” [Coa99] framework activities (in
 FDD these are called “processes”) as shown in Figure 3.5.
 FDD provides greater emphasis on project management guidelines and tech
niques than many other agile methods. As projects grow in size and complexity,
 ad hoc project management is often inadequate. It is essential for developers, their
 managers, and other stakeholders to understand project status—what accomplish
ments have been made and problems have been encountered. If deadline pressure
 is significant, it is critical to determine if software increments (features) are properly
 scheduled. To accomplish this, FDD defines six milestones during the design and
 implementation of a feature: “design walkthrough, design, design inspection, code,
 code inspection, promote to build” [Coa99].
 3.5.6 Lean Software Development (LSD)
 Lean Software Development (LSD) has adapted the principles of lean manufacturing
 to the world of software engineering. The lean principles that inspire the LSD process
 can be summarized ([Pop03], [Pop06a]) as eliminate waste, build quality in, create
 knowledge, defer commitment, deliver fast, respect people, and optimize the whole.
 Each of these principles can be adapted to the software process. For example,
 eliminate waste within the context of an agile software project can be interpreted
 to mean [Das05]: (1) adding no extraneous features or functions, (2) assessing the
 cost and schedule impact of any newly requested requirement, (3) removing any
 superfluous process steps, (4) establishing mechanisms to improve the way team
 members find information, (5) ensuring the testing finds as many errors as possible,
88
 PART ONE THE SOFTWARE PROCESS
 (6) reducing the time required to request and get a decision that affects the software
 or the process that is applied to create it, and (7) streamlining the manner in which
 information is transmitted to all stakeholders involved in the process.
 For a detailed discussion of LSD and pragmatic guidelines for implementing the
 process, you should examine [Pop06a] and [Pop06b].
 3.5.7 Agile Modeling (AM)
 WebRef
 Comprehensive
 information on agile
 modeling can be found
 at: www
 .agilemodeling.com.
 uote:
 “I was in the drug
 store the other day
 trying to get a cold
 medication . . . not
 easy. There’s an
 entire wall of
 products you need.
 You stand there
 going, Well, this
 one is quick acting
 but this is long
 lasting. . . . Which
 is more important,
 the present or the
 future?”
 Jerry Seinfeld
 There are many situations in which software engineers must build large, business
critical systems. The scope and complexity of such systems must be modeled so that
 (1) all constituencies can better understand what needs to be accomplished, (2) the
 problem can be partitioned effectively among the people who must solve it, and
 (3) quality can be assessed as the system is being engineered and built.
 Over the past 30 years, a wide variety of software engineering modeling methods
 and notation have been proposed for analysis and design (both architectural and
 component-level). These methods have merit, but they have proven to be difficult
 to apply and challenging to sustain (over many projects). Part of the problem is the
 “weight” of these modeling methods. By this I mean the volume of notation required,
 the degree of formalism suggested, the sheer size of the models for large projects,
 and the difficulty in maintaining the model(s) as changes occur. Yet analysis and de
sign modeling have substantial benefit for large projects—if for no other reason than
 to make these projects intellectually manageable. Is there an agile approach to soft
ware engineering modeling that might provide an alternative?
 At “The Official Agile Modeling Site,” Scott Ambler [Amb02a] describes agile mod
eling (AM) in the following manner:
 Agile Modeling (AM) is a practice-based methodology for effective modeling and documen
tation of software-based systems. Simply put, Agile Modeling (AM) is a collection of values,
 principles, and practices for modeling software that can be applied on a software develop
ment project in an effective and light-weight manner. Agile models are more effective than
 traditional models because they are just barely good, they don’t have to be perfect.
 Agile modeling adopts all of the values that are consistent with the agile manifesto.
 The agile modeling philosophy recognizes that an agile team must have the courage
 to make decisions that may cause it to reject a design and refactor. The team must
 also have the humility to recognize that technologists do not have all the answers and
 that business experts and other stakeholders should be respected and embraced.
 Although AM suggests a wide array of “core” and “supplementary” modeling prin
ciples, those that make AM unique are [Amb02a]:
 Model with a purpose. A developer who uses AM should have a specific
 goal (e.g., to communicate information to the customer or to help better un
derstand some aspect of the software) in mind before creating the model.
 Once the goal for the model is identified, the type of notation to be used and
 level of detail required will be more obvious.
89
 CHAPTER 3 AGILE DEVELOPMENT
 Use multiple models. There are many different models and notations that
 can be used to describe software. Only a small subset is essential for most
 projects. AM suggests that to provide needed insight, each model should
 present a different aspect of the system and only those models that provide
 value to their intended audience should be used.
 “Traveling light” is an
 appropriate philosophy
 for all software engi
neering work. Build
 only those models that
 provide value … no
 more, no less.
 Travel light. As software engineering work proceeds, keep only those mod
els that will provide long-term value and jettison the rest. Every work product
 that is kept must be maintained as changes occur. This represents work that
 slows the team down. Ambler [Amb02a] notes that “Every time you decide to
 keep a model you trade-off agility for the convenience of having that informa
tion available to your team in an abstract manner (hence potentially enhanc
ing communication within your team as well as with project stakeholders).”
 Content is more important than representation. Modeling should im
part information to its intended audience. A syntactically perfect model that
 imparts little useful content is not as valuable as a model with flawed nota
tion that nevertheless provides valuable content for its audience.
 Know the models and the tools you use to create them. Understand
 the strengths and weaknesses of each model and the tools that are used to
 create it.
 Adapt locally. The modeling approach should be adapted to the needs of
 the agile team.
 A major segment of the software engineering community has adopted the Unified
 Modeling Language (UML)16 as the preferred method for representing analysis and
 design models. The Unified Process (Chapter 2) has been developed to provide a
 framework for the application of UML. Scott Ambler [Amb06] has developed a sim
plified version of the UP that integrates his agile modeling philosophy.
 3.5.8 Agile Unified Process (AUP)
 The Agile Unified Process (AUP) adopts a “serial in the large” and “iterative in the
 small” [Amb06] philosophy for building computer-based systems. By adopting the
 classic UP phased activities—inception, elaboration, construction, and transition—AUP
 provides a serial overlay (i.e., a linear sequence of software engineering activities)
 that enables a team to visualize the overall process flow for a software project. How
ever, within each of the activities, the team iterates to achieve agility and to deliver
 meaningful software increments to end users as rapidly as possible. Each AUP iter
ation addresses the following activities [Amb06]: 
• Modeling. UML representations of the business and problem domains are
 created. However, to stay agile, these models should be “just barely good
 enough” [Amb06] to allow the team to proceed.
 16 A brief tutorial on UML is presented in Appendix 1.
90
 PART ONE THE SOFTWARE PROCESS
 • Implementation. Models are translated into source code.
 • Testing. Like XP, the team designs and executes a series of tests to uncover
 errors and ensure that the source code meets its requirements.
 • Deployment. Like the generic process activity discussed in Chapters 1 and 2,
 deployment in this context focuses on the delivery of a software increment
 and the acquisition of feedback from end users.
 • Configuration and project management. In the context of AUP, configuration
 management (Chapter 22) addresses change management, risk manage
ment, and the control of any persistent work products17 that are produced by
 the team. Project management tracks and controls the progress of the team
 and coordinates team activities.
 • Environment management. Environment management coordinates a process
 infrastructure that includes standards, tools, and other support technology
 available to the team.
 Although the AUP has historical and technical connections to the Unified Modeling
 Language, it is important to note that UML modeling can be using in conjunction
 with any of the agile process models described in Section 3.5.
 SOFTWARE TOOLS
 Agile Development
 Objective: The objective of agile development
 tools is to assist in one or more aspects of agile
 development with an emphasis on facilitating the rapid
 generation of operational software. These tools can also
 be used when prescriptive process models (Chapter 2) are
 applied.
 Mechanics: Tool mechanics vary. In general, agile tool
 sets encompass automated support for project planning,
 use case development and requirements gathering, rapid
 design, code generation, and testing.
 Representative Tools:18
 Note: Because agile development is a hot topic, most
 software tools vendors purport to sell tools that support 
the agile approach. The tools noted here have
 characteristics that make them particularly useful for
 agile projects.
 OnTime, developed by Axosoft (www.axosoft.com),
 provides agile process management support for
 various technical activities within the process.
 Ideogramic UML, developed by Ideogramic
 (www.ideogramic.com) is a UML tool set
 specifically developed for use within an agile 
process.
 Together Tool Set, distributed by Borland
 (www.borland.com), provides a tools suite that
 supports many technical activities within XP and other
 agile processes.
 17 A persistent work product is a model or document or test case produced by the team that will be kept
 for an indeterminate period of time. It will not be discarded once the software increment is
 delivered.
 18 Tools noted here do not represent an endorsement, but rather a sampling of tools in this category.
 In most cases, tool names are trademarked by their respective developers.
91
 CHAPTER 3 AGILE DEVELOPMENT
 3.6 A TOOL SET FOR THE AGILE PROCESS
 The “tool set” that
 supports agile
 processes focuses
 more on people issues
 than it does on
 technology issues.
 Some proponents of the agile philosophy argue that automated software tools (e.g.,
 design tools) should be viewed as a minor supplement to the team’s activities, and
 not at all pivotal to the success of the team. However, Alistair Cockburn [Coc04] sug
gests that tools can have a benefit and that “agile teams stress using tools that per
mit the rapid flow of understanding. Some of those tools are social, starting even at
 the hiring stage. Some tools are technological, helping distributed teams simulate
 being physically present. Many tools are physical, allowing people to manipulate
 them in workshops.”
 Because acquiring the right people (hiring), team collaboration, stakeholder com
munication, and indirect management are key elements in virtually all agile process
 models, Cockburn argues that “tools” that address these issues are critical success
 factors for agility. For example, a hiring “tool” might be the requirement to have a
 prospective team member spend a few hours pair programming with an existing
 member of the team. The “fit” can be assessed immediately.
 Collaborative and communication “tools” are generally low tech and incorporate
 any mechanism (“physical proximity, whiteboards, poster sheets, index cards, and
 sticky notes” [Coc04]) that provides information and coordination among agile de
velopers. Active communication is achieved via the team dynamics (e.g., pair pro
gramming), while passive communication is achieved by “information radiators”
 (e.g., a flat panel display that presents the overall status of different components of
 an increment). Project management tools deemphasize the Gantt chart and replace
 it with earned value charts or “graphs of tests created versus passed . . . other agile
 tools are used to optimize the environment in which the agile team works (e.g., more
 efficient meeting areas), improve the team culture by nurturing social interactions
 (e.g., collocated teams), physical devices (e.g., electronic whiteboards), and process
 enhancement (e.g., pair programming or time-boxing)” [Coc04].
 Are any of these things really tools? They are, if they facilitate the work performed
 by an agile team member and enhance the quality of the end product.
 3.7 SUMMARY
 In a modern economy, market conditions change rapidly, customer and end-user
 needs evolve, and new competitive threats emerge without warning. Practitioners
 must approach software engineering in a manner that allows them to remain agile—
 to define maneuverable, adaptive, lean processes that can accommodate the needs
 of modern business.
 An agile philosophy for software engineering stresses four key issues: the impor
tance of self-organizing teams that have control over the work they perform, com
munication and collaboration between team members and between practitioners
 and their customers, a recognition that change represents an opportunity, and
92
 PART ONE THE SOFTWARE PROCESS
 an emphasis on rapid delivery of software that satisfies the customer. Agile process
 models have been designed to address each of these issues.
 Extreme programming (XP) is the most widely used agile process. Organized as
 four framework activities—planning, design, coding, and testing—XP suggests a
 number of innovative and powerful techniques that allow an agile team to create
 frequent software releases that deliver features and functionality that have been de
scribed and then prioritized by stakeholders.
 Other agile process models also stress human collaboration and team self
organization, but define their own framework activities and select different points of
 emphasis. For example, ASD uses an iterative process that incorporates adaptive
 cycle planning, relatively rigorous requirement gathering methods, and an iterative
 development cycle that incorporates customer focus groups and formal technical re
views as real-time feedback mechanisms. Scrum emphasizes the use of a set of soft
ware process patterns that have proven effective for projects with tight time lines,
 changing requirements, and business criticality. Each process pattern defines a set
 of development tasks and allows the Scrum team to construct a process that is
 adapted to the needs of the project. The Dynamic Systems Development Method
 (DSDM) advocates the use of time-box scheduling and suggests that only enough
 work is required for each software increment to facilitate movement to the next
 increment. Crystal is a family of agile process models that can be adopted to the spe
cific characteristics of a project.
 Feature Driven Development (FDD) is somewhat more “formal” than other agile
 methods, but still maintains agility by focusing the project team on the development
 of features—a client-valued function that can be implemented in two weeks or less.
 Lean Software Development (LSD) has adapted the principles of lean manufacturing
 to the world of software engineering. Agile modeling (AM) suggests that modeling is
 essential for all systems, but that the complexity, type, and size of the model must be
 tuned to the software to be built. The Agile Unified Process (AUP) adopts a “serial in
 the large” and “iterative in the small” philosophy for building software.
 PROBLEMS AND POINTS TO PONDER
 3.1. Reread “The Manifesto for Agile Software Development” at the beginning of this chapter.
 Can you think of a situation in which one or more of the four “values” could get a software team
 into trouble?
 3.2. Describe agility (for software projects) in your own words.
 3.3. Why does an iterative process make it easier to manage change? Is every agile process dis
cussed in this chapter iterative? Is it possible to complete a project in just one iteration and still
 be agile? Explain your answers.
 3.4. Could each of the agile processes be described using the generic framework activities
 noted in Chapter 2? Build a table that maps the generic activities into the activities defined for
 each agile process.
 3.5. Try to come up with one more “agility principle” that would help a software engineering
 team become even more maneuverable.
93
 CHAPTER 3 AGILE DEVELOPMENT
 3.6. Select one agility principle noted in Section 3.3.1 and try to determine whether each of the
 process models presented in this chapter exhibits the principle. [Note: I have presented an
 overview of these process models only, so it may not be possible to determine whether a prin
ciple has been addressed by one or more of the models, unless you do additional research
 (which is not required for this problem).]
 3.7. Why do requirements change so much? After all, don’t people know what they want?
 3.8. Most agile process models recommend face-to-face communication. Yet today, members
 of a software team and their customers may be geographically separated from one another. Do
 you think this implies that geographical separation is something to avoid? Can you think of ways
 to overcome this problem?
 3.9. Write an XP user story that describes the “favorite places” or “bookmarks” feature avail
able on most Web browsers.
 3.10. What is a spike solution in XP?
 3.11. Describe the XP concepts of refactoring and pair programming in your own words.
 3.12. Do a bit more reading and describe what a time-box is. How does this assist an ASD team
 in delivering software increments in a short time period?
 3.13. Do the 80 percent rule in DSDM and the time-boxing approach defined for ASD achieve
 the same result?
 3.14. Using the process pattern template presented in Chapter 2, develop a process pattern for
 any one of the Scrum patterns presented in Section 3.5.2.
 3.15. Why is Crystal called a family of agile methods?
 3.16. Using the FDD feature template described in Section 3.5.5, define a feature set for a Web
 browser. Now develop a set of features for the feature set.
 3.17. Visit the Official Agile Modeling Site and make a complete list of all core and supple
mentary AM principles.
 3.18. The tool set proposed in Section 3.6 supports many of the “soft” aspects of agile meth
ods. Since communication is so important, recommend an actual tool set that might be used to
 enhance communication among stakeholders on an agile team.
 FURTHER READINGS AND INFORMATION SOURCES
 The overall philosophy and underlying principles of agile software development are considered
 in depth in many of the books referenced in the body of this chapter. In addition, books by Shaw
 and Warden (The Art of Agile Development, O’Reilly Media, Inc., 2008), Hunt (Agile Software Con
struction, Springer, 2005), and Carmichael and Haywood (Better Software Faster, Prentice-Hall,
 2002) present useful discussions of the subject. Aguanno (Managing Agile Projects, Multi
Media Publications, 2005), Highsmith (Agile Project Management: Creating Innovative Products,
 Addison-Wesley, 2004), and Larman (Agile and Iterative Development: A Manager’s Guide,
 Addison-Wesley, 2003) present a management overview and consider project management
 issues. Highsmith (Agile Software Development Ecosystems, Addison-Wesley, 2002) presents a
 survey of agile principles, processes, and practices. A worthwhile discussion of the delicate bal
ance between agility and discipline is presented by Booch and his colleagues (Balancing Agility
 and Discipline, Addison-Wesley, 2004).
 Martin (Clean Code: A Handbook of Agile Software Craftsmanship, Prentice-Hall, 2009) pres
ents the principles, patterns, and practices required to develop “clean code” in an agile software
 engineering environment. Leffingwell (Scaling Software Agility: Best Practices for Large Enter
prises, Addison-Wesley, 2007) discusses strategies for scaling up agile practices for large proj
ects. Lippert and Rook (Refactoring in Large Software Projects: Performing Complex Restructurings
 Successfully, Wiley, 2006) discuss the use of refactoring when applied in large, complex systems.
94
 PART ONE THE SOFTWARE PROCESS
 Stamelos and Sfetsos (Agile Software Development Quality Assurance, IGI Global, 2007) discuss
 SQA techniques that conform to the agile philosophy.
 Dozens of books have been written about Extreme Programming over the past decade. Beck
 (Extreme Programming Explained: Embrace Change, 2d ed., Addison-Wesley, 2004) remains the
 definitive treatment of the subject. In addition, Jeffries and his colleagues (Extreme Programming
 Installed, Addison-Wesley, 2000), Succi and Marchesi (Extreme Programming Examined,
 Addison-Wesley, 2001), Newkirk and Martin (Extreme Programming in Practice, Addison-Wesley,
 2001), and Auer and his colleagues (Extreme Programming Applied: Play to Win, Addison-Wesley,
 2001) provide a nuts-and-bolts discussion of XP along with guidance on how best to apply it.
 McBreen (Questioning Extreme Programming, Addison-Wesley, 2003) takes a critical look at XP,
 defining when and where it is appropriate. An in-depth consideration of pair programming is
 presented by McBreen (Pair Programming Illuminated, Addison-Wesley, 2003).
 ASD is addressed in depth by Highsmith [Hig00]. Schwaber (The Enterprise and Scrum,
 Microsoft Press, 2007) discusses the use of Scrum for projects that have a major business
 impact. The nuts and bolts of Scrum are discussed by Schwaber and Beedle (Agile Software
 Development with SCRUM, Prentice-Hall, 2001). Worthwhile treatments of DSDM have been
 written by the DSDM Consortium (DSDM: Business Focused Development, 2d ed., Pearson Edu
cation, 2003) and Stapleton (DSDM: The Method in Practice, Addison-Wesley, 1997). Cockburn
 (Crystal Clear, Addison-Wesley, 2005) presents an excellent overview of the Crystal family of
 processes. Palmer and Felsing [Pal02] present a detailed treatment of FDD. Carmichael and
 Haywood (Better Software Faster, Prentice-Hall, 2002) provides another useful treatment of FDD
 that includes a step-by-step journey through the mechanics of the process. Poppendieck and 
Poppendieck (Lean Development: An Agile Toolkit for Software Development Managers, Addison
Wesley, 2003) provide guidelines for managing and controlling agile projects. Ambler and
 Jeffries (Agile Modeling, Wiley, 2002) discuss AM in some depth.
 A wide variety of information sources on agile software development are available on the
 Internet. An up-to-date list of World Wide Web references that are relevant to the agile process
 can be found at the SEPA website: www.mhhe.com/engcs/compsci/pressman/
 professional/olc/ser.htm.
In 2001, Kent Beck and 16 other noted software developers, writers, and con
sultants [Bec01a] (referred to as the “Agile Alliance”) signed the “Manifesto for
 Agile Software Development.” It stated:
 We are uncovering better ways of developing software by doing it and helping others
 do it. Through this work we have come to value: 
Individuals and interactions over processes and tools
 Working software over comprehensive documentation
 Customer collaboration over contract negotiation
 Responding to change over following a plan
 That is, while there is value in the items on the right, we value the items on the 
left more.
 QUICK
 LOOK
 What is it? Agile software engi
neering combines a philosophy and
 a set of development guidelines. The
 philosophy encourages customer
 satisfaction and early incremental delivery of
 software; small, highly motivated project teams;
 informal methods; minimal software engineer
ing work products; and overall development
 simplicity. The development guidelines stress
 delivery over analysis and design (although
 these activities are not discouraged), and active
 and continuous communication between devel
opers and customers.
 Who does it? Software engineers and other
 project stakeholders (managers, customers, end
 users) work together on an agile team—a team
 that is self-organizing and in control of its own
 destiny. An agile team fosters communication
 and collaboration among all who serve on it.
 Why is it important? The modern business envi
ronment that spawns computer-based systems
 and software products is fast-paced and ever
changing. Agile software engineering repre
sents a reasonable alternative to conventional
 software engineering for certain classes of soft
ware and certain types of software projects. It
 has been demonstrated to deliver successful sys
tems quickly.
 Whatarethesteps? Agiledevelopmentmightbest
 be termed “software engineering lite.” The basic
 framework activities—communication, planning,
 modeling, construction, and deployment—
 remain. But they morph into a minimal task set
 that pushes the project team toward construction
 and delivery (some would argue that this is
 done at the expense of problem analysis and
 solution design).
 What is the work product? Both the customer
 and the software engineer have the same
 view—the only really important work product
 is an operational “software increment” that is
 delivered to the customer on the appropriate
 commitment date.
 How do I ensure that I’ve done it right? If the
 agile team agrees that the process works, and
 the team produces deliverable software
 increments that satisfy the customer, you’ve
 done it right.
 65
66
 PART ONE THE SOFTWARE PROCESS
 FDD . . . . . . . . . .86
 Industrial XP . . .77
 Lean Software
 Development . . .87
 pair 
programming . . .76
 project 
velocity . . . . . . .74
 refactoring . . . . .75
 Scrum . . . . . . . .82
 stories . . . . . . . .74
 XP process . . . . .73
 uote:
 “Agility: 1,
 everything else: 0.”
 Tom DeMarco
 A manifesto is normally associated with an emerging political movement—one
 that attacks the old guard and suggests revolutionary change (hopefully for the
 better). In some ways, that’s exactly what agile development is all about.
 Although the underlying ideas that guide agile development have been with us for
 many years, it has been less than two decades since these ideas have crystallized
 into a “movement.” In essence, agile1 methods were developed in an effort to over
come perceived and actual weaknesses in conventional software engineering. Agile
 development can provide important benefits, but it is not applicable to all projects,
 all products, all people, and all situations. It is also not antithetical to solid software
 engineering practice and can be applied as an overriding philosophy for all software
 work.
 In the modern economy, it is often difficult or impossible to predict how a
 computer-based system (e.g., a Web-based application) will evolve as time passes.
 Market conditions change rapidly, end-user needs evolve, and new competitive
 threats emerge without warning. In many situations, you won’t be able to define
 requirements fully before the project begins. You must be agile enough to respond to
 a fluid business environment.
 Fluidity implies change, and change is expensive. Particularly if it is uncontrolled
 or poorly managed. One of the most compelling characteristics of the agile approach
 is its ability to reduce the costs of change throughout the software process.
 Does this mean that a recognition of challenges posed by modern realities causes
 you to discard valuable software engineering principles, concepts, methods, and
 tools? Absolutely not! Like all engineering disciplines, software engineering contin
ues to evolve. It can be adapted easily to meet the challenges posed by a demand for
 agility.
 In a thought-provoking book on agile software development, Alistair Cockburn
 [Coc02] argues that the prescriptive process models introduced in Chapter 2 have a
 major failing: they forget the frailties of the people who build computer software. Software
 engineers are not robots. They exhibit great variation in working styles; significant dif
ferences in skill level, creativity, orderliness, consistency, and spontaneity. Some com
municate well in written form, others do not. Cockburn argues that process models
 can “deal with people’s common weaknesses with [either] discipline or tolerance” and
 that most prescriptive process models choose discipline. He states: “Because consis
tency in action is a human weakness, high discipline methodologies are fragile.”
 If process models are to work, they must provide a realistic mechanism for en
couraging the discipline that is necessary, or they must be characterized in a man
ner that shows “tolerance” for the people who do software engineering work.
 Invariably, tolerant practices are easier for software people to adopt and sustain, but
 (as Cockburn admits) they may be less productive. Like most things in life, trade-offs
 must be considered.
 1 Agile methods are sometimes referred to as light methods or lean methods.
67
 CHAPTER 3 AGILE DEVELOPMENT
 3.1 WHAT IS AGILITY?
 Just what is agility in the context of software engineering work? Ivar Jacobson
 [Jac02a] provides a useful discussion:
 Agility has become today’s buzzword when describing a modern software process. Every
one is agile. An agile team is a nimble team able to appropriately respond to changes.
 Change is what software development is very much about. Changes in the software be
ing built, changes to the team members, changes because of new technology, changes of
 all kinds that may have an impact on the product they build or the project that creates the
 product. Support for changes should be built-in everything we do in software, something
 we embrace because it is the heart and soul of software. An agile team recognizes that
 software is developed by individuals working in teams and that the skills of these people,
 their ability to collaborate is at the core for the success of the project.
 Don’t make the
 mistake of assuming
 that agility gives you
 license to hack out
 solutions. A process is
 required and discipline
 is essential.
 In Jacobson’s view, the pervasiveness of change is the primary driver for agility. Soft
ware engineers must be quick on their feet if they are to accommodate the rapid
 changes that Jacobson describes.
 But agility is more than an effective response to change. It also encompasses the
 philosophy espoused in the manifesto noted at the beginning of this chapter. It
 encourages team structures and attitudes that make communication (among team
 members, between technologists and business people, between software engineers
 and their managers) more facile. It emphasizes rapid delivery of operational soft
ware and de-emphasizes the importance of intermediate work products (not always
 a good thing); it adopts the customer as a part of the development team and works
 to eliminate the “us and them” attitude that continues to pervade many software
 projects; it recognizes that planning in an uncertain world has its limits and that a
 project plan must be flexible.
 Agility can be applied to any software process. However, to accomplish this, it is
 essential that the process be designed in a way that allows the project team to adapt
 tasks and to streamline them, conduct planning in a way that understands the fluid
ity of an agile development approach, eliminate all but the most essential work prod
ucts and keep them lean, and emphasize an incremental delivery strategy that gets
 working software to the customer as rapidly as feasible for the product type and
 operational environment.
 3.2 AGILITY AND THE COST OF CHANGE
 The conventional wisdom in software development (supported by decades of expe
rience) is that the cost of change increases nonlinearly as a project progresses
 (Figure 3.1, solid black curve). It is relatively easy to accommodate a change when a
 software team is gathering requirements (early in a project). A usage scenario might
 have to be modified, a list of functions may be extended, or a written specification
 can be edited. The costs of doing this work are minimal, and the time required will
68
 PART ONE THE SOFTWARE PROCESS
 FIGURE 3.1
 Change costs
 as a function
 of time in
 development
 uote:
 Development cost
 Cost of change
 using conventional
 software processes
 Cost of change
 using agile processes
 “Agility is dynamic,
 content specific,
 aggressively
 change embracing,
 and growth
 oriented.”
 Idealized cost of change
 using agile process
 Development schedule progress–Steven
 Goldman et al.
 An agile process
 reduces the cost of
 change because
 software is released in
 increments and change
 can be better
 controlled within an
 increment.
 not adversely affect the outcome of the project. But what if we fast-forward a num
ber of months? The team is in the middle of validation testing (something that occurs
 relatively late in the project), and an important stakeholder is requesting a major
 functional change. The change requires a modification to the architectural design of
 the software, the design and construction of three new components, modifications
 to another five components, the design of new tests, and so on. Costs escalate
 quickly, and the time and cost required to ensure that the change is made without
 unintended side effects is nontrivial.
 Proponents of agility (e.g., [Bec00], [Amb04]) argue that a well-designed agile
 process “flattens” the cost of change curve (Figure 3.1, shaded, solid curve), allowing
 a software team to accommodate changes late in a software project without dramatic
 cost and time impact. You’ve already learned that the agile process encompasses in
cremental delivery. When incremental delivery is coupled with other agile practices
 such as continuous unit testing and pair programming (discussed later in this chap
ter), the cost of making a change is attenuated. Although debate about the degree to
 which the cost curve flattens is ongoing, there is evidence [Coc01a] to suggest that a
 significant reduction in the cost of change can be achieved.
 3.3 WHAT IS ANAGILE PROCESS?
 Any agile software process is characterized in a manner that addresses a number of
 key assumptions [Fow02] about the majority of software projects: 
1. It is difficult to predict in advance which software requirements will persist
 and which will change. It is equally difficult to predict how customer
 priorities will change as the project proceeds.
69
 CHAPTER 3 AGILE DEVELOPMENT
 WebRef
 A comprehensive
 collection of articles on
 the agile process 
can be found at
 www.aanpo.org/
 articles/index.
 Although agile
 processes embrace
 change, it is still
 important to examine
 the reasons for
 change.
 Working software is
 important, but don’t
 forget that it must also
 exhibit a variety of
 quality attributes
 including reliability,
 usability, and 
maintainability.
 2. For many types of software, design and construction are interleaved. That is,
 both activities should be performed in tandem so that design models are
 proven as they are created. It is difficult to predict how much design is
 necessary before construction is used to prove the design.
 3. Analysis, design, construction, and testing are not as predictable (from a
 planning point of view) as we might like.
 Given these three assumptions, an important question arises: How do we create a
 process that can manage unpredictability? The answer, as I have already noted, lies
 in process adaptability (to rapidly changing project and technical conditions). An
 agile process, therefore, must be adaptable.
 But continual adaptation without forward progress accomplishes little. Therefore,
 an agile software process must adapt incrementally. To accomplish incremental adap
tation, an agile team requires customer feedback (so that the appropriate adaptations
 can be made). An effective catalyst for customer feedback is an operational prototype
 or a portion of an operational system. Hence, an incremental development strategy
 should be instituted. Software increments (executable prototypes or portions of an op
erational system) must be delivered in short time periods so that adaptation keeps pace
 with change (unpredictability). This iterative approach enables the customer to evalu
ate the software increment regularly, provide necessary feedback to the software team,
 and influence the process adaptations that are made to accommodate the feedback.
 3.3.1 Agility Principles
 The Agile Alliance (see [Agi03], [Fow01]) defines 12 agility principles for those who
 want to achieve agility: 
1. Our highest priority is to satisfy the customer through early and continuous
 delivery of valuable software.
 2. Welcome changing requirements, even late in development. Agile processes
 harness change for the customer’s competitive advantage.
 3. Deliver working software frequently, from a couple of weeks to a couple of
 months, with a preference to the shorter timescale.
 4. Business people and developers must work together daily throughout the
 project.
 5. Build projects around motivated individuals. Give them the environment and
 support they need, and trust them to get the job done.
 6. The most efficient and effective method of conveying information to and
 within a development team is face-to-face conversation.
 7. Working software is the primary measure of progress.
 8. Agile processes promote sustainable development. The sponsors, developers,
 and users should be able to maintain a constant pace indefinitely.
70
 PART ONE THE SOFTWARE PROCESS
 9. Continuous attention to technical excellence and good design enhances
 agility.
 10. Simplicity—the art of maximizing the amount of work not done—is 
essential.
 11. The best architectures, requirements, and designs emerge from self
organizing teams.
 12. At regular intervals, the team reflects on how to become more effective, then
 tunes and adjusts its behavior accordingly.
 Not every agile process model applies these 12 principles with equal weight, and
 some models choose to ignore (or at least downplay) the importance of one or more
 of the principles. However, the principles define an agile spirit that is maintained in
 each of the process models presented in this chapter.
 3.3.2 The Politics of Agile Development
 You don’t have to
 choose between agility
 and software engi
neering. Rather, define
 a software engineering
 approach that is agile.
 There is considerable debate (sometimes strident) about the benefits and applicabil
ity of agile software development as opposed to more conventional software engi
neering processes. Jim Highsmith [Hig02a] (facetiously) states the extremes when he
 characterizes the feeling of the pro-agility camp (“agilists”). “Traditional methodolo
gists are a bunch of stick-in-the-muds who’d rather produce flawless documentation
 than a working system that meets business needs.” As a counterpoint, he states
 (again, facetiously) the position of the traditional software engineering camp: “Light
weight, er, ‘agile’ methodologists are a bunch of glorified hackers who are going to
 be in for a heck of a surprise when they try to scale up their toys into enterprise-wide
 software.”
 Like all software technology arguments, this methodology debate risks degener
ating into a religious war. If warfare breaks out, rational thought disappears and
 beliefs rather than facts guide decision making.
 No one is against agility. The real question is: What is the best way to achieve it?
 As important, how do you build software that meets customers’ needs today and
 exhibits the quality characteristics that will enable it to be extended and scaled to
 meet customers’ needs over the long term?
 There are no absolute answers to either of these questions. Even within the agile
 school itself, there are many proposed process models (Section 3.4), each with a
 subtly different approach to the agility problem. Within each model there is a set of
 “ideas” (agilists are loath to call them “work tasks”) that represent a significant
 departure from traditional software engineering. And yet, many agile concepts are
 simply adaptations of good software engineering concepts. Bottom line: there is
 much that can be gained by considering the best of both schools and virtually
 nothing to be gained by denigrating either approach.
 If you have further interest, see [Hig01], [Hig02a], and [DeM02] for an entertain
ing summary of other important technical and political issues.
71
 CHAPTER 3 AGILE DEVELOPMENT
 uote:
 “Agile methods
 derive much of
 their agility by
 relying on the
 tacit knowledge
 embodied in the
 team, rather than
 writing the
 knowledge down
 in plans.”
 Barry Boehm
 ?
 What key
 traits must
 exist among the
 people on an
 effective software
 team?
 uote:
 “What counts as
 barely sufficient
 for one team is
 either overly
 sufficient or
 insufficient for
 another.”
 Alistair
 Cockburn
 3.3.3 Human Factors
 Proponents of agile software development take great pains to emphasize the impor
tance of “people factors.” As Cockburn and Highsmith [Coc01a] state, “Agile devel
opment focuses on the talents and skills of individuals, molding the process to
 specific people and teams.” The key point in this statement is that the process molds
 to the needs of the people and team, not the other way around.2
 If members of the software team are to drive the characteristics of the process that
 is applied to build software, a number of key traits must exist among the people on
 an agile team and the team itself:
 Competence. In an agile development (as well as software engineering)
 context, “competence” encompasses innate talent, specific software-related
 skills, and overall knowledge of the process that the team has chosen to
 apply. Skill and knowledge of process can and should be taught to all people
 who serve as agile team members.
 Common focus. Although members of the agile team may perform differ
ent tasks and bring different skills to the project, all should be focused on one
 goal—to deliver a working software increment to the customer within the
 time promised. To achieve this goal, the team will also focus on continual
 adaptations (small and large) that will make the process fit the needs of the
 team.
 Collaboration. Software engineering (regardless of process) is about as
sessing, analyzing, and using information that is communicated to the soft
ware team; creating information that will help all stakeholders understand
 the work of the team; and building information (computer software and rele
vant databases) that provides business value for the customer. To accomplish
 these tasks, team members must collaborate—with one another and all other
 stakeholders.
 Decision-making ability. Any good software team (including agile teams)
 must be allowed the freedom to control its own destiny. This implies that the
 team is given autonomy—decision-making authority for both technical and
 project issues.
 Fuzzy problem-solving ability. Software managers must recognize that
 the agile team will continually have to deal with ambiguity and will continu
ally be buffeted by change. In some cases, the team must accept the fact that
 the problem they are solving today may not be the problem that needs to be
 solved tomorrow. However, lessons learned from any problem-solving
 2 Successful software engineering organizations recognize this reality regardless of the process
 model they choose.
72
 PART ONE THE SOFTWARE PROCESS
 A self-organizing team
 is in control of the
 work it performs. The
 team makes its own
 commitments and
 defines plans to
 achieve them.
 activity (including those that solve the wrong problem) may be of benefit to
 the team later in the project.
 Mutual trust and respect. The agile team must become what DeMarco
 and Lister [DeM98] call a “jelled” team (Chapter 24). A jelled team exhibits
 the trust and respect that are necessary to make them “so strongly knit that
 the whole is greater than the sum of the parts.” [DeM98]
 Self-organization. In the context of agile development, self-organization
 implies three things: (1) the agile team organizes itself for the work to be
 done, (2) the team organizes the process to best accommodate its local envi
ronment, (3) the team organizes the work schedule to best achieve delivery
 of the software increment. Self-organization has a number of technical bene
fits, but more importantly, it serves to improve collaboration and boost team
 morale. In essence, the team serves as its own management. Ken Schwaber
 [Sch02] addresses these issues when he writes: “The team selects how much
 work it believes it can perform within the iteration, and the team commits to
 the work. Nothing demotivates a team as much as someone else making
 commitments for it. Nothing motivates a team as much as accepting the
 responsibility for fulfilling commitments that it made itself.”
 3.4 EXTREME PROGRAMMING (XP)
 In order to illustrate an agile process in a bit more detail, I’ll provide you with an
 overview of Extreme Programming (XP), the most widely used approach to agile soft
ware development. Although early work on the ideas and methods associated with
 XP occurred during the late 1980s, the seminal work on the subject has been written
 by Kent Beck [Bec04a]. More recently, a variant of XP, called Industrial XP (IXP) has
 been proposed [Ker05]. IXP refines XP and targets the agile process specifically for
 use within large organizations.
 3.4.1 XP Values
 Beck [Bec04a] defines a set of five values that establish a foundation for all work per
formed as part of XP—communication, simplicity, feedback, courage, and respect. Each
 of these values is used as a driver for specific XP activities, actions, and tasks.
 In order to achieve effective communication between software engineers and
 other stakeholders (e.g., to establish required features and functions for the soft
ware), XP emphasizes close, yet informal (verbal) collaboration between customers
 and developers, the establishment of effective metaphors3 for communicating
 important concepts, continuous feedback, and the avoidance of voluminous docu
mentation as a communication medium.
 3 In the XP context, a metaphor is “a story that everyone—customers, programmers, and managers—
 can tell about how the system works” [Bec04a].
73
 CHAPTER 3 AGILE DEVELOPMENT
 Keep it simple
 whenever you can, but
 recognize that
 continual “refactoring”
 can absorb significant
 time and resources.
 uote:
 “XP is the answer
 to the question,
 ‘How little can we
 do and still build
 great software?’“
 Anonymous
 WebRef
 An excellent overview
 of “rules” for XP can
 be found at www
 .extremeprogramm
 ing.org/rules.html.
 To achieve simplicity, XP restricts developers to design only for immediate needs,
 rather than consider future needs. The intent is to create a simple design that can be
 easily implemented in code). If the design must be improved, it can be refactored4 at
 a later time.
 Feedback is derived from three sources: the implemented software itself, the
 customer, and other software team members. By designing and implementing an
 effective testing strategy (Chapters 17 through 20), the software (via test results) pro
vides the agile team with feedback. XP makes use of the unit test as its primary test
ing tactic. As each class is developed, the team develops a unit test to exercise each
 operation according to its specified functionality. As an increment is delivered to a
 customer, the user stories or use cases (Chapter 5) that are implemented by the
 increment are used as a basis for acceptance tests. The degree to which the software
 implements the output, function, and behavior of the use case is a form of feedback.
 Finally, as new requirements are derived as part of iterative planning, the team pro
vides the customer with rapid feedback regarding cost and schedule impact.
 Beck [Bec04a] argues that strict adherence to certain XP practices demands
 courage. A better word might be discipline. For example, there is often significant
 pressure to design for future requirements. Most software teams succumb, arguing
 that “designing for tomorrow” will save time and effort in the long run. An agile XP
 team must have the discipline (courage) to design for today, recognizing that future
 requirements may change dramatically, thereby demanding substantial rework of
 the design and implemented code.
 By following each of these values, the agile team inculcates respect among it
 members, between other stakeholders and team members, and indirectly, for the
 software itself. As they achieve successful delivery of software increments, the team
 develops growing respect for the XP process.
 3.4.2 The XP Process
 Extreme Programming uses an object-oriented approach (Appendix 2) as its pre
ferred development paradigm and encompasses a set of rules and practices that
 occur within the context of four framework activities: planning, design, coding, and
 testing. Figure 3.2 illustrates the XP process and notes some of the key ideas and
 tasks that are associated with each framework activity. Key XP activities are sum
marized in the paragraphs that follow.
 Planning. The planning activity (also called the planning game) begins with
 listening—a requirements gathering activity that enables the technical members of
 the XP team to understand the business context for the software and to get a broad
 4 Refactoring allows a software engineer to improve the internal structure of a design (or source
 code) without changing its external functionality or behavior. In essence, refactoring can be used
 to improve the efficiency, readability, or performance of a design or the code that implements a
 design.
74
 PART ONE THE SOFTWARE PROCESS
 FIGURE 3.2
 The Extreme
 Programming
 process
 ?
 What is an
 XP “story”?
 WebRef
 A worthwhile XP
 “planning game” can
 be found at:
 c2.com/cgi/
 wiki?planningGame.
 simple design
 CRC cards
 user stories
 values
 acceptance test criteria
 iteration plan
 Release
 spike solutions
 prototypes
 refactoring
 design
 pair programming
 planning
 software increment
 project velocity computed
 unit test
 continuous integration
 acceptance testing
 test
 coding
 feel for required output and major features and functionality. Listening leads to the
 creation of a set of “stories” (also called user stories) that describe required output,
 features, and functionality for software to be built. Each story (similar to use cases
 described in Chapter 5) is written by the customer and is placed on an index card.
 The customer assigns a value (i.e., a priority) to the story based on the overall busi
ness value of the feature or function.5 Members of the XP team then assess each
 story and assign a cost—measured in development weeks—to it. If the story is esti
mated to require more than three development weeks, the customer is asked to split
 the story into smaller stories and the assignment of value and cost occurs again. It
 is important to note that new stories can be written at any time.
 Customers and developers work together to decide how to group stories into the
 next release (the next software increment) to be developed by the XP team. Once a
 basic commitment (agreement on stories to be included, delivery date, and other
 project matters) is made for a release, the XP team orders the stories that will be de
veloped in one of three ways: (1) all stories will be implemented immediately (within
 a few weeks), (2) the stories with highest value will be moved up in the schedule and
 implemented first, or (3) the riskiest stories will be moved up in the schedule and
 implemented first.
 After the first project release (also called a software increment) has been deliv
ered, the XP team computes project velocity. Stated simply, project velocity is the
 5 The value of a story may also be dependent on the presence of another story.
75
 CHAPTER 3 AGILE DEVELOPMENT
 Project velocity is a
 subtle measure of
 team productivity.
 XP deemphasizes the
 importance of design.
 Not everyone agrees.
 In fact, there are times
 when design should be
 emphasized.
 WebRef
 Refactoring techniques
 and tools can be
 found at:
 www.refactoring
 .com.
 number of customer stories implemented during the first release. Project velocity can
 then be used to (1) help estimate delivery dates and schedule for subsequent releases
 and (2) determine whether an overcommitment has been made for all stories across
 the entire development project. If an overcommitment occurs, the content of releases
 is modified or end delivery dates are changed.
 As development work proceeds, the customer can add stories, change the value
 of an existing story, split stories, or eliminate them. The XP team then reconsiders all
 remaining releases and modifies its plans accordingly.
 Design. XP design rigorously follows the KIS (keep it simple) principle. A simple
 design is always preferred over a more complex representation. In addition, the de
sign provides implementation guidance for a story as it is written—nothing less,
 nothing more. The design of extra functionality (because the developer assumes it
 will be required later) is discouraged.6
 XP encourages the use of CRC cards (Chapter 7) as an effective mechanism for
 thinking about the software in an object-oriented context. CRC (class-responsibility
collaborator) cards identify and organize the object-oriented classes7 that are rele
vant to the current software increment. The XP team conducts the design exercise
 using a process similar to the one described in Chapter 8. The CRC cards are the only
 design work product produced as part of the XP process.
 If a difficult design problem is encountered as part of the design of a story, XP rec
ommends the immediate creation of an operational prototype of that portion of the
 design. Called a spike solution, the design prototype is implemented and evaluated.
 The intent is to lower risk when true implementation starts and to validate the orig
inal estimates for the story containing the design problem.
 In the preceding section, we noted that XP encourages refactoring—a construction
 technique that is also a method for design optimization. Fowler [Fow00] describes
 refactoring in the following manner:
 Refactoring is the process of changing a software system in such a way that it does not
 alter the external behavior of the code yet improves the internal structure. It is a disci
plined way to clean up code [and modify/simplify the internal design] that minimizes the
 chances of introducing bugs. In essence, when you refactor you are improving the design
 of the code after it has been written.
 Because XP design uses virtually no notation and produces few, if any, work prod
ucts other than CRC cards and spike solutions, design is viewed as a transient arti
fact that can and should be continually modified as construction proceeds. The intent
 of refactoring is to control these modifications by suggesting small design changes
 6 These design guidelines should be followed in every software engineering method, although there
 are times when sophisticated design notation and terminology may get in the way of simplicity.
 7 Object-oriented classes are discussed in Appendix 2, in Chapter 8, and throughout Part 2 of this
 book.
76
 PART ONE THE SOFTWARE PROCESS
 Refactoring improves
 the internal structure of
 a design (or source
 code) without
 changing its external
 functionality or
 behavior.
 WebRef
 Useful information on
 XP can be obtained 
at www
 .xprogramming.
 com.
 ?
 What is 
pair
 programming?
 Many software teams
 are populated by indi
vidualists. You’ll have
 to work to change that
 culture if pair program
ming is to work effec
tively.
 ?
 XP?
 How are unit
 tests used in
 that “can radically improve the design” [Fow00]. It should be noted, however, that
 the effort required for refactoring can grow dramatically as the size of an application
 grows.
 A central notion in XP is that design occurs both before and after coding com
mences. Refactoring means that design occurs continuously as the system is con
structed. In fact, the construction activity itself will provide the XP team with
 guidance on how to improve the design.
 Coding. After stories are developed and preliminary design work is done, the team
 does not move to code, but rather develops a series of unit tests that will exercise
 each of the stories that is to be included in the current release (software increment).8
 Once the unit test9 has been created, the developer is better able to focus on what
 must be implemented to pass the test. Nothing extraneous is added (KIS). Once the
 code is complete, it can be unit-tested immediately, thereby providing instantaneous
 feedback to the developers.
 A key concept during the coding activity (and one of the most talked about aspects
 of XP) is pair programming. XP recommends that two people work together at one
 computer workstation to create code for a story. This provides a mechanism for real
time problem solving (two heads are often better than one) and real-time quality as
surance (the code is reviewed as it is created). It also keeps the developers focused
 on the problem at hand. In practice, each person takes on a slightly different role. For
 example, one person might think about the coding details of a particular portion of
 the design while the other ensures that coding standards (a required part of XP) are
 being followed or that the code for the story will satisfy the unit test that has been
 developed to validate the code against the story.
 As pair programmers complete their work, the code they develop is integrated
 with the work of others. In some cases this is performed on a daily basis by an inte
gration team. In other cases, the pair programmers have integration responsibility.
 This “continuous integration” strategy helps to avoid compatibility and interfacing
 problems and provides a “smoke testing” environment (Chapter 17) that helps to
 uncover errors early.
 Testing. I have already noted that the creation of unit tests before coding com
mences is a key element of the XP approach. The unit tests that are created should
 be implemented using a framework that enables them to be automated (hence, they
 can be executed easily and repeatedly). This encourages a regression testing strat
egy (Chapter 17) whenever code is modified (which is often, given the XP refactor
ing philosophy).
 8 This approach is analogous to knowing the exam questions before you begin to study. It makes
 studying much easier by focusing attention only on the questions that will be asked.
 9 Unit testing, discussed in detail in Chapter 17, focuses on an individual software component, exer
cising the component’s interface, data structures, and functionality in an effort to uncover errors
 that are local to the component.
77
 CHAPTER 3 AGILE DEVELOPMENT
 XP acceptance tests
 are derived from user
 stories.
 ?
 What new
 practices are
 appended to XP
 to create IXP?
 uote:
 “Ability is what
 you’re capable of
 doing. Motivation
 determines what
 you do. Attitude
 determines how
 well you do it.”
 Lou Holtz
 As the individual unit tests are organized into a “universal testing suite” [Wel99],
 integration and validation testing of the system can occur on a daily basis. This pro
vides the XP team with a continual indication of progress and also can raise warn
ing flags early if things go awry. Wells [Wel99] states: “Fixing small problems every
 few hours takes less time than fixing huge problems just before the deadline.”
 XP acceptance tests, also called customer tests, are specified by the customer and
 focus on overall system features and functionality that are visible and reviewable by
 the customer. Acceptance tests are derived from user stories that have been imple
mented as part of a software release.
 3.4.3 Industrial XP
 Joshua Kerievsky [Ker05] describes Industrial Extreme Programming (IXP) in the fol
lowing manner: “IXP is an organic evolution of XP. It is imbued with XP’s minimal
ist, customer-centric, test-driven spirit. IXP differs most from the original XP in its
 greater inclusion of management, its expanded role for customers, and its upgraded
 technical practices.” IXP incorporates six new practices that are designed to help
 ensure that an XP project works successfully for significant projects within a large
 organization.
 Readiness assessment. Prior to the initiation of an IXP project, the organ
ization should conduct a readiness assessment. The assessment ascertains
 whether (1) an appropriate development environment exists to support IXP,
 (2) the team will be populated by the proper set of stakeholders, (3) the or
ganization has a distinct quality program and supports continuous improve
ment, (4) the organizational culture will support the new values of an agile
 team, and (5) the broader project community will be populated appropriately.
 Project community. Classic XP suggests that the right people be used to
 populate the agile team to ensure success. The implication is that people on
 the team must be well-trained, adaptable and skilled, and have the proper
 temperament to contribute to a self-organizing team. When XP is to be
 applied for a significant project in a large organization, the concept of the
 “team” should morph into that of a community. A community may have a
 technologist and customers who are central to the success of a project as
 well as many other stakeholders (e.g., legal staff, quality auditors, manufac
turing or sales types) who “are often at the periphery of an IXP project yet
 they may play important roles on the project” [Ker05]. In IXP, the community
 members and their roles should be explicitly defined and mechanisms for
 communication and coordination between community members should be
 established.
 Project chartering. The IXP team assesses the project itself to determine
 whether an appropriate business justification for the project exists and
 whether the project will further the overall goals and objectives of the
78
 PART ONE THE SOFTWARE PROCESS
 organization. Chartering also examines the context of the project to deter
mine how it complements, extends, or replaces existing systems or
 processes.
 Test-driven management. An IXP project requires measurable criteria for
 assessing the state of the project and the progress that has been made to
 date. Test-driven management establishes a series of measurable “destina
tions” [Ker05] and then defines mechanisms for determining whether or not
 these destinations have been reached.
 Retrospectives. An IXP team conducts a specialized technical review
 (Chapter 15) after a software increment is delivered. Called a retrospective,
 the review examines “issues, events, and lessons-learned” [Ker05] across a
 software increment and/or the entire software release. The intent is to
 improve the IXP process.
 Continuous learning. Because learning is a vital part of continuous
 process improvement, members of the XP team are encouraged (and possi
bly, incented) to learn new methods and techniques that can lead to a higher
quality product.
 In addition to the six new practices discussed, IXP modifies a number of existing
 XP practices. Story-driven development (SDD) insists that stories for acceptance tests
 be written before a single line of code is generated. Domain-driven design (DDD) is
 an improvement on the “system metaphor” concept used in XP. DDD [Eva03] sug
gests the evolutionary creation of a domain model that “accurately represents how
 domain experts think about their subject” [Ker05]. Pairing extends the XP pair
programming concept to include managers and other stakeholders. The intent is to
 improve knowledge sharing among XP team members who may not be directly in
volved in technical development. Iterative usability discourages front-loaded inter
face design in favor of usability design that evolves as software increments are
 delivered and users’ interaction with the software is studied.
 IXP makes smaller modifications to other XP practices and redefines certain roles
 and responsibilities to make them more amenable to significant projects for large
 organizations. For further discussion of IXP, visit http://industrialxp.org.
 3.4.4 The XP Debate
 All new process models and methods spur worthwhile discussion and in some in
stances heated debate. Extreme Programming has done both. In an interesting book
 that examines the efficacy of XP, Stephens and Rosenberg [Ste03] argue that many
 XP practices are worthwhile, but others have been overhyped, and a few are prob
lematic. The authors suggest that the codependent nature of XP practices are both
 its strength and its weakness. Because many organizations adopt only a subset of XP
 practices, they weaken the efficacy of the entire process. Proponents counter that
 XP is continuously evolving and that many of the issues raised by critics have been
79
 CHAPTER 3 AGILE DEVELOPMENT
 addressed as XP practice matures. Among the issues that continue to trouble some
 critics of XP are:10
 ?
 What are
 some of the
 issues that lead to
 an XP debate?
 • Requirements volatility. Because the customer is an active member of the XP
 team, changes to requirements are requested informally. As a consequence,
 the scope of the project can change and earlier work may have to be
 modified to accommodate current needs. Proponents argue that this happens
 regardless of the process that is applied and that XP provides mechanisms for
 controlling scope creep.
 • Conflicting customer needs. Many projects have multiple customers, each with
 his own set of needs. In XP, the team itself is tasked with assimilating the
 needs of different customers, a job that may be beyond their scope of
 authority.
 • Requirements are expressed informally. User stories and acceptance tests are
 the only explicit manifestation of requirements in XP. Critics argue that a
 more formal model or specification is often needed to ensure that omissions,
 inconsistencies, and errors are uncovered before the system is built. Propo
nents counter that the changing nature of requirements makes such models
 and specification obsolete almost as soon as they are developed.
 • Lack of formal design. XP deemphasizes the need for architectural design and
 in many instances, suggests that design of all kinds should be relatively
 informal. Critics argue that when complex systems are built, design must be
 emphasized to ensure that the overall structure of the software will exhibit
 quality and maintainability. XP proponents suggest that the incremental
 nature of the XP process limits complexity (simplicity is a core value) and
 therefore reduces the need for extensive design.
 You should note that every software process has flaws and that many software or
ganizations have used XP successfully. The key is to recognize where a process may
 have weaknesses and to adapt it to the specific needs of your organization.
 SAFEHOME
 Considering Agile Software Development
 The scene: Doug Miller’s office.
 The Players: Doug Miller, software engineering
 manager; Jamie Lazar, software team member; Vinod
 Raman, software team member.
 The conversation:
 (A knock on the door, Jamie and Vinod enter Doug’s office)
 Jamie: Doug, you got a minute?
 10 For a detailed look at some thoughtful criticism that has been leveled at XP, visit
 www.softwarereality.com/ExtremeProgramming.jsp.
3.5 OTHERAGILEPROCESSMODELS
 The history of software engineering is littered with dozens of obsolete process
 descriptions and methodologies, modeling methods and notations, tools, and
 technology. Each flared in notoriety and was then eclipsed by something new and
 (purportedly) better. With the introduction of a wide array of agile process models—
 each contending for acceptance within the software development community—the
 agile movement is following the same historical path.11
 As I noted in the last section, the most widely used of all agile process models
 isExtreme Programming (XP). But many other agile process models have been
 proposed and are in use across the industry. Among the most common are:
 •Adaptive Software Development (ASD)
 •Scrum
 •Dynamic Systems Development Method (DSDM)
 80 PART ONE THE SOFTWARE PROCESS
 Doug: Sure Jamie, what’s up?
 Jamie:We’ve been thinking about our process
 discussion yesterday . . . you know, what process we’re
 going to choose for this new SafeHomeproject.
 Doug:And?
 Vinod: I was talking to a friend at another company,
 and he was telling me about Extreme Programming. It’s
 an agile process model . . . heard of it?
 Doug: Yeah, some good, some bad.
 Jamie:Well, it sounds pretty good to us. Lets you
 develop software really fast, uses something called pair
 programming to do real-time quality checks . . . it’s pretty
 cool, I think.
 Doug: It does have a lot of really good ideas. I like the
 pair-programming concept, for instance, and the idea
 that stakeholders should be part of the team.
 Jamie:Huh? You mean that marketing will work on the
 project team with us?
 Doug (nodding): They’re a stakeholder, aren’t they?
 Jamie: Jeez . . . they’ll be requesting changes every five
 minutes.
 Vinod:Not necessarily. My friend said that there are
 ways to “embrace” changes during an XP project.
 Doug: So you guys think we should use XP?
 Jamie: It’s definitely worth considering.
 Doug: I agree. And even if we choose an incremental
 model as our approach, there’s no reason why we can’t
 incorporate much of what XP has to offer.
 Vinod:Doug, before you said “some good, some bad.”
 What was the “bad”?
 Doug: The thing I don’t like is the way XP downplays
 analysis and design . . . sort of says that writing code is
 where the action is . . . 
(The team members look at one another and smile.)
 Doug: So you agree with the XP approach?
 Jamie (speaking for both):Writing code is what
 we do, Boss!
 Doug (laughing): True, but I’d like to see you spend a
 little less time coding and then recoding and a little more
 time analyzing what has to be done and designing a
 solution that works.
 Vinod:Maybe we can have it both ways, agility with a
 little discipline.
 Doug: I think we can, Vinod. In fact, I’m sure of it.
 uote:
 “Our profession
 goes through
 methodologies like
 a 14-year-old goes
 through clothing.”
 Stephen
 Hawrysh and
 JimRuprecht
 11This is not a bad thing. Before one or more models or methods are accepted as a de facto standard,
 all must contend for the hearts and minds of software engineers. The “winners” evolve into best
 practice, while the “losers” either disappear or merge with the winning models.
81
 CHAPTER 3 AGILE DEVELOPMENT
 • Crystal
 • Feature Drive Development (FDD)
 • Lean Software Development (LSD)
 • Agile Modeling (AM)
 • Agile Unified Process (AUP)
 In the sections that follow, I present a very brief overview of each of these agile
 process models. It is important to note that all agile process models conform (to a
 greater or lesser degree) to the Manifesto for Agile Software Development and the prin
ciples noted in Section 3.3.1. For additional detail, refer to the references noted in
 each subsection or for a survey, examine the “agile software development” entry
 in Wikipedia.12
 3.5.1 Adaptive Software Development (ASD)
 WebRef
 Useful resources for
 ASD can be found at
 www.adaptivesd
 .com.
 Adaptive Software Development (ASD) has been proposed by Jim Highsmith [Hig00] as
 a technique for building complex software and systems. The philosophical under
pinnings of ASD focus on human collaboration and team self-organization.
 Highsmith argues that an agile, adaptive development approach based on collab
oration is “as much a source of order in our complex interactions as discipline and
 engineering.” He defines an ASD “life cycle” (Figure 3.3) that incorporates three
 phases, speculation, collaboration, and learning.
 FIGURE 3.3
 Adaptive
 software
 development
 adaptive cycle planning
 mission statement
 project constraints
 basic requirements
 time-boxed release plan
 Release
 Requirements gathering
 JAD
 mini-specs
 speculation
 software increment
 adjustments for subsequent cycles
 collaboration
 components implemented/tested
 focus groups for feedback
 formal technical reviews
 learning
 postmortems
 12 See http://en.wikipedia.org/wiki/Agile_software_development#Agile_methods.
82
 PART ONE THE SOFTWARE PROCESS
 Effective collaboration
 with your customer will
 only occur if you
 jettison any “us and
 them” attitudes.
 ASD emphasizes
 learning as a key
 element in achieving 
a “self-organizing”
 team.
 WebRef
 Useful Scrum
 information and
 resources can be found
 at www
 .controlchaos.com.
 During speculation, the project is initiated and adaptive cycle planning is con
ducted. Adaptive cycle planning uses project initiation information—the customer’s
 mission statement, project constraints (e.g., delivery dates or user descriptions), and
 basic requirements—to define the set of release cycles (software increments) that
 will be required for the project.
 No matter how complete and farsighted the cycle plan, it will invariably change.
 Based on information obtained at the completion of the first cycle, the plan is re
viewed and adjusted so that planned work better fits the reality in which an ASD
 team is working.
 Motivated people use collaboration in a way that multiplies their talent and cre
ative output beyond their absolute numbers. This approach is a recurring theme in
 all agile methods. But collaboration is not easy. It encompasses communication and
 teamwork, but it also emphasizes individualism, because individual creativity plays
 an important role in collaborative thinking. It is, above all, a matter of trust. People
 working together must trust one another to (1) criticize without animosity, (2) assist
 without resentment, (3) work as hard as or harder than they do, (4) have the skill set
 to contribute to the work at hand, and (5) communicate problems or concerns in a
 way that leads to effective action.
 As members of an ASD team begin to develop the components that are part of an
 adaptive cycle, the emphasis is on “learning” as much as it is on progress toward
 a completed cycle. In fact, Highsmith [Hig00] argues that software developers often
 overestimate their own understanding (of the technology, the process, and the proj
ect) and that learning will help them to improve their level of real understanding.
 ASD teams learn in three ways: focus groups (Chapter 5), technical reviews (Chap
ter 14), and project postmortems.
 The ASD philosophy has merit regardless of the process model that is used. ASD’s
 overall emphasis on the dynamics of self-organizing teams, interpersonal collabo
ration, and individual and team learning yield software project teams that have a
 much higher likelihood of success.
 3.5.2 Scrum
 Scrum (the name is derived from an activity that occurs during a rugby match13) is
 an agile software development method that was conceived by Jeff Sutherland and his
 development team in the early 1990s. In recent years, further development on the
 Scrum methods has been performed by Schwaber and Beedle [Sch01a].
 Scrum principles are consistent with the agile manifesto and are used to guide
 development activities within a process that incorporates the following framework
 activities: requirements, analysis, design, evolution, and delivery. Within each
 13 A group of players forms around the ball and the teammates work together (sometimes violently!)
 to move the ball downfield.
every 24
 hours
 30 days
 Scrum: 15 minute daily meeting.
 Team members respond to basics:
 1) What did you do since last Scrum
 meeting?
 2) Do you have any obstacles?
 3) What will you do before next
 meeting?
 Sprint Backlog:
 Feature(s)
 assigned
 to sprint
 Product Backlog:
 Prioritized product features desired by the customer
 Backlog
 items
 expanded
 by team
 New functionality
 is demonstrated
 at end of sprint
 framework activity, work tasks occur within a process pattern (discussed in the fol
lowing paragraph) called a sprint.The work conducted within a sprint (the number
 of sprints required for each framework activity will vary depending on product com
plexity and size) is adapted to the problem at hand and is defined and often modified
 in real time by the Scrum team. The overall flow of the Scrum process is illustrated
 in Figure 3.4.
 Scrum emphasizes the use of a set of software process patterns [Noy02] that have
 proven effective for projects with tight timelines, changing requirements, and business
 criticality. Each of these process patterns defines a set of development actions:
 Backlog—a prioritized list of project requirements or features that provide busi
ness value for the customer. Items can be added to the backlog at any time (this is
 how changes are introduced). The product manager assesses the backlog and
 updates priorities as required.
 Sprints—consist of work units that are required to achieve a requirement de
fined in the backlog that must be fit into a predefined time-box14(typically 30 days).
 CHAPTER 3 AGILE DEVELOPMENT 83
 14A time-boxis a project management term (see Part 4 of this book) that indicates a period of time
 that has been allocated to accomplish some task.
 FIGURE3.4
 Scrum process
 flow
 Scrum incorporates a
 set of process patterns
 that emphasize project
 priorities,
 compartmentalized
 work units,
 communication, and
 frequent customer
 feedback.
84
 PART ONE THE SOFTWARE PROCESS
 Changes (e.g., backlog work items) are not introduced during the sprint. Hence, the
 sprint allows team members to work in a short-term, but stable environment.
 Scrum meetings—are short (typically 15 minutes) meetings held daily by the Scrum
 team. Three key questions are asked and answered by all team members [Noy02]:
 • What did you do since the last team meeting?
 • What obstacles are you encountering?
 • What do you plan to accomplish by the next team meeting?
 A team leader, called a Scrum master, leads the meeting and assesses the responses
 from each person. The Scrum meeting helps the team to uncover potential problems
 as early as possible. Also, these daily meetings lead to “knowledge socialization”
 [Bee99] and thereby promote a self-organizing team structure.
 Demos—deliver the software increment to the customer so that functionality that
 has been implemented can be demonstrated and evaluated by the customer. It is im
portant to note that the demo may not contain all planned functionality, but rather
 those functions that can be delivered within the time-box that was established.
 Beedle and his colleagues [Bee99] present a comprehensive discussion of these pat
terns in which they state: “Scrum assumes up-front the existence of chaos. . . . ” The
 Scrum process patterns enable a software team to work successfully in a world
 where the elimination of uncertainty is impossible.
 3.5.3 Dynamic Systems Development Method (DSDM)
 WebRef
 Useful resources for
 DSSD can be found at
 www.dsdm.org.
 The Dynamic Systems Development Method (DSDM) [Sta97] is an agile software devel
opment approach that “provides a framework for building and maintaining systems
 which meet tight time constraints through the use of incremental prototyping in a con
trolled project environment” [CCS02]. The DSDM philosophy is borrowed from a mod
ified version of the Pareto principle—80 percent of an application can be delivered in
 20 percent of the time it would take to deliver the complete (100 percent) application.
 DSDM is an iterative software process in which each iteration follows the 80 per
cent rule. That is, only enough work is required for each increment to facilitate
 movement to the next increment. The remaining detail can be completed later when
 more business requirements are known or changes have been requested and
 accommodated.
 The DSDM Consortium (www.dsdm.org) is a worldwide group of member com
panies that collectively take on the role of “keeper” of the method. The consortium
 has defined an agile process model, called the DSDM life cycle that defines three dif
ferent iterative cycles, preceded by two additional life cycle activities:
 Feasibility study—establishes the basic business requirements and constraints
 associated with the application to be built and then assesses whether the applica
tion is a viable candidate for the DSDM process.
85
 CHAPTER 3 AGILE DEVELOPMENT
 DSDM is a process
 framework that can
 adopt the tactics of
 another agile approach
 such as XP.
 Crystal is a family of
 process models with
 the same “genetic
 code” but different
 methods for adapting
 to project
 characteristics.
 Business study—establishes the functional and information requirements that
 will allow the application to provide business value; also, defines the basic
 application architecture and identifies the maintainability requirements for the
 application.
 Functional model iteration—produces a set of incremental prototypes that
 demonstrate functionality for the customer. (Note: All DSDM prototypes are in
tended to evolve into the deliverable application.) The intent during this iterative
 cycle is to gather additional requirements by eliciting feedback from users as they
 exercise the prototype.
 Design and build iteration—revisits prototypes built during functional model
 iteration to ensure that each has been engineered in a manner that will enable it to
 provide operational business value for end users. In some cases, functional model
 iteration and design and build iteration occur concurrently.
 Implementation—places the latest software increment (an “operationalized” pro
totype) into the operational environment. It should be noted that (1) the increment
 may not be 100 percent complete or (2) changes may be requested as the incre
ment is put into place. In either case, DSDM development work continues by
 returning to the functional model iteration activity.
 DSDM can be combined with XP (Section 3.4) to provide a combination approach
 that defines a solid process model (the DSDM life cycle) with the nuts and bolts prac
tices (XP) that are required to build software increments. In addition, the ASD con
cepts of collaboration and self-organizing teams can be adapted to a combined
 process model.
 3.5.4 Crystal
 Alistair Cockburn [Coc05] and Jim Highsmith [Hig02b] created the Crystal family of
 agile methods15 in order to achieve a software development approach that puts a
 premium on “maneuverability” during what Cockburn characterizes as “a resource
limited, cooperative game of invention and communication, with a primary goal of
 delivering useful, working software and a secondary goal of setting up for the next
 game” [Coc02].
 To achieve maneuverability, Cockburn and Highsmith have defined a set of
 methodologies, each with core elements that are common to all, and roles, process
 patterns, work products, and practice that are unique to each. The Crystal family is
 actually a set of example agile processes that have been proven effective for differ
ent types of projects. The intent is to allow agile teams to select the member of the
 crystal family that is most appropriate for their project and environment.
 15 The name “crystal” is derived from the characteristics of geological crystals, each with its own
 color, shape, and hardness.
86
 PART ONE THE SOFTWARE PROCESS
 3.5.5 Feature Driven Development (FDD)
 WebRef
 A wide variety of
 articles and
 presentations on FDD
 can be found at:
 www.featuredrive
 ndevelopment
 .com/.
 Feature Driven Development (FDD) was originally conceived by Peter Coad and his
 colleagues [Coa99] as a practical process model for object-oriented software engi
neering. Stephen Palmer and John Felsing [Pal02] have extended and improved
 Coad’s work, describing an adaptive, agile process that can be applied to moderately
 sized and larger software projects.
 Like other agile approaches, FDD adopts a philosophy that (1) emphasizes col
laboration among people on an FDD team; (2) manages problem and project
 complexity using feature-based decomposition followed by the integration of
 software increments, and (3) communication of technical detail using verbal,
 graphical, and text-based means. FDD emphasizes software quality assurance
 activities by encouraging an incremental development strategy, the use of design
 and code inspections, the application of software quality assurance audits (Chap
ter 16), the collection of metrics, and the use of patterns (for analysis, design, and
 construction).
 In the context of FDD, a feature “is a client-valued function that can be imple
mented in two weeks or less” [Coa99]. The emphasis on the definition of features
 provides the following benefits:
 • Because features are small blocks of deliverable functionality, users can
 describe them more easily; understand how they relate to one another more
 readily; and better review them for ambiguity, error, or omissions.
 • Features can be organized into a hierarchical business-related grouping.
 • Since a feature is the FDD deliverable software increment, the team develops
 operational features every two weeks.
 • Because features are small, their design and code representations are easier
 to inspect effectively.
 • Project planning, scheduling, and tracking are driven by the feature
 hierarchy, rather than an arbitrarily adopted software engineering 
task set.
 Coad and his colleagues [Coa99] suggest the following template for defining a
 feature:
 <action> the <result> <by for of to> a(n) <object>
 where an <object> is “a person, place, or thing (including roles, moments in time or
 intervals of time, or catalog-entry-like descriptions).” Examples of features for an 
e-commerce application might be:
 Add the product to shopping cart
 Display the technical-specifications of the product
 Store the shipping-information for the customer
87
 CHAPTER 3 AGILE DEVELOPMENT
 FIGURE 3.5
 Feature Driven
 Development
 [Coa99] (with
 permission)
 Develop
 an
 Overall
 Model
 Build a
 Features
 List
 Plan
 By
 Feature
 Design
 By
 Feature
 (more shape
 than content)
 A list of features
 grouped into sets
 and subject areas
 A development plan
 Class owners
 Feature Set Owners
 A design
 package
 (sequences)
 Build
 By
 Feature
 Completed
 client-value
 function
 A feature set groups related features into business-related categories and is defined
 [Coa99] as:
 <action><-ing> a(n) <object>
 For example: Making a product sale is a feature set that would encompass the fea
tures noted earlier and others.
 The FDD approach defines five “collaborating” [Coa99] framework activities (in
 FDD these are called “processes”) as shown in Figure 3.5.
 FDD provides greater emphasis on project management guidelines and tech
niques than many other agile methods. As projects grow in size and complexity,
 ad hoc project management is often inadequate. It is essential for developers, their
 managers, and other stakeholders to understand project status—what accomplish
ments have been made and problems have been encountered. If deadline pressure
 is significant, it is critical to determine if software increments (features) are properly
 scheduled. To accomplish this, FDD defines six milestones during the design and
 implementation of a feature: “design walkthrough, design, design inspection, code,
 code inspection, promote to build” [Coa99].
 3.5.6 Lean Software Development (LSD)
 Lean Software Development (LSD) has adapted the principles of lean manufacturing
 to the world of software engineering. The lean principles that inspire the LSD process
 can be summarized ([Pop03], [Pop06a]) as eliminate waste, build quality in, create
 knowledge, defer commitment, deliver fast, respect people, and optimize the whole.
 Each of these principles can be adapted to the software process. For example,
 eliminate waste within the context of an agile software project can be interpreted
 to mean [Das05]: (1) adding no extraneous features or functions, (2) assessing the
 cost and schedule impact of any newly requested requirement, (3) removing any
 superfluous process steps, (4) establishing mechanisms to improve the way team
 members find information, (5) ensuring the testing finds as many errors as possible,
88
 PART ONE THE SOFTWARE PROCESS
 (6) reducing the time required to request and get a decision that affects the software
 or the process that is applied to create it, and (7) streamlining the manner in which
 information is transmitted to all stakeholders involved in the process.
 For a detailed discussion of LSD and pragmatic guidelines for implementing the
 process, you should examine [Pop06a] and [Pop06b].
 3.5.7 Agile Modeling (AM)
 WebRef
 Comprehensive
 information on agile
 modeling can be found
 at: www
 .agilemodeling.com.
 uote:
 “I was in the drug
 store the other day
 trying to get a cold
 medication . . . not
 easy. There’s an
 entire wall of
 products you need.
 You stand there
 going, Well, this
 one is quick acting
 but this is long
 lasting. . . . Which
 is more important,
 the present or the
 future?”
 Jerry Seinfeld
 There are many situations in which software engineers must build large, business
critical systems. The scope and complexity of such systems must be modeled so that
 (1) all constituencies can better understand what needs to be accomplished, (2) the
 problem can be partitioned effectively among the people who must solve it, and
 (3) quality can be assessed as the system is being engineered and built.
 Over the past 30 years, a wide variety of software engineering modeling methods
 and notation have been proposed for analysis and design (both architectural and
 component-level). These methods have merit, but they have proven to be difficult
 to apply and challenging to sustain (over many projects). Part of the problem is the
 “weight” of these modeling methods. By this I mean the volume of notation required,
 the degree of formalism suggested, the sheer size of the models for large projects,
 and the difficulty in maintaining the model(s) as changes occur. Yet analysis and de
sign modeling have substantial benefit for large projects—if for no other reason than
 to make these projects intellectually manageable. Is there an agile approach to soft
ware engineering modeling that might provide an alternative?
 At “The Official Agile Modeling Site,” Scott Ambler [Amb02a] describes agile mod
eling (AM) in the following manner:
 Agile Modeling (AM) is a practice-based methodology for effective modeling and documen
tation of software-based systems. Simply put, Agile Modeling (AM) is a collection of values,
 principles, and practices for modeling software that can be applied on a software develop
ment project in an effective and light-weight manner. Agile models are more effective than
 traditional models because they are just barely good, they don’t have to be perfect.
 Agile modeling adopts all of the values that are consistent with the agile manifesto.
 The agile modeling philosophy recognizes that an agile team must have the courage
 to make decisions that may cause it to reject a design and refactor. The team must
 also have the humility to recognize that technologists do not have all the answers and
 that business experts and other stakeholders should be respected and embraced.
 Although AM suggests a wide array of “core” and “supplementary” modeling prin
ciples, those that make AM unique are [Amb02a]:
 Model with a purpose. A developer who uses AM should have a specific
 goal (e.g., to communicate information to the customer or to help better un
derstand some aspect of the software) in mind before creating the model.
 Once the goal for the model is identified, the type of notation to be used and
 level of detail required will be more obvious.
89
 CHAPTER 3 AGILE DEVELOPMENT
 Use multiple models. There are many different models and notations that
 can be used to describe software. Only a small subset is essential for most
 projects. AM suggests that to provide needed insight, each model should
 present a different aspect of the system and only those models that provide
 value to their intended audience should be used.
 “Traveling light” is an
 appropriate philosophy
 for all software engi
neering work. Build
 only those models that
 provide value … no
 more, no less.
 Travel light. As software engineering work proceeds, keep only those mod
els that will provide long-term value and jettison the rest. Every work product
 that is kept must be maintained as changes occur. This represents work that
 slows the team down. Ambler [Amb02a] notes that “Every time you decide to
 keep a model you trade-off agility for the convenience of having that informa
tion available to your team in an abstract manner (hence potentially enhanc
ing communication within your team as well as with project stakeholders).”
 Content is more important than representation. Modeling should im
part information to its intended audience. A syntactically perfect model that
 imparts little useful content is not as valuable as a model with flawed nota
tion that nevertheless provides valuable content for its audience.
 Know the models and the tools you use to create them. Understand
 the strengths and weaknesses of each model and the tools that are used to
 create it.
 Adapt locally. The modeling approach should be adapted to the needs of
 the agile team.
 A major segment of the software engineering community has adopted the Unified
 Modeling Language (UML)16 as the preferred method for representing analysis and
 design models. The Unified Process (Chapter 2) has been developed to provide a
 framework for the application of UML. Scott Ambler [Amb06] has developed a sim
plified version of the UP that integrates his agile modeling philosophy.
 3.5.8 Agile Unified Process (AUP)
 The Agile Unified Process (AUP) adopts a “serial in the large” and “iterative in the
 small” [Amb06] philosophy for building computer-based systems. By adopting the
 classic UP phased activities—inception, elaboration, construction, and transition—AUP
 provides a serial overlay (i.e., a linear sequence of software engineering activities)
 that enables a team to visualize the overall process flow for a software project. How
ever, within each of the activities, the team iterates to achieve agility and to deliver
 meaningful software increments to end users as rapidly as possible. Each AUP iter
ation addresses the following activities [Amb06]: 
• Modeling. UML representations of the business and problem domains are
 created. However, to stay agile, these models should be “just barely good
 enough” [Amb06] to allow the team to proceed.
 16 A brief tutorial on UML is presented in Appendix 1.
90
 PART ONE THE SOFTWARE PROCESS
 • Implementation. Models are translated into source code.
 • Testing. Like XP, the team designs and executes a series of tests to uncover
 errors and ensure that the source code meets its requirements.
 • Deployment. Like the generic process activity discussed in Chapters 1 and 2,
 deployment in this context focuses on the delivery of a software increment
 and the acquisition of feedback from end users.
 • Configuration and project management. In the context of AUP, configuration
 management (Chapter 22) addresses change management, risk manage
ment, and the control of any persistent work products17 that are produced by
 the team. Project management tracks and controls the progress of the team
 and coordinates team activities.
 • Environment management. Environment management coordinates a process
 infrastructure that includes standards, tools, and other support technology
 available to the team.
 Although the AUP has historical and technical connections to the Unified Modeling
 Language, it is important to note that UML modeling can be using in conjunction
 with any of the agile process models described in Section 3.5.
 SOFTWARE TOOLS
 Agile Development
 Objective: The objective of agile development
 tools is to assist in one or more aspects of agile
 development with an emphasis on facilitating the rapid
 generation of operational software. These tools can also
 be used when prescriptive process models (Chapter 2) are
 applied.
 Mechanics: Tool mechanics vary. In general, agile tool
 sets encompass automated support for project planning,
 use case development and requirements gathering, rapid
 design, code generation, and testing.
 Representative Tools:18
 Note: Because agile development is a hot topic, most
 software tools vendors purport to sell tools that support 
the agile approach. The tools noted here have
 characteristics that make them particularly useful for
 agile projects.
 OnTime, developed by Axosoft (www.axosoft.com),
 provides agile process management support for
 various technical activities within the process.
 Ideogramic UML, developed by Ideogramic
 (www.ideogramic.com) is a UML tool set
 specifically developed for use within an agile 
process.
 Together Tool Set, distributed by Borland
 (www.borland.com), provides a tools suite that
 supports many technical activities within XP and other
 agile processes.
 17 A persistent work product is a model or document or test case produced by the team that will be kept
 for an indeterminate period of time. It will not be discarded once the software increment is
 delivered.
 18 Tools noted here do not represent an endorsement, but rather a sampling of tools in this category.
 In most cases, tool names are trademarked by their respective developers.
91
 CHAPTER 3 AGILE DEVELOPMENT
 3.6 A TOOL SET FOR THE AGILE PROCESS
 The “tool set” that
 supports agile
 processes focuses
 more on people issues
 than it does on
 technology issues.
 Some proponents of the agile philosophy argue that automated software tools (e.g.,
 design tools) should be viewed as a minor supplement to the team’s activities, and
 not at all pivotal to the success of the team. However, Alistair Cockburn [Coc04] sug
gests that tools can have a benefit and that “agile teams stress using tools that per
mit the rapid flow of understanding. Some of those tools are social, starting even at
 the hiring stage. Some tools are technological, helping distributed teams simulate
 being physically present. Many tools are physical, allowing people to manipulate
 them in workshops.”
 Because acquiring the right people (hiring), team collaboration, stakeholder com
munication, and indirect management are key elements in virtually all agile process
 models, Cockburn argues that “tools” that address these issues are critical success
 factors for agility. For example, a hiring “tool” might be the requirement to have a
 prospective team member spend a few hours pair programming with an existing
 member of the team. The “fit” can be assessed immediately.
 Collaborative and communication “tools” are generally low tech and incorporate
 any mechanism (“physical proximity, whiteboards, poster sheets, index cards, and
 sticky notes” [Coc04]) that provides information and coordination among agile de
velopers. Active communication is achieved via the team dynamics (e.g., pair pro
gramming), while passive communication is achieved by “information radiators”
 (e.g., a flat panel display that presents the overall status of different components of
 an increment). Project management tools deemphasize the Gantt chart and replace
 it with earned value charts or “graphs of tests created versus passed . . . other agile
 tools are used to optimize the environment in which the agile team works (e.g., more
 efficient meeting areas), improve the team culture by nurturing social interactions
 (e.g., collocated teams), physical devices (e.g., electronic whiteboards), and process
 enhancement (e.g., pair programming or time-boxing)” [Coc04].
 Are any of these things really tools? They are, if they facilitate the work performed
 by an agile team member and enhance the quality of the end product.
 3.7 SUMMARY
 In a modern economy, market conditions change rapidly, customer and end-user
 needs evolve, and new competitive threats emerge without warning. Practitioners
 must approach software engineering in a manner that allows them to remain agile—
 to define maneuverable, adaptive, lean processes that can accommodate the needs
 of modern business.
 An agile philosophy for software engineering stresses four key issues: the impor
tance of self-organizing teams that have control over the work they perform, com
munication and collaboration between team members and between practitioners
 and their customers, a recognition that change represents an opportunity, and
92
 PART ONE THE SOFTWARE PROCESS
 an emphasis on rapid delivery of software that satisfies the customer. Agile process
 models have been designed to address each of these issues.
 Extreme programming (XP) is the most widely used agile process. Organized as
 four framework activities—planning, design, coding, and testing—XP suggests a
 number of innovative and powerful techniques that allow an agile team to create
 frequent software releases that deliver features and functionality that have been de
scribed and then prioritized by stakeholders.
 Other agile process models also stress human collaboration and team self
organization, but define their own framework activities and select different points of
 emphasis. For example, ASD uses an iterative process that incorporates adaptive
 cycle planning, relatively rigorous requirement gathering methods, and an iterative
 development cycle that incorporates customer focus groups and formal technical re
views as real-time feedback mechanisms. Scrum emphasizes the use of a set of soft
ware process patterns that have proven effective for projects with tight time lines,
 changing requirements, and business criticality. Each process pattern defines a set
 of development tasks and allows the Scrum team to construct a process that is
 adapted to the needs of the project. The Dynamic Systems Development Method
 (DSDM) advocates the use of time-box scheduling and suggests that only enough
 work is required for each software increment to facilitate movement to the next
 increment. Crystal is a family of agile process models that can be adopted to the spe
cific characteristics of a project.
 Feature Driven Development (FDD) is somewhat more “formal” than other agile
 methods, but still maintains agility by focusing the project team on the development
 of features—a client-valued function that can be implemented in two weeks or less.
 Lean Software Development (LSD) has adapted the principles of lean manufacturing
 to the world of software engineering. Agile modeling (AM) suggests that modeling is
 essential for all systems, but that the complexity, type, and size of the model must be
 tuned to the software to be built. The Agile Unified Process (AUP) adopts a “serial in
 the large” and “iterative in the small” philosophy for building software.
 PROBLEMS AND POINTS TO PONDER
 3.1. Reread “The Manifesto for Agile Software Development” at the beginning of this chapter.
 Can you think of a situation in which one or more of the four “values” could get a software team
 into trouble?
 3.2. Describe agility (for software projects) in your own words.
 3.3. Why does an iterative process make it easier to manage change? Is every agile process dis
cussed in this chapter iterative? Is it possible to complete a project in just one iteration and still
 be agile? Explain your answers.
 3.4. Could each of the agile processes be described using the generic framework activities
 noted in Chapter 2? Build a table that maps the generic activities into the activities defined for
 each agile process.
 3.5. Try to come up with one more “agility principle” that would help a software engineering
 team become even more maneuverable.
93
 CHAPTER 3 AGILE DEVELOPMENT
 3.6. Select one agility principle noted in Section 3.3.1 and try to determine whether each of the
 process models presented in this chapter exhibits the principle. [Note: I have presented an
 overview of these process models only, so it may not be possible to determine whether a prin
ciple has been addressed by one or more of the models, unless you do additional research
 (which is not required for this problem).]
 3.7. Why do requirements change so much? After all, don’t people know what they want?
 3.8. Most agile process models recommend face-to-face communication. Yet today, members
 of a software team and their customers may be geographically separated from one another. Do
 you think this implies that geographical separation is something to avoid? Can you think of ways
 to overcome this problem?
 3.9. Write an XP user story that describes the “favorite places” or “bookmarks” feature avail
able on most Web browsers.
 3.10. What is a spike solution in XP?
 3.11. Describe the XP concepts of refactoring and pair programming in your own words.
 3.12. Do a bit more reading and describe what a time-box is. How does this assist an ASD team
 in delivering software increments in a short time period?
 3.13. Do the 80 percent rule in DSDM and the time-boxing approach defined for ASD achieve
 the same result?
 3.14. Using the process pattern template presented in Chapter 2, develop a process pattern for
 any one of the Scrum patterns presented in Section 3.5.2.
 3.15. Why is Crystal called a family of agile methods?
 3.16. Using the FDD feature template described in Section 3.5.5, define a feature set for a Web
 browser. Now develop a set of features for the feature set.
 3.17. Visit the Official Agile Modeling Site and make a complete list of all core and supple
mentary AM principles.
 3.18. The tool set proposed in Section 3.6 supports many of the “soft” aspects of agile meth
ods. Since communication is so important, recommend an actual tool set that might be used to
 enhance communication among stakeholders on an agile team.
 FURTHER READINGS AND INFORMATION SOURCES
 The overall philosophy and underlying principles of agile software development are considered
 in depth in many of the books referenced in the body of this chapter. In addition, books by Shaw
 and Warden (The Art of Agile Development, O’Reilly Media, Inc., 2008), Hunt (Agile Software Con
struction, Springer, 2005), and Carmichael and Haywood (Better Software Faster, Prentice-Hall,
 2002) present useful discussions of the subject. Aguanno (Managing Agile Projects, Multi
Media Publications, 2005), Highsmith (Agile Project Management: Creating Innovative Products,
 Addison-Wesley, 2004), and Larman (Agile and Iterative Development: A Manager’s Guide,
 Addison-Wesley, 2003) present a management overview and consider project management
 issues. Highsmith (Agile Software Development Ecosystems, Addison-Wesley, 2002) presents a
 survey of agile principles, processes, and practices. A worthwhile discussion of the delicate bal
ance between agility and discipline is presented by Booch and his colleagues (Balancing Agility
 and Discipline, Addison-Wesley, 2004).
 Martin (Clean Code: A Handbook of Agile Software Craftsmanship, Prentice-Hall, 2009) pres
ents the principles, patterns, and practices required to develop “clean code” in an agile software
 engineering environment. Leffingwell (Scaling Software Agility: Best Practices for Large Enter
prises, Addison-Wesley, 2007) discusses strategies for scaling up agile practices for large proj
ects. Lippert and Rook (Refactoring in Large Software Projects: Performing Complex Restructurings
 Successfully, Wiley, 2006) discuss the use of refactoring when applied in large, complex systems.
94
 PART ONE THE SOFTWARE PROCESS
 Stamelos and Sfetsos (Agile Software Development Quality Assurance, IGI Global, 2007) discuss
 SQA techniques that conform to the agile philosophy.
 Dozens of books have been written about Extreme Programming over the past decade. Beck
 (Extreme Programming Explained: Embrace Change, 2d ed., Addison-Wesley, 2004) remains the
 definitive treatment of the subject. In addition, Jeffries and his colleagues (Extreme Programming
 Installed, Addison-Wesley, 2000), Succi and Marchesi (Extreme Programming Examined,
 Addison-Wesley, 2001), Newkirk and Martin (Extreme Programming in Practice, Addison-Wesley,
 2001), and Auer and his colleagues (Extreme Programming Applied: Play to Win, Addison-Wesley,
 2001) provide a nuts-and-bolts discussion of XP along with guidance on how best to apply it.
 McBreen (Questioning Extreme Programming, Addison-Wesley, 2003) takes a critical look at XP,
 defining when and where it is appropriate. An in-depth consideration of pair programming is
 presented by McBreen (Pair Programming Illuminated, Addison-Wesley, 2003).
 ASD is addressed in depth by Highsmith [Hig00]. Schwaber (The Enterprise and Scrum,
 Microsoft Press, 2007) discusses the use of Scrum for projects that have a major business
 impact. The nuts and bolts of Scrum are discussed by Schwaber and Beedle (Agile Software
 Development with SCRUM, Prentice-Hall, 2001). Worthwhile treatments of DSDM have been
 written by the DSDM Consortium (DSDM: Business Focused Development, 2d ed., Pearson Edu
cation, 2003) and Stapleton (DSDM: The Method in Practice, Addison-Wesley, 1997). Cockburn
 (Crystal Clear, Addison-Wesley, 2005) presents an excellent overview of the Crystal family of
 processes. Palmer and Felsing [Pal02] present a detailed treatment of FDD. Carmichael and
 Haywood (Better Software Faster, Prentice-Hall, 2002) provides another useful treatment of FDD
 that includes a step-by-step journey through the mechanics of the process. Poppendieck and 
Poppendieck (Lean Development: An Agile Toolkit for Software Development Managers, Addison
Wesley, 2003) provide guidelines for managing and controlling agile projects. Ambler and
 Jeffries (Agile Modeling, Wiley, 2002) discuss AM in some depth.
 A wide variety of information sources on agile software development are available on the
 Internet. An up-to-date list of World Wide Web references that are relevant to the agile process
 can be found at the SEPA website: www.mhhe.com/engcs/compsci/pressman/
 professional/olc/ser.htm.
In 2001, Kent Beck and 16 other noted software developers, writers, and con
sultants [Bec01a] (referred to as the “Agile Alliance”) signed the “Manifesto for
 Agile Software Development.” It stated:
 We are uncovering better ways of developing software by doing it and helping others
 do it. Through this work we have come to value: 
Individuals and interactions over processes and tools
 Working software over comprehensive documentation
 Customer collaboration over contract negotiation
 Responding to change over following a plan
 That is, while there is value in the items on the right, we value the items on the 
left more.
 QUICK
 LOOK
 What is it? Agile software engi
neering combines a philosophy and
 a set of development guidelines. The
 philosophy encourages customer
 satisfaction and early incremental delivery of
 software; small, highly motivated project teams;
 informal methods; minimal software engineer
ing work products; and overall development
 simplicity. The development guidelines stress
 delivery over analysis and design (although
 these activities are not discouraged), and active
 and continuous communication between devel
opers and customers.
 Who does it? Software engineers and other
 project stakeholders (managers, customers, end
 users) work together on an agile team—a team
 that is self-organizing and in control of its own
 destiny. An agile team fosters communication
 and collaboration among all who serve on it.
 Why is it important? The modern business envi
ronment that spawns computer-based systems
 and software products is fast-paced and ever
changing. Agile software engineering repre
sents a reasonable alternative to conventional
 software engineering for certain classes of soft
ware and certain types of software projects. It
 has been demonstrated to deliver successful sys
tems quickly.
 Whatarethesteps? Agiledevelopmentmightbest
 be termed “software engineering lite.” The basic
 framework activities—communication, planning,
 modeling, construction, and deployment—
 remain. But they morph into a minimal task set
 that pushes the project team toward construction
 and delivery (some would argue that this is
 done at the expense of problem analysis and
 solution design).
 What is the work product? Both the customer
 and the software engineer have the same
 view—the only really important work product
 is an operational “software increment” that is
 delivered to the customer on the appropriate
 commitment date.
 How do I ensure that I’ve done it right? If the
 agile team agrees that the process works, and
 the team produces deliverable software
 increments that satisfy the customer, you’ve
 done it right.
 65
66
 PART ONE THE SOFTWARE PROCESS
 FDD . . . . . . . . . .86
 Industrial XP . . .77
 Lean Software
 Development . . .87
 pair 
programming . . .76
 project 
velocity . . . . . . .74
 refactoring . . . . .75
 Scrum . . . . . . . .82
 stories . . . . . . . .74
 XP process . . . . .73
 uote:
 “Agility: 1,
 everything else: 0.”
 Tom DeMarco
 A manifesto is normally associated with an emerging political movement—one
 that attacks the old guard and suggests revolutionary change (hopefully for the
 better). In some ways, that’s exactly what agile development is all about.
 Although the underlying ideas that guide agile development have been with us for
 many years, it has been less than two decades since these ideas have crystallized
 into a “movement.” In essence, agile1 methods were developed in an effort to over
come perceived and actual weaknesses in conventional software engineering. Agile
 development can provide important benefits, but it is not applicable to all projects,
 all products, all people, and all situations. It is also not antithetical to solid software
 engineering practice and can be applied as an overriding philosophy for all software
 work.
 In the modern economy, it is often difficult or impossible to predict how a
 computer-based system (e.g., a Web-based application) will evolve as time passes.
 Market conditions change rapidly, end-user needs evolve, and new competitive
 threats emerge without warning. In many situations, you won’t be able to define
 requirements fully before the project begins. You must be agile enough to respond to
 a fluid business environment.
 Fluidity implies change, and change is expensive. Particularly if it is uncontrolled
 or poorly managed. One of the most compelling characteristics of the agile approach
 is its ability to reduce the costs of change throughout the software process.
 Does this mean that a recognition of challenges posed by modern realities causes
 you to discard valuable software engineering principles, concepts, methods, and
 tools? Absolutely not! Like all engineering disciplines, software engineering contin
ues to evolve. It can be adapted easily to meet the challenges posed by a demand for
 agility.
 In a thought-provoking book on agile software development, Alistair Cockburn
 [Coc02] argues that the prescriptive process models introduced in Chapter 2 have a
 major failing: they forget the frailties of the people who build computer software. Software
 engineers are not robots. They exhibit great variation in working styles; significant dif
ferences in skill level, creativity, orderliness, consistency, and spontaneity. Some com
municate well in written form, others do not. Cockburn argues that process models
 can “deal with people’s common weaknesses with [either] discipline or tolerance” and
 that most prescriptive process models choose discipline. He states: “Because consis
tency in action is a human weakness, high discipline methodologies are fragile.”
 If process models are to work, they must provide a realistic mechanism for en
couraging the discipline that is necessary, or they must be characterized in a man
ner that shows “tolerance” for the people who do software engineering work.
 Invariably, tolerant practices are easier for software people to adopt and sustain, but
 (as Cockburn admits) they may be less productive. Like most things in life, trade-offs
 must be considered.
 1 Agile methods are sometimes referred to as light methods or lean methods.
67
 CHAPTER 3 AGILE DEVELOPMENT
 3.1 WHAT IS AGILITY?
 Just what is agility in the context of software engineering work? Ivar Jacobson
 [Jac02a] provides a useful discussion:
 Agility has become today’s buzzword when describing a modern software process. Every
one is agile. An agile team is a nimble team able to appropriately respond to changes.
 Change is what software development is very much about. Changes in the software be
ing built, changes to the team members, changes because of new technology, changes of
 all kinds that may have an impact on the product they build or the project that creates the
 product. Support for changes should be built-in everything we do in software, something
 we embrace because it is the heart and soul of software. An agile team recognizes that
 software is developed by individuals working in teams and that the skills of these people,
 their ability to collaborate is at the core for the success of the project.
 Don’t make the
 mistake of assuming
 that agility gives you
 license to hack out
 solutions. A process is
 required and discipline
 is essential.
 In Jacobson’s view, the pervasiveness of change is the primary driver for agility. Soft
ware engineers must be quick on their feet if they are to accommodate the rapid
 changes that Jacobson describes.
 But agility is more than an effective response to change. It also encompasses the
 philosophy espoused in the manifesto noted at the beginning of this chapter. It
 encourages team structures and attitudes that make communication (among team
 members, between technologists and business people, between software engineers
 and their managers) more facile. It emphasizes rapid delivery of operational soft
ware and de-emphasizes the importance of intermediate work products (not always
 a good thing); it adopts the customer as a part of the development team and works
 to eliminate the “us and them” attitude that continues to pervade many software
 projects; it recognizes that planning in an uncertain world has its limits and that a
 project plan must be flexible.
 Agility can be applied to any software process. However, to accomplish this, it is
 essential that the process be designed in a way that allows the project team to adapt
 tasks and to streamline them, conduct planning in a way that understands the fluid
ity of an agile development approach, eliminate all but the most essential work prod
ucts and keep them lean, and emphasize an incremental delivery strategy that gets
 working software to the customer as rapidly as feasible for the product type and
 operational environment.
 3.2 AGILITY AND THE COST OF CHANGE
 The conventional wisdom in software development (supported by decades of expe
rience) is that the cost of change increases nonlinearly as a project progresses
 (Figure 3.1, solid black curve). It is relatively easy to accommodate a change when a
 software team is gathering requirements (early in a project). A usage scenario might
 have to be modified, a list of functions may be extended, or a written specification
 can be edited. The costs of doing this work are minimal, and the time required will
68
 PART ONE THE SOFTWARE PROCESS
 FIGURE 3.1
 Change costs
 as a function
 of time in
 development
 uote:
 Development cost
 Cost of change
 using conventional
 software processes
 Cost of change
 using agile processes
 “Agility is dynamic,
 content specific,
 aggressively
 change embracing,
 and growth
 oriented.”
 Idealized cost of change
 using agile process
 Development schedule progress–Steven
 Goldman et al.
 An agile process
 reduces the cost of
 change because
 software is released in
 increments and change
 can be better
 controlled within an
 increment.
 not adversely affect the outcome of the project. But what if we fast-forward a num
ber of months? The team is in the middle of validation testing (something that occurs
 relatively late in the project), and an important stakeholder is requesting a major
 functional change. The change requires a modification to the architectural design of
 the software, the design and construction of three new components, modifications
 to another five components, the design of new tests, and so on. Costs escalate
 quickly, and the time and cost required to ensure that the change is made without
 unintended side effects is nontrivial.
 Proponents of agility (e.g., [Bec00], [Amb04]) argue that a well-designed agile
 process “flattens” the cost of change curve (Figure 3.1, shaded, solid curve), allowing
 a software team to accommodate changes late in a software project without dramatic
 cost and time impact. You’ve already learned that the agile process encompasses in
cremental delivery. When incremental delivery is coupled with other agile practices
 such as continuous unit testing and pair programming (discussed later in this chap
ter), the cost of making a change is attenuated. Although debate about the degree to
 which the cost curve flattens is ongoing, there is evidence [Coc01a] to suggest that a
 significant reduction in the cost of change can be achieved.
 3.3 WHAT IS ANAGILE PROCESS?
 Any agile software process is characterized in a manner that addresses a number of
 key assumptions [Fow02] about the majority of software projects: 
1. It is difficult to predict in advance which software requirements will persist
 and which will change. It is equally difficult to predict how customer
 priorities will change as the project proceeds.
69
 CHAPTER 3 AGILE DEVELOPMENT
 WebRef
 A comprehensive
 collection of articles on
 the agile process 
can be found at
 www.aanpo.org/
 articles/index.
 Although agile
 processes embrace
 change, it is still
 important to examine
 the reasons for
 change.
 Working software is
 important, but don’t
 forget that it must also
 exhibit a variety of
 quality attributes
 including reliability,
 usability, and 
maintainability.
 2. For many types of software, design and construction are interleaved. That is,
 both activities should be performed in tandem so that design models are
 proven as they are created. It is difficult to predict how much design is
 necessary before construction is used to prove the design.
 3. Analysis, design, construction, and testing are not as predictable (from a
 planning point of view) as we might like.
 Given these three assumptions, an important question arises: How do we create a
 process that can manage unpredictability? The answer, as I have already noted, lies
 in process adaptability (to rapidly changing project and technical conditions). An
 agile process, therefore, must be adaptable.
 But continual adaptation without forward progress accomplishes little. Therefore,
 an agile software process must adapt incrementally. To accomplish incremental adap
tation, an agile team requires customer feedback (so that the appropriate adaptations
 can be made). An effective catalyst for customer feedback is an operational prototype
 or a portion of an operational system. Hence, an incremental development strategy
 should be instituted. Software increments (executable prototypes or portions of an op
erational system) must be delivered in short time periods so that adaptation keeps pace
 with change (unpredictability). This iterative approach enables the customer to evalu
ate the software increment regularly, provide necessary feedback to the software team,
 and influence the process adaptations that are made to accommodate the feedback.
 3.3.1 Agility Principles
 The Agile Alliance (see [Agi03], [Fow01]) defines 12 agility principles for those who
 want to achieve agility: 
1. Our highest priority is to satisfy the customer through early and continuous
 delivery of valuable software.
 2. Welcome changing requirements, even late in development. Agile processes
 harness change for the customer’s competitive advantage.
 3. Deliver working software frequently, from a couple of weeks to a couple of
 months, with a preference to the shorter timescale.
 4. Business people and developers must work together daily throughout the
 project.
 5. Build projects around motivated individuals. Give them the environment and
 support they need, and trust them to get the job done.
 6. The most efficient and effective method of conveying information to and
 within a development team is face-to-face conversation.
 7. Working software is the primary measure of progress.
 8. Agile processes promote sustainable development. The sponsors, developers,
 and users should be able to maintain a constant pace indefinitely.
70
 PART ONE THE SOFTWARE PROCESS
 9. Continuous attention to technical excellence and good design enhances
 agility.
 10. Simplicity—the art of maximizing the amount of work not done—is 
essential.
 11. The best architectures, requirements, and designs emerge from self
organizing teams.
 12. At regular intervals, the team reflects on how to become more effective, then
 tunes and adjusts its behavior accordingly.
 Not every agile process model applies these 12 principles with equal weight, and
 some models choose to ignore (or at least downplay) the importance of one or more
 of the principles. However, the principles define an agile spirit that is maintained in
 each of the process models presented in this chapter.
 3.3.2 The Politics of Agile Development
 You don’t have to
 choose between agility
 and software engi
neering. Rather, define
 a software engineering
 approach that is agile.
 There is considerable debate (sometimes strident) about the benefits and applicabil
ity of agile software development as opposed to more conventional software engi
neering processes. Jim Highsmith [Hig02a] (facetiously) states the extremes when he
 characterizes the feeling of the pro-agility camp (“agilists”). “Traditional methodolo
gists are a bunch of stick-in-the-muds who’d rather produce flawless documentation
 than a working system that meets business needs.” As a counterpoint, he states
 (again, facetiously) the position of the traditional software engineering camp: “Light
weight, er, ‘agile’ methodologists are a bunch of glorified hackers who are going to
 be in for a heck of a surprise when they try to scale up their toys into enterprise-wide
 software.”
 Like all software technology arguments, this methodology debate risks degener
ating into a religious war. If warfare breaks out, rational thought disappears and
 beliefs rather than facts guide decision making.
 No one is against agility. The real question is: What is the best way to achieve it?
 As important, how do you build software that meets customers’ needs today and
 exhibits the quality characteristics that will enable it to be extended and scaled to
 meet customers’ needs over the long term?
 There are no absolute answers to either of these questions. Even within the agile
 school itself, there are many proposed process models (Section 3.4), each with a
 subtly different approach to the agility problem. Within each model there is a set of
 “ideas” (agilists are loath to call them “work tasks”) that represent a significant
 departure from traditional software engineering. And yet, many agile concepts are
 simply adaptations of good software engineering concepts. Bottom line: there is
 much that can be gained by considering the best of both schools and virtually
 nothing to be gained by denigrating either approach.
 If you have further interest, see [Hig01], [Hig02a], and [DeM02] for an entertain
ing summary of other important technical and political issues.
71
 CHAPTER 3 AGILE DEVELOPMENT
 uote:
 “Agile methods
 derive much of
 their agility by
 relying on the
 tacit knowledge
 embodied in the
 team, rather than
 writing the
 knowledge down
 in plans.”
 Barry Boehm
 ?
 What key
 traits must
 exist among the
 people on an
 effective software
 team?
 uote:
 “What counts as
 barely sufficient
 for one team is
 either overly
 sufficient or
 insufficient for
 another.”
 Alistair
 Cockburn
 3.3.3 Human Factors
 Proponents of agile software development take great pains to emphasize the impor
tance of “people factors.” As Cockburn and Highsmith [Coc01a] state, “Agile devel
opment focuses on the talents and skills of individuals, molding the process to
 specific people and teams.” The key point in this statement is that the process molds
 to the needs of the people and team, not the other way around.2
 If members of the software team are to drive the characteristics of the process that
 is applied to build software, a number of key traits must exist among the people on
 an agile team and the team itself:
 Competence. In an agile development (as well as software engineering)
 context, “competence” encompasses innate talent, specific software-related
 skills, and overall knowledge of the process that the team has chosen to
 apply. Skill and knowledge of process can and should be taught to all people
 who serve as agile team members.
 Common focus. Although members of the agile team may perform differ
ent tasks and bring different skills to the project, all should be focused on one
 goal—to deliver a working software increment to the customer within the
 time promised. To achieve this goal, the team will also focus on continual
 adaptations (small and large) that will make the process fit the needs of the
 team.
 Collaboration. Software engineering (regardless of process) is about as
sessing, analyzing, and using information that is communicated to the soft
ware team; creating information that will help all stakeholders understand
 the work of the team; and building information (computer software and rele
vant databases) that provides business value for the customer. To accomplish
 these tasks, team members must collaborate—with one another and all other
 stakeholders.
 Decision-making ability. Any good software team (including agile teams)
 must be allowed the freedom to control its own destiny. This implies that the
 team is given autonomy—decision-making authority for both technical and
 project issues.
 Fuzzy problem-solving ability. Software managers must recognize that
 the agile team will continually have to deal with ambiguity and will continu
ally be buffeted by change. In some cases, the team must accept the fact that
 the problem they are solving today may not be the problem that needs to be
 solved tomorrow. However, lessons learned from any problem-solving
 2 Successful software engineering organizations recognize this reality regardless of the process
 model they choose.
72
 PART ONE THE SOFTWARE PROCESS
 A self-organizing team
 is in control of the
 work it performs. The
 team makes its own
 commitments and
 defines plans to
 achieve them.
 activity (including those that solve the wrong problem) may be of benefit to
 the team later in the project.
 Mutual trust and respect. The agile team must become what DeMarco
 and Lister [DeM98] call a “jelled” team (Chapter 24). A jelled team exhibits
 the trust and respect that are necessary to make them “so strongly knit that
 the whole is greater than the sum of the parts.” [DeM98]
 Self-organization. In the context of agile development, self-organization
 implies three things: (1) the agile team organizes itself for the work to be
 done, (2) the team organizes the process to best accommodate its local envi
ronment, (3) the team organizes the work schedule to best achieve delivery
 of the software increment. Self-organization has a number of technical bene
fits, but more importantly, it serves to improve collaboration and boost team
 morale. In essence, the team serves as its own management. Ken Schwaber
 [Sch02] addresses these issues when he writes: “The team selects how much
 work it believes it can perform within the iteration, and the team commits to
 the work. Nothing demotivates a team as much as someone else making
 commitments for it. Nothing motivates a team as much as accepting the
 responsibility for fulfilling commitments that it made itself.”
 3.4 EXTREME PROGRAMMING (XP)
 In order to illustrate an agile process in a bit more detail, I’ll provide you with an
 overview of Extreme Programming (XP), the most widely used approach to agile soft
ware development. Although early work on the ideas and methods associated with
 XP occurred during the late 1980s, the seminal work on the subject has been written
 by Kent Beck [Bec04a]. More recently, a variant of XP, called Industrial XP (IXP) has
 been proposed [Ker05]. IXP refines XP and targets the agile process specifically for
 use within large organizations.
 3.4.1 XP Values
 Beck [Bec04a] defines a set of five values that establish a foundation for all work per
formed as part of XP—communication, simplicity, feedback, courage, and respect. Each
 of these values is used as a driver for specific XP activities, actions, and tasks.
 In order to achieve effective communication between software engineers and
 other stakeholders (e.g., to establish required features and functions for the soft
ware), XP emphasizes close, yet informal (verbal) collaboration between customers
 and developers, the establishment of effective metaphors3 for communicating
 important concepts, continuous feedback, and the avoidance of voluminous docu
mentation as a communication medium.
 3 In the XP context, a metaphor is “a story that everyone—customers, programmers, and managers—
 can tell about how the system works” [Bec04a].
73
 CHAPTER 3 AGILE DEVELOPMENT
 Keep it simple
 whenever you can, but
 recognize that
 continual “refactoring”
 can absorb significant
 time and resources.
 uote:
 “XP is the answer
 to the question,
 ‘How little can we
 do and still build
 great software?’“
 Anonymous
 WebRef
 An excellent overview
 of “rules” for XP can
 be found at www
 .extremeprogramm
 ing.org/rules.html.
 To achieve simplicity, XP restricts developers to design only for immediate needs,
 rather than consider future needs. The intent is to create a simple design that can be
 easily implemented in code). If the design must be improved, it can be refactored4 at
 a later time.
 Feedback is derived from three sources: the implemented software itself, the
 customer, and other software team members. By designing and implementing an
 effective testing strategy (Chapters 17 through 20), the software (via test results) pro
vides the agile team with feedback. XP makes use of the unit test as its primary test
ing tactic. As each class is developed, the team develops a unit test to exercise each
 operation according to its specified functionality. As an increment is delivered to a
 customer, the user stories or use cases (Chapter 5) that are implemented by the
 increment are used as a basis for acceptance tests. The degree to which the software
 implements the output, function, and behavior of the use case is a form of feedback.
 Finally, as new requirements are derived as part of iterative planning, the team pro
vides the customer with rapid feedback regarding cost and schedule impact.
 Beck [Bec04a] argues that strict adherence to certain XP practices demands
 courage. A better word might be discipline. For example, there is often significant
 pressure to design for future requirements. Most software teams succumb, arguing
 that “designing for tomorrow” will save time and effort in the long run. An agile XP
 team must have the discipline (courage) to design for today, recognizing that future
 requirements may change dramatically, thereby demanding substantial rework of
 the design and implemented code.
 By following each of these values, the agile team inculcates respect among it
 members, between other stakeholders and team members, and indirectly, for the
 software itself. As they achieve successful delivery of software increments, the team
 develops growing respect for the XP process.
 3.4.2 The XP Process
 Extreme Programming uses an object-oriented approach (Appendix 2) as its pre
ferred development paradigm and encompasses a set of rules and practices that
 occur within the context of four framework activities: planning, design, coding, and
 testing. Figure 3.2 illustrates the XP process and notes some of the key ideas and
 tasks that are associated with each framework activity. Key XP activities are sum
marized in the paragraphs that follow.
 Planning. The planning activity (also called the planning game) begins with
 listening—a requirements gathering activity that enables the technical members of
 the XP team to understand the business context for the software and to get a broad
 4 Refactoring allows a software engineer to improve the internal structure of a design (or source
 code) without changing its external functionality or behavior. In essence, refactoring can be used
 to improve the efficiency, readability, or performance of a design or the code that implements a
 design.
74
 PART ONE THE SOFTWARE PROCESS
 FIGURE 3.2
 The Extreme
 Programming
 process
 ?
 What is an
 XP “story”?
 WebRef
 A worthwhile XP
 “planning game” can
 be found at:
 c2.com/cgi/
 wiki?planningGame.
 simple design
 CRC cards
 user stories
 values
 acceptance test criteria
 iteration plan
 Release
 spike solutions
 prototypes
 refactoring
 design
 pair programming
 planning
 software increment
 project velocity computed
 unit test
 continuous integration
 acceptance testing
 test
 coding
 feel for required output and major features and functionality. Listening leads to the
 creation of a set of “stories” (also called user stories) that describe required output,
 features, and functionality for software to be built. Each story (similar to use cases
 described in Chapter 5) is written by the customer and is placed on an index card.
 The customer assigns a value (i.e., a priority) to the story based on the overall busi
ness value of the feature or function.5 Members of the XP team then assess each
 story and assign a cost—measured in development weeks—to it. If the story is esti
mated to require more than three development weeks, the customer is asked to split
 the story into smaller stories and the assignment of value and cost occurs again. It
 is important to note that new stories can be written at any time.
 Customers and developers work together to decide how to group stories into the
 next release (the next software increment) to be developed by the XP team. Once a
 basic commitment (agreement on stories to be included, delivery date, and other
 project matters) is made for a release, the XP team orders the stories that will be de
veloped in one of three ways: (1) all stories will be implemented immediately (within
 a few weeks), (2) the stories with highest value will be moved up in the schedule and
 implemented first, or (3) the riskiest stories will be moved up in the schedule and
 implemented first.
 After the first project release (also called a software increment) has been deliv
ered, the XP team computes project velocity. Stated simply, project velocity is the
 5 The value of a story may also be dependent on the presence of another story.
75
 CHAPTER 3 AGILE DEVELOPMENT
 Project velocity is a
 subtle measure of
 team productivity.
 XP deemphasizes the
 importance of design.
 Not everyone agrees.
 In fact, there are times
 when design should be
 emphasized.
 WebRef
 Refactoring techniques
 and tools can be
 found at:
 www.refactoring
 .com.
 number of customer stories implemented during the first release. Project velocity can
 then be used to (1) help estimate delivery dates and schedule for subsequent releases
 and (2) determine whether an overcommitment has been made for all stories across
 the entire development project. If an overcommitment occurs, the content of releases
 is modified or end delivery dates are changed.
 As development work proceeds, the customer can add stories, change the value
 of an existing story, split stories, or eliminate them. The XP team then reconsiders all
 remaining releases and modifies its plans accordingly.
 Design. XP design rigorously follows the KIS (keep it simple) principle. A simple
 design is always preferred over a more complex representation. In addition, the de
sign provides implementation guidance for a story as it is written—nothing less,
 nothing more. The design of extra functionality (because the developer assumes it
 will be required later) is discouraged.6
 XP encourages the use of CRC cards (Chapter 7) as an effective mechanism for
 thinking about the software in an object-oriented context. CRC (class-responsibility
collaborator) cards identify and organize the object-oriented classes7 that are rele
vant to the current software increment. The XP team conducts the design exercise
 using a process similar to the one described in Chapter 8. The CRC cards are the only
 design work product produced as part of the XP process.
 If a difficult design problem is encountered as part of the design of a story, XP rec
ommends the immediate creation of an operational prototype of that portion of the
 design. Called a spike solution, the design prototype is implemented and evaluated.
 The intent is to lower risk when true implementation starts and to validate the orig
inal estimates for the story containing the design problem.
 In the preceding section, we noted that XP encourages refactoring—a construction
 technique that is also a method for design optimization. Fowler [Fow00] describes
 refactoring in the following manner:
 Refactoring is the process of changing a software system in such a way that it does not
 alter the external behavior of the code yet improves the internal structure. It is a disci
plined way to clean up code [and modify/simplify the internal design] that minimizes the
 chances of introducing bugs. In essence, when you refactor you are improving the design
 of the code after it has been written.
 Because XP design uses virtually no notation and produces few, if any, work prod
ucts other than CRC cards and spike solutions, design is viewed as a transient arti
fact that can and should be continually modified as construction proceeds. The intent
 of refactoring is to control these modifications by suggesting small design changes
 6 These design guidelines should be followed in every software engineering method, although there
 are times when sophisticated design notation and terminology may get in the way of simplicity.
 7 Object-oriented classes are discussed in Appendix 2, in Chapter 8, and throughout Part 2 of this
 book.
76
 PART ONE THE SOFTWARE PROCESS
 Refactoring improves
 the internal structure of
 a design (or source
 code) without
 changing its external
 functionality or
 behavior.
 WebRef
 Useful information on
 XP can be obtained 
at www
 .xprogramming.
 com.
 ?
 What is 
pair
 programming?
 Many software teams
 are populated by indi
vidualists. You’ll have
 to work to change that
 culture if pair program
ming is to work effec
tively.
 ?
 XP?
 How are unit
 tests used in
 that “can radically improve the design” [Fow00]. It should be noted, however, that
 the effort required for refactoring can grow dramatically as the size of an application
 grows.
 A central notion in XP is that design occurs both before and after coding com
mences. Refactoring means that design occurs continuously as the system is con
structed. In fact, the construction activity itself will provide the XP team with
 guidance on how to improve the design.
 Coding. After stories are developed and preliminary design work is done, the team
 does not move to code, but rather develops a series of unit tests that will exercise
 each of the stories that is to be included in the current release (software increment).8
 Once the unit test9 has been created, the developer is better able to focus on what
 must be implemented to pass the test. Nothing extraneous is added (KIS). Once the
 code is complete, it can be unit-tested immediately, thereby providing instantaneous
 feedback to the developers.
 A key concept during the coding activity (and one of the most talked about aspects
 of XP) is pair programming. XP recommends that two people work together at one
 computer workstation to create code for a story. This provides a mechanism for real
time problem solving (two heads are often better than one) and real-time quality as
surance (the code is reviewed as it is created). It also keeps the developers focused
 on the problem at hand. In practice, each person takes on a slightly different role. For
 example, one person might think about the coding details of a particular portion of
 the design while the other ensures that coding standards (a required part of XP) are
 being followed or that the code for the story will satisfy the unit test that has been
 developed to validate the code against the story.
 As pair programmers complete their work, the code they develop is integrated
 with the work of others. In some cases this is performed on a daily basis by an inte
gration team. In other cases, the pair programmers have integration responsibility.
 This “continuous integration” strategy helps to avoid compatibility and interfacing
 problems and provides a “smoke testing” environment (Chapter 17) that helps to
 uncover errors early.
 Testing. I have already noted that the creation of unit tests before coding com
mences is a key element of the XP approach. The unit tests that are created should
 be implemented using a framework that enables them to be automated (hence, they
 can be executed easily and repeatedly). This encourages a regression testing strat
egy (Chapter 17) whenever code is modified (which is often, given the XP refactor
ing philosophy).
 8 This approach is analogous to knowing the exam questions before you begin to study. It makes
 studying much easier by focusing attention only on the questions that will be asked.
 9 Unit testing, discussed in detail in Chapter 17, focuses on an individual software component, exer
cising the component’s interface, data structures, and functionality in an effort to uncover errors
 that are local to the component.
77
 CHAPTER 3 AGILE DEVELOPMENT
 XP acceptance tests
 are derived from user
 stories.
 ?
 What new
 practices are
 appended to XP
 to create IXP?
 uote:
 “Ability is what
 you’re capable of
 doing. Motivation
 determines what
 you do. Attitude
 determines how
 well you do it.”
 Lou Holtz
 As the individual unit tests are organized into a “universal testing suite” [Wel99],
 integration and validation testing of the system can occur on a daily basis. This pro
vides the XP team with a continual indication of progress and also can raise warn
ing flags early if things go awry. Wells [Wel99] states: “Fixing small problems every
 few hours takes less time than fixing huge problems just before the deadline.”
 XP acceptance tests, also called customer tests, are specified by the customer and
 focus on overall system features and functionality that are visible and reviewable by
 the customer. Acceptance tests are derived from user stories that have been imple
mented as part of a software release.
 3.4.3 Industrial XP
 Joshua Kerievsky [Ker05] describes Industrial Extreme Programming (IXP) in the fol
lowing manner: “IXP is an organic evolution of XP. It is imbued with XP’s minimal
ist, customer-centric, test-driven spirit. IXP differs most from the original XP in its
 greater inclusion of management, its expanded role for customers, and its upgraded
 technical practices.” IXP incorporates six new practices that are designed to help
 ensure that an XP project works successfully for significant projects within a large
 organization.
 Readiness assessment. Prior to the initiation of an IXP project, the organ
ization should conduct a readiness assessment. The assessment ascertains
 whether (1) an appropriate development environment exists to support IXP,
 (2) the team will be populated by the proper set of stakeholders, (3) the or
ganization has a distinct quality program and supports continuous improve
ment, (4) the organizational culture will support the new values of an agile
 team, and (5) the broader project community will be populated appropriately.
 Project community. Classic XP suggests that the right people be used to
 populate the agile team to ensure success. The implication is that people on
 the team must be well-trained, adaptable and skilled, and have the proper
 temperament to contribute to a self-organizing team. When XP is to be
 applied for a significant project in a large organization, the concept of the
 “team” should morph into that of a community. A community may have a
 technologist and customers who are central to the success of a project as
 well as many other stakeholders (e.g., legal staff, quality auditors, manufac
turing or sales types) who “are often at the periphery of an IXP project yet
 they may play important roles on the project” [Ker05]. In IXP, the community
 members and their roles should be explicitly defined and mechanisms for
 communication and coordination between community members should be
 established.
 Project chartering. The IXP team assesses the project itself to determine
 whether an appropriate business justification for the project exists and
 whether the project will further the overall goals and objectives of the
78
 PART ONE THE SOFTWARE PROCESS
 organization. Chartering also examines the context of the project to deter
mine how it complements, extends, or replaces existing systems or
 processes.
 Test-driven management. An IXP project requires measurable criteria for
 assessing the state of the project and the progress that has been made to
 date. Test-driven management establishes a series of measurable “destina
tions” [Ker05] and then defines mechanisms for determining whether or not
 these destinations have been reached.
 Retrospectives. An IXP team conducts a specialized technical review
 (Chapter 15) after a software increment is delivered. Called a retrospective,
 the review examines “issues, events, and lessons-learned” [Ker05] across a
 software increment and/or the entire software release. The intent is to
 improve the IXP process.
 Continuous learning. Because learning is a vital part of continuous
 process improvement, members of the XP team are encouraged (and possi
bly, incented) to learn new methods and techniques that can lead to a higher
quality product.
 In addition to the six new practices discussed, IXP modifies a number of existing
 XP practices. Story-driven development (SDD) insists that stories for acceptance tests
 be written before a single line of code is generated. Domain-driven design (DDD) is
 an improvement on the “system metaphor” concept used in XP. DDD [Eva03] sug
gests the evolutionary creation of a domain model that “accurately represents how
 domain experts think about their subject” [Ker05]. Pairing extends the XP pair
programming concept to include managers and other stakeholders. The intent is to
 improve knowledge sharing among XP team members who may not be directly in
volved in technical development. Iterative usability discourages front-loaded inter
face design in favor of usability design that evolves as software increments are
 delivered and users’ interaction with the software is studied.
 IXP makes smaller modifications to other XP practices and redefines certain roles
 and responsibilities to make them more amenable to significant projects for large
 organizations. For further discussion of IXP, visit http://industrialxp.org.
 3.4.4 The XP Debate
 All new process models and methods spur worthwhile discussion and in some in
stances heated debate. Extreme Programming has done both. In an interesting book
 that examines the efficacy of XP, Stephens and Rosenberg [Ste03] argue that many
 XP practices are worthwhile, but others have been overhyped, and a few are prob
lematic. The authors suggest that the codependent nature of XP practices are both
 its strength and its weakness. Because many organizations adopt only a subset of XP
 practices, they weaken the efficacy of the entire process. Proponents counter that
 XP is continuously evolving and that many of the issues raised by critics have been
79
 CHAPTER 3 AGILE DEVELOPMENT
 addressed as XP practice matures. Among the issues that continue to trouble some
 critics of XP are:10
 ?
 What are
 some of the
 issues that lead to
 an XP debate?
 • Requirements volatility. Because the customer is an active member of the XP
 team, changes to requirements are requested informally. As a consequence,
 the scope of the project can change and earlier work may have to be
 modified to accommodate current needs. Proponents argue that this happens
 regardless of the process that is applied and that XP provides mechanisms for
 controlling scope creep.
 • Conflicting customer needs. Many projects have multiple customers, each with
 his own set of needs. In XP, the team itself is tasked with assimilating the
 needs of different customers, a job that may be beyond their scope of
 authority.
 • Requirements are expressed informally. User stories and acceptance tests are
 the only explicit manifestation of requirements in XP. Critics argue that a
 more formal model or specification is often needed to ensure that omissions,
 inconsistencies, and errors are uncovered before the system is built. Propo
nents counter that the changing nature of requirements makes such models
 and specification obsolete almost as soon as they are developed.
 • Lack of formal design. XP deemphasizes the need for architectural design and
 in many instances, suggests that design of all kinds should be relatively
 informal. Critics argue that when complex systems are built, design must be
 emphasized to ensure that the overall structure of the software will exhibit
 quality and maintainability. XP proponents suggest that the incremental
 nature of the XP process limits complexity (simplicity is a core value) and
 therefore reduces the need for extensive design.
 You should note that every software process has flaws and that many software or
ganizations have used XP successfully. The key is to recognize where a process may
 have weaknesses and to adapt it to the specific needs of your organization.
 SAFEHOME
 Considering Agile Software Development
 The scene: Doug Miller’s office.
 The Players: Doug Miller, software engineering
 manager; Jamie Lazar, software team member; Vinod
 Raman, software team member.
 The conversation:
 (A knock on the door, Jamie and Vinod enter Doug’s office)
 Jamie: Doug, you got a minute?
 10 For a detailed look at some thoughtful criticism that has been leveled at XP, visit
 www.softwarereality.com/ExtremeProgramming.jsp.
3.5 OTHERAGILEPROCESSMODELS
 The history of software engineering is littered with dozens of obsolete process
 descriptions and methodologies, modeling methods and notations, tools, and
 technology. Each flared in notoriety and was then eclipsed by something new and
 (purportedly) better. With the introduction of a wide array of agile process models—
 each contending for acceptance within the software development community—the
 agile movement is following the same historical path.11
 As I noted in the last section, the most widely used of all agile process models
 isExtreme Programming (XP). But many other agile process models have been
 proposed and are in use across the industry. Among the most common are:
 •Adaptive Software Development (ASD)
 •Scrum
 •Dynamic Systems Development Method (DSDM)
 80 PART ONE THE SOFTWARE PROCESS
 Doug: Sure Jamie, what’s up?
 Jamie:We’ve been thinking about our process
 discussion yesterday . . . you know, what process we’re
 going to choose for this new SafeHomeproject.
 Doug:And?
 Vinod: I was talking to a friend at another company,
 and he was telling me about Extreme Programming. It’s
 an agile process model . . . heard of it?
 Doug: Yeah, some good, some bad.
 Jamie:Well, it sounds pretty good to us. Lets you
 develop software really fast, uses something called pair
 programming to do real-time quality checks . . . it’s pretty
 cool, I think.
 Doug: It does have a lot of really good ideas. I like the
 pair-programming concept, for instance, and the idea
 that stakeholders should be part of the team.
 Jamie:Huh? You mean that marketing will work on the
 project team with us?
 Doug (nodding): They’re a stakeholder, aren’t they?
 Jamie: Jeez . . . they’ll be requesting changes every five
 minutes.
 Vinod:Not necessarily. My friend said that there are
 ways to “embrace” changes during an XP project.
 Doug: So you guys think we should use XP?
 Jamie: It’s definitely worth considering.
 Doug: I agree. And even if we choose an incremental
 model as our approach, there’s no reason why we can’t
 incorporate much of what XP has to offer.
 Vinod:Doug, before you said “some good, some bad.”
 What was the “bad”?
 Doug: The thing I don’t like is the way XP downplays
 analysis and design . . . sort of says that writing code is
 where the action is . . . 
(The team members look at one another and smile.)
 Doug: So you agree with the XP approach?
 Jamie (speaking for both):Writing code is what
 we do, Boss!
 Doug (laughing): True, but I’d like to see you spend a
 little less time coding and then recoding and a little more
 time analyzing what has to be done and designing a
 solution that works.
 Vinod:Maybe we can have it both ways, agility with a
 little discipline.
 Doug: I think we can, Vinod. In fact, I’m sure of it.
 uote:
 “Our profession
 goes through
 methodologies like
 a 14-year-old goes
 through clothing.”
 Stephen
 Hawrysh and
 JimRuprecht
 11This is not a bad thing. Before one or more models or methods are accepted as a de facto standard,
 all must contend for the hearts and minds of software engineers. The “winners” evolve into best
 practice, while the “losers” either disappear or merge with the winning models.
81
 CHAPTER 3 AGILE DEVELOPMENT
 • Crystal
 • Feature Drive Development (FDD)
 • Lean Software Development (LSD)
 • Agile Modeling (AM)
 • Agile Unified Process (AUP)
 In the sections that follow, I present a very brief overview of each of these agile
 process models. It is important to note that all agile process models conform (to a
 greater or lesser degree) to the Manifesto for Agile Software Development and the prin
ciples noted in Section 3.3.1. For additional detail, refer to the references noted in
 each subsection or for a survey, examine the “agile software development” entry
 in Wikipedia.12
 3.5.1 Adaptive Software Development (ASD)
 WebRef
 Useful resources for
 ASD can be found at
 www.adaptivesd
 .com.
 Adaptive Software Development (ASD) has been proposed by Jim Highsmith [Hig00] as
 a technique for building complex software and systems. The philosophical under
pinnings of ASD focus on human collaboration and team self-organization.
 Highsmith argues that an agile, adaptive development approach based on collab
oration is “as much a source of order in our complex interactions as discipline and
 engineering.” He defines an ASD “life cycle” (Figure 3.3) that incorporates three
 phases, speculation, collaboration, and learning.
 FIGURE 3.3
 Adaptive
 software
 development
 adaptive cycle planning
 mission statement
 project constraints
 basic requirements
 time-boxed release plan
 Release
 Requirements gathering
 JAD
 mini-specs
 speculation
 software increment
 adjustments for subsequent cycles
 collaboration
 components implemented/tested
 focus groups for feedback
 formal technical reviews
 learning
 postmortems
 12 See http://en.wikipedia.org/wiki/Agile_software_development#Agile_methods.
82
 PART ONE THE SOFTWARE PROCESS
 Effective collaboration
 with your customer will
 only occur if you
 jettison any “us and
 them” attitudes.
 ASD emphasizes
 learning as a key
 element in achieving 
a “self-organizing”
 team.
 WebRef
 Useful Scrum
 information and
 resources can be found
 at www
 .controlchaos.com.
 During speculation, the project is initiated and adaptive cycle planning is con
ducted. Adaptive cycle planning uses project initiation information—the customer’s
 mission statement, project constraints (e.g., delivery dates or user descriptions), and
 basic requirements—to define the set of release cycles (software increments) that
 will be required for the project.
 No matter how complete and farsighted the cycle plan, it will invariably change.
 Based on information obtained at the completion of the first cycle, the plan is re
viewed and adjusted so that planned work better fits the reality in which an ASD
 team is working.
 Motivated people use collaboration in a way that multiplies their talent and cre
ative output beyond their absolute numbers. This approach is a recurring theme in
 all agile methods. But collaboration is not easy. It encompasses communication and
 teamwork, but it also emphasizes individualism, because individual creativity plays
 an important role in collaborative thinking. It is, above all, a matter of trust. People
 working together must trust one another to (1) criticize without animosity, (2) assist
 without resentment, (3) work as hard as or harder than they do, (4) have the skill set
 to contribute to the work at hand, and (5) communicate problems or concerns in a
 way that leads to effective action.
 As members of an ASD team begin to develop the components that are part of an
 adaptive cycle, the emphasis is on “learning” as much as it is on progress toward
 a completed cycle. In fact, Highsmith [Hig00] argues that software developers often
 overestimate their own understanding (of the technology, the process, and the proj
ect) and that learning will help them to improve their level of real understanding.
 ASD teams learn in three ways: focus groups (Chapter 5), technical reviews (Chap
ter 14), and project postmortems.
 The ASD philosophy has merit regardless of the process model that is used. ASD’s
 overall emphasis on the dynamics of self-organizing teams, interpersonal collabo
ration, and individual and team learning yield software project teams that have a
 much higher likelihood of success.
 3.5.2 Scrum
 Scrum (the name is derived from an activity that occurs during a rugby match13) is
 an agile software development method that was conceived by Jeff Sutherland and his
 development team in the early 1990s. In recent years, further development on the
 Scrum methods has been performed by Schwaber and Beedle [Sch01a].
 Scrum principles are consistent with the agile manifesto and are used to guide
 development activities within a process that incorporates the following framework
 activities: requirements, analysis, design, evolution, and delivery. Within each
 13 A group of players forms around the ball and the teammates work together (sometimes violently!)
 to move the ball downfield.
every 24
 hours
 30 days
 Scrum: 15 minute daily meeting.
 Team members respond to basics:
 1) What did you do since last Scrum
 meeting?
 2) Do you have any obstacles?
 3) What will you do before next
 meeting?
 Sprint Backlog:
 Feature(s)
 assigned
 to sprint
 Product Backlog:
 Prioritized product features desired by the customer
 Backlog
 items
 expanded
 by team
 New functionality
 is demonstrated
 at end of sprint
 framework activity, work tasks occur within a process pattern (discussed in the fol
lowing paragraph) called a sprint.The work conducted within a sprint (the number
 of sprints required for each framework activity will vary depending on product com
plexity and size) is adapted to the problem at hand and is defined and often modified
 in real time by the Scrum team. The overall flow of the Scrum process is illustrated
 in Figure 3.4.
 Scrum emphasizes the use of a set of software process patterns [Noy02] that have
 proven effective for projects with tight timelines, changing requirements, and business
 criticality. Each of these process patterns defines a set of development actions:
 Backlog—a prioritized list of project requirements or features that provide busi
ness value for the customer. Items can be added to the backlog at any time (this is
 how changes are introduced). The product manager assesses the backlog and
 updates priorities as required.
 Sprints—consist of work units that are required to achieve a requirement de
fined in the backlog that must be fit into a predefined time-box14(typically 30 days).
 CHAPTER 3 AGILE DEVELOPMENT 83
 14A time-boxis a project management term (see Part 4 of this book) that indicates a period of time
 that has been allocated to accomplish some task.
 FIGURE3.4
 Scrum process
 flow
 Scrum incorporates a
 set of process patterns
 that emphasize project
 priorities,
 compartmentalized
 work units,
 communication, and
 frequent customer
 feedback.
84
 PART ONE THE SOFTWARE PROCESS
 Changes (e.g., backlog work items) are not introduced during the sprint. Hence, the
 sprint allows team members to work in a short-term, but stable environment.
 Scrum meetings—are short (typically 15 minutes) meetings held daily by the Scrum
 team. Three key questions are asked and answered by all team members [Noy02]:
 • What did you do since the last team meeting?
 • What obstacles are you encountering?
 • What do you plan to accomplish by the next team meeting?
 A team leader, called a Scrum master, leads the meeting and assesses the responses
 from each person. The Scrum meeting helps the team to uncover potential problems
 as early as possible. Also, these daily meetings lead to “knowledge socialization”
 [Bee99] and thereby promote a self-organizing team structure.
 Demos—deliver the software increment to the customer so that functionality that
 has been implemented can be demonstrated and evaluated by the customer. It is im
portant to note that the demo may not contain all planned functionality, but rather
 those functions that can be delivered within the time-box that was established.
 Beedle and his colleagues [Bee99] present a comprehensive discussion of these pat
terns in which they state: “Scrum assumes up-front the existence of chaos. . . . ” The
 Scrum process patterns enable a software team to work successfully in a world
 where the elimination of uncertainty is impossible.
 3.5.3 Dynamic Systems Development Method (DSDM)
 WebRef
 Useful resources for
 DSSD can be found at
 www.dsdm.org.
 The Dynamic Systems Development Method (DSDM) [Sta97] is an agile software devel
opment approach that “provides a framework for building and maintaining systems
 which meet tight time constraints through the use of incremental prototyping in a con
trolled project environment” [CCS02]. The DSDM philosophy is borrowed from a mod
ified version of the Pareto principle—80 percent of an application can be delivered in
 20 percent of the time it would take to deliver the complete (100 percent) application.
 DSDM is an iterative software process in which each iteration follows the 80 per
cent rule. That is, only enough work is required for each increment to facilitate
 movement to the next increment. The remaining detail can be completed later when
 more business requirements are known or changes have been requested and
 accommodated.
 The DSDM Consortium (www.dsdm.org) is a worldwide group of member com
panies that collectively take on the role of “keeper” of the method. The consortium
 has defined an agile process model, called the DSDM life cycle that defines three dif
ferent iterative cycles, preceded by two additional life cycle activities:
 Feasibility study—establishes the basic business requirements and constraints
 associated with the application to be built and then assesses whether the applica
tion is a viable candidate for the DSDM process.
85
 CHAPTER 3 AGILE DEVELOPMENT
 DSDM is a process
 framework that can
 adopt the tactics of
 another agile approach
 such as XP.
 Crystal is a family of
 process models with
 the same “genetic
 code” but different
 methods for adapting
 to project
 characteristics.
 Business study—establishes the functional and information requirements that
 will allow the application to provide business value; also, defines the basic
 application architecture and identifies the maintainability requirements for the
 application.
 Functional model iteration—produces a set of incremental prototypes that
 demonstrate functionality for the customer. (Note: All DSDM prototypes are in
tended to evolve into the deliverable application.) The intent during this iterative
 cycle is to gather additional requirements by eliciting feedback from users as they
 exercise the prototype.
 Design and build iteration—revisits prototypes built during functional model
 iteration to ensure that each has been engineered in a manner that will enable it to
 provide operational business value for end users. In some cases, functional model
 iteration and design and build iteration occur concurrently.
 Implementation—places the latest software increment (an “operationalized” pro
totype) into the operational environment. It should be noted that (1) the increment
 may not be 100 percent complete or (2) changes may be requested as the incre
ment is put into place. In either case, DSDM development work continues by
 returning to the functional model iteration activity.
 DSDM can be combined with XP (Section 3.4) to provide a combination approach
 that defines a solid process model (the DSDM life cycle) with the nuts and bolts prac
tices (XP) that are required to build software increments. In addition, the ASD con
cepts of collaboration and self-organizing teams can be adapted to a combined
 process model.
 3.5.4 Crystal
 Alistair Cockburn [Coc05] and Jim Highsmith [Hig02b] created the Crystal family of
 agile methods15 in order to achieve a software development approach that puts a
 premium on “maneuverability” during what Cockburn characterizes as “a resource
limited, cooperative game of invention and communication, with a primary goal of
 delivering useful, working software and a secondary goal of setting up for the next
 game” [Coc02].
 To achieve maneuverability, Cockburn and Highsmith have defined a set of
 methodologies, each with core elements that are common to all, and roles, process
 patterns, work products, and practice that are unique to each. The Crystal family is
 actually a set of example agile processes that have been proven effective for differ
ent types of projects. The intent is to allow agile teams to select the member of the
 crystal family that is most appropriate for their project and environment.
 15 The name “crystal” is derived from the characteristics of geological crystals, each with its own
 color, shape, and hardness.
86
 PART ONE THE SOFTWARE PROCESS
 3.5.5 Feature Driven Development (FDD)
 WebRef
 A wide variety of
 articles and
 presentations on FDD
 can be found at:
 www.featuredrive
 ndevelopment
 .com/.
 Feature Driven Development (FDD) was originally conceived by Peter Coad and his
 colleagues [Coa99] as a practical process model for object-oriented software engi
neering. Stephen Palmer and John Felsing [Pal02] have extended and improved
 Coad’s work, describing an adaptive, agile process that can be applied to moderately
 sized and larger software projects.
 Like other agile approaches, FDD adopts a philosophy that (1) emphasizes col
laboration among people on an FDD team; (2) manages problem and project
 complexity using feature-based decomposition followed by the integration of
 software increments, and (3) communication of technical detail using verbal,
 graphical, and text-based means. FDD emphasizes software quality assurance
 activities by encouraging an incremental development strategy, the use of design
 and code inspections, the application of software quality assurance audits (Chap
ter 16), the collection of metrics, and the use of patterns (for analysis, design, and
 construction).
 In the context of FDD, a feature “is a client-valued function that can be imple
mented in two weeks or less” [Coa99]. The emphasis on the definition of features
 provides the following benefits:
 • Because features are small blocks of deliverable functionality, users can
 describe them more easily; understand how they relate to one another more
 readily; and better review them for ambiguity, error, or omissions.
 • Features can be organized into a hierarchical business-related grouping.
 • Since a feature is the FDD deliverable software increment, the team develops
 operational features every two weeks.
 • Because features are small, their design and code representations are easier
 to inspect effectively.
 • Project planning, scheduling, and tracking are driven by the feature
 hierarchy, rather than an arbitrarily adopted software engineering 
task set.
 Coad and his colleagues [Coa99] suggest the following template for defining a
 feature:
 <action> the <result> <by for of to> a(n) <object>
 where an <object> is “a person, place, or thing (including roles, moments in time or
 intervals of time, or catalog-entry-like descriptions).” Examples of features for an 
e-commerce application might be:
 Add the product to shopping cart
 Display the technical-specifications of the product
 Store the shipping-information for the customer
87
 CHAPTER 3 AGILE DEVELOPMENT
 FIGURE 3.5
 Feature Driven
 Development
 [Coa99] (with
 permission)
 Develop
 an
 Overall
 Model
 Build a
 Features
 List
 Plan
 By
 Feature
 Design
 By
 Feature
 (more shape
 than content)
 A list of features
 grouped into sets
 and subject areas
 A development plan
 Class owners
 Feature Set Owners
 A design
 package
 (sequences)
 Build
 By
 Feature
 Completed
 client-value
 function
 A feature set groups related features into business-related categories and is defined
 [Coa99] as:
 <action><-ing> a(n) <object>
 For example: Making a product sale is a feature set that would encompass the fea
tures noted earlier and others.
 The FDD approach defines five “collaborating” [Coa99] framework activities (in
 FDD these are called “processes”) as shown in Figure 3.5.
 FDD provides greater emphasis on project management guidelines and tech
niques than many other agile methods. As projects grow in size and complexity,
 ad hoc project management is often inadequate. It is essential for developers, their
 managers, and other stakeholders to understand project status—what accomplish
ments have been made and problems have been encountered. If deadline pressure
 is significant, it is critical to determine if software increments (features) are properly
 scheduled. To accomplish this, FDD defines six milestones during the design and
 implementation of a feature: “design walkthrough, design, design inspection, code,
 code inspection, promote to build” [Coa99].
 3.5.6 Lean Software Development (LSD)
 Lean Software Development (LSD) has adapted the principles of lean manufacturing
 to the world of software engineering. The lean principles that inspire the LSD process
 can be summarized ([Pop03], [Pop06a]) as eliminate waste, build quality in, create
 knowledge, defer commitment, deliver fast, respect people, and optimize the whole.
 Each of these principles can be adapted to the software process. For example,
 eliminate waste within the context of an agile software project can be interpreted
 to mean [Das05]: (1) adding no extraneous features or functions, (2) assessing the
 cost and schedule impact of any newly requested requirement, (3) removing any
 superfluous process steps, (4) establishing mechanisms to improve the way team
 members find information, (5) ensuring the testing finds as many errors as possible,
88
 PART ONE THE SOFTWARE PROCESS
 (6) reducing the time required to request and get a decision that affects the software
 or the process that is applied to create it, and (7) streamlining the manner in which
 information is transmitted to all stakeholders involved in the process.
 For a detailed discussion of LSD and pragmatic guidelines for implementing the
 process, you should examine [Pop06a] and [Pop06b].
 3.5.7 Agile Modeling (AM)
 WebRef
 Comprehensive
 information on agile
 modeling can be found
 at: www
 .agilemodeling.com.
 uote:
 “I was in the drug
 store the other day
 trying to get a cold
 medication . . . not
 easy. There’s an
 entire wall of
 products you need.
 You stand there
 going, Well, this
 one is quick acting
 but this is long
 lasting. . . . Which
 is more important,
 the present or the
 future?”
 Jerry Seinfeld
 There are many situations in which software engineers must build large, business
critical systems. The scope and complexity of such systems must be modeled so that
 (1) all constituencies can better understand what needs to be accomplished, (2) the
 problem can be partitioned effectively among the people who must solve it, and
 (3) quality can be assessed as the system is being engineered and built.
 Over the past 30 years, a wide variety of software engineering modeling methods
 and notation have been proposed for analysis and design (both architectural and
 component-level). These methods have merit, but they have proven to be difficult
 to apply and challenging to sustain (over many projects). Part of the problem is the
 “weight” of these modeling methods. By this I mean the volume of notation required,
 the degree of formalism suggested, the sheer size of the models for large projects,
 and the difficulty in maintaining the model(s) as changes occur. Yet analysis and de
sign modeling have substantial benefit for large projects—if for no other reason than
 to make these projects intellectually manageable. Is there an agile approach to soft
ware engineering modeling that might provide an alternative?
 At “The Official Agile Modeling Site,” Scott Ambler [Amb02a] describes agile mod
eling (AM) in the following manner:
 Agile Modeling (AM) is a practice-based methodology for effective modeling and documen
tation of software-based systems. Simply put, Agile Modeling (AM) is a collection of values,
 principles, and practices for modeling software that can be applied on a software develop
ment project in an effective and light-weight manner. Agile models are more effective than
 traditional models because they are just barely good, they don’t have to be perfect.
 Agile modeling adopts all of the values that are consistent with the agile manifesto.
 The agile modeling philosophy recognizes that an agile team must have the courage
 to make decisions that may cause it to reject a design and refactor. The team must
 also have the humility to recognize that technologists do not have all the answers and
 that business experts and other stakeholders should be respected and embraced.
 Although AM suggests a wide array of “core” and “supplementary” modeling prin
ciples, those that make AM unique are [Amb02a]:
 Model with a purpose. A developer who uses AM should have a specific
 goal (e.g., to communicate information to the customer or to help better un
derstand some aspect of the software) in mind before creating the model.
 Once the goal for the model is identified, the type of notation to be used and
 level of detail required will be more obvious.
89
 CHAPTER 3 AGILE DEVELOPMENT
 Use multiple models. There are many different models and notations that
 can be used to describe software. Only a small subset is essential for most
 projects. AM suggests that to provide needed insight, each model should
 present a different aspect of the system and only those models that provide
 value to their intended audience should be used.
 “Traveling light” is an
 appropriate philosophy
 for all software engi
neering work. Build
 only those models that
 provide value … no
 more, no less.
 Travel light. As software engineering work proceeds, keep only those mod
els that will provide long-term value and jettison the rest. Every work product
 that is kept must be maintained as changes occur. This represents work that
 slows the team down. Ambler [Amb02a] notes that “Every time you decide to
 keep a model you trade-off agility for the convenience of having that informa
tion available to your team in an abstract manner (hence potentially enhanc
ing communication within your team as well as with project stakeholders).”
 Content is more important than representation. Modeling should im
part information to its intended audience. A syntactically perfect model that
 imparts little useful content is not as valuable as a model with flawed nota
tion that nevertheless provides valuable content for its audience.
 Know the models and the tools you use to create them. Understand
 the strengths and weaknesses of each model and the tools that are used to
 create it.
 Adapt locally. The modeling approach should be adapted to the needs of
 the agile team.
 A major segment of the software engineering community has adopted the Unified
 Modeling Language (UML)16 as the preferred method for representing analysis and
 design models. The Unified Process (Chapter 2) has been developed to provide a
 framework for the application of UML. Scott Ambler [Amb06] has developed a sim
plified version of the UP that integrates his agile modeling philosophy.
 3.5.8 Agile Unified Process (AUP)
 The Agile Unified Process (AUP) adopts a “serial in the large” and “iterative in the
 small” [Amb06] philosophy for building computer-based systems. By adopting the
 classic UP phased activities—inception, elaboration, construction, and transition—AUP
 provides a serial overlay (i.e., a linear sequence of software engineering activities)
 that enables a team to visualize the overall process flow for a software project. How
ever, within each of the activities, the team iterates to achieve agility and to deliver
 meaningful software increments to end users as rapidly as possible. Each AUP iter
ation addresses the following activities [Amb06]: 
• Modeling. UML representations of the business and problem domains are
 created. However, to stay agile, these models should be “just barely good
 enough” [Amb06] to allow the team to proceed.
 16 A brief tutorial on UML is presented in Appendix 1.
90
 PART ONE THE SOFTWARE PROCESS
 • Implementation. Models are translated into source code.
 • Testing. Like XP, the team designs and executes a series of tests to uncover
 errors and ensure that the source code meets its requirements.
 • Deployment. Like the generic process activity discussed in Chapters 1 and 2,
 deployment in this context focuses on the delivery of a software increment
 and the acquisition of feedback from end users.
 • Configuration and project management. In the context of AUP, configuration
 management (Chapter 22) addresses change management, risk manage
ment, and the control of any persistent work products17 that are produced by
 the team. Project management tracks and controls the progress of the team
 and coordinates team activities.
 • Environment management. Environment management coordinates a process
 infrastructure that includes standards, tools, and other support technology
 available to the team.
 Although the AUP has historical and technical connections to the Unified Modeling
 Language, it is important to note that UML modeling can be using in conjunction
 with any of the agile process models described in Section 3.5.
 SOFTWARE TOOLS
 Agile Development
 Objective: The objective of agile development
 tools is to assist in one or more aspects of agile
 development with an emphasis on facilitating the rapid
 generation of operational software. These tools can also
 be used when prescriptive process models (Chapter 2) are
 applied.
 Mechanics: Tool mechanics vary. In general, agile tool
 sets encompass automated support for project planning,
 use case development and requirements gathering, rapid
 design, code generation, and testing.
 Representative Tools:18
 Note: Because agile development is a hot topic, most
 software tools vendors purport to sell tools that support 
the agile approach. The tools noted here have
 characteristics that make them particularly useful for
 agile projects.
 OnTime, developed by Axosoft (www.axosoft.com),
 provides agile process management support for
 various technical activities within the process.
 Ideogramic UML, developed by Ideogramic
 (www.ideogramic.com) is a UML tool set
 specifically developed for use within an agile 
process.
 Together Tool Set, distributed by Borland
 (www.borland.com), provides a tools suite that
 supports many technical activities within XP and other
 agile processes.
 17 A persistent work product is a model or document or test case produced by the team that will be kept
 for an indeterminate period of time. It will not be discarded once the software increment is
 delivered.
 18 Tools noted here do not represent an endorsement, but rather a sampling of tools in this category.
 In most cases, tool names are trademarked by their respective developers.
91
 CHAPTER 3 AGILE DEVELOPMENT
 3.6 A TOOL SET FOR THE AGILE PROCESS
 The “tool set” that
 supports agile
 processes focuses
 more on people issues
 than it does on
 technology issues.
 Some proponents of the agile philosophy argue that automated software tools (e.g.,
 design tools) should be viewed as a minor supplement to the team’s activities, and
 not at all pivotal to the success of the team. However, Alistair Cockburn [Coc04] sug
gests that tools can have a benefit and that “agile teams stress using tools that per
mit the rapid flow of understanding. Some of those tools are social, starting even at
 the hiring stage. Some tools are technological, helping distributed teams simulate
 being physically present. Many tools are physical, allowing people to manipulate
 them in workshops.”
 Because acquiring the right people (hiring), team collaboration, stakeholder com
munication, and indirect management are key elements in virtually all agile process
 models, Cockburn argues that “tools” that address these issues are critical success
 factors for agility. For example, a hiring “tool” might be the requirement to have a
 prospective team member spend a few hours pair programming with an existing
 member of the team. The “fit” can be assessed immediately.
 Collaborative and communication “tools” are generally low tech and incorporate
 any mechanism (“physical proximity, whiteboards, poster sheets, index cards, and
 sticky notes” [Coc04]) that provides information and coordination among agile de
velopers. Active communication is achieved via the team dynamics (e.g., pair pro
gramming), while passive communication is achieved by “information radiators”
 (e.g., a flat panel display that presents the overall status of different components of
 an increment). Project management tools deemphasize the Gantt chart and replace
 it with earned value charts or “graphs of tests created versus passed . . . other agile
 tools are used to optimize the environment in which the agile team works (e.g., more
 efficient meeting areas), improve the team culture by nurturing social interactions
 (e.g., collocated teams), physical devices (e.g., electronic whiteboards), and process
 enhancement (e.g., pair programming or time-boxing)” [Coc04].
 Are any of these things really tools? They are, if they facilitate the work performed
 by an agile team member and enhance the quality of the end product.
 3.7 SUMMARY
 In a modern economy, market conditions change rapidly, customer and end-user
 needs evolve, and new competitive threats emerge without warning. Practitioners
 must approach software engineering in a manner that allows them to remain agile—
 to define maneuverable, adaptive, lean processes that can accommodate the needs
 of modern business.
 An agile philosophy for software engineering stresses four key issues: the impor
tance of self-organizing teams that have control over the work they perform, com
munication and collaboration between team members and between practitioners
 and their customers, a recognition that change represents an opportunity, and
92
 PART ONE THE SOFTWARE PROCESS
 an emphasis on rapid delivery of software that satisfies the customer. Agile process
 models have been designed to address each of these issues.
 Extreme programming (XP) is the most widely used agile process. Organized as
 four framework activities—planning, design, coding, and testing—XP suggests a
 number of innovative and powerful techniques that allow an agile team to create
 frequent software releases that deliver features and functionality that have been de
scribed and then prioritized by stakeholders.
 Other agile process models also stress human collaboration and team self
organization, but define their own framework activities and select different points of
 emphasis. For example, ASD uses an iterative process that incorporates adaptive
 cycle planning, relatively rigorous requirement gathering methods, and an iterative
 development cycle that incorporates customer focus groups and formal technical re
views as real-time feedback mechanisms. Scrum emphasizes the use of a set of soft
ware process patterns that have proven effective for projects with tight time lines,
 changing requirements, and business criticality. Each process pattern defines a set
 of development tasks and allows the Scrum team to construct a process that is
 adapted to the needs of the project. The Dynamic Systems Development Method
 (DSDM) advocates the use of time-box scheduling and suggests that only enough
 work is required for each software increment to facilitate movement to the next
 increment. Crystal is a family of agile process models that can be adopted to the spe
cific characteristics of a project.
 Feature Driven Development (FDD) is somewhat more “formal” than other agile
 methods, but still maintains agility by focusing the project team on the development
 of features—a client-valued function that can be implemented in two weeks or less.
 Lean Software Development (LSD) has adapted the principles of lean manufacturing
 to the world of software engineering. Agile modeling (AM) suggests that modeling is
 essential for all systems, but that the complexity, type, and size of the model must be
 tuned to the software to be built. The Agile Unified Process (AUP) adopts a “serial in
 the large” and “iterative in the small” philosophy for building software.
 PROBLEMS AND POINTS TO PONDER
 3.1. Reread “The Manifesto for Agile Software Development” at the beginning of this chapter.
 Can you think of a situation in which one or more of the four “values” could get a software team
 into trouble?
 3.2. Describe agility (for software projects) in your own words.
 3.3. Why does an iterative process make it easier to manage change? Is every agile process dis
cussed in this chapter iterative? Is it possible to complete a project in just one iteration and still
 be agile? Explain your answers.
 3.4. Could each of the agile processes be described using the generic framework activities
 noted in Chapter 2? Build a table that maps the generic activities into the activities defined for
 each agile process.
 3.5. Try to come up with one more “agility principle” that would help a software engineering
 team become even more maneuverable.
93
 CHAPTER 3 AGILE DEVELOPMENT
 3.6. Select one agility principle noted in Section 3.3.1 and try to determine whether each of the
 process models presented in this chapter exhibits the principle. [Note: I have presented an
 overview of these process models only, so it may not be possible to determine whether a prin
ciple has been addressed by one or more of the models, unless you do additional research
 (which is not required for this problem).]
 3.7. Why do requirements change so much? After all, don’t people know what they want?
 3.8. Most agile process models recommend face-to-face communication. Yet today, members
 of a software team and their customers may be geographically separated from one another. Do
 you think this implies that geographical separation is something to avoid? Can you think of ways
 to overcome this problem?
 3.9. Write an XP user story that describes the “favorite places” or “bookmarks” feature avail
able on most Web browsers.
 3.10. What is a spike solution in XP?
 3.11. Describe the XP concepts of refactoring and pair programming in your own words.
 3.12. Do a bit more reading and describe what a time-box is. How does this assist an ASD team
 in delivering software increments in a short time period?
 3.13. Do the 80 percent rule in DSDM and the time-boxing approach defined for ASD achieve
 the same result?
 3.14. Using the process pattern template presented in Chapter 2, develop a process pattern for
 any one of the Scrum patterns presented in Section 3.5.2.
 3.15. Why is Crystal called a family of agile methods?
 3.16. Using the FDD feature template described in Section 3.5.5, define a feature set for a Web
 browser. Now develop a set of features for the feature set.
 3.17. Visit the Official Agile Modeling Site and make a complete list of all core and supple
mentary AM principles.
 3.18. The tool set proposed in Section 3.6 supports many of the “soft” aspects of agile meth
ods. Since communication is so important, recommend an actual tool set that might be used to
 enhance communication among stakeholders on an agile team.
 FURTHER READINGS AND INFORMATION SOURCES
 The overall philosophy and underlying principles of agile software development are considered
 in depth in many of the books referenced in the body of this chapter. In addition, books by Shaw
 and Warden (The Art of Agile Development, O’Reilly Media, Inc., 2008), Hunt (Agile Software Con
struction, Springer, 2005), and Carmichael and Haywood (Better Software Faster, Prentice-Hall,
 2002) present useful discussions of the subject. Aguanno (Managing Agile Projects, Multi
Media Publications, 2005), Highsmith (Agile Project Management: Creating Innovative Products,
 Addison-Wesley, 2004), and Larman (Agile and Iterative Development: A Manager’s Guide,
 Addison-Wesley, 2003) present a management overview and consider project management
 issues. Highsmith (Agile Software Development Ecosystems, Addison-Wesley, 2002) presents a
 survey of agile principles, processes, and practices. A worthwhile discussion of the delicate bal
ance between agility and discipline is presented by Booch and his colleagues (Balancing Agility
 and Discipline, Addison-Wesley, 2004).
 Martin (Clean Code: A Handbook of Agile Software Craftsmanship, Prentice-Hall, 2009) pres
ents the principles, patterns, and practices required to develop “clean code” in an agile software
 engineering environment. Leffingwell (Scaling Software Agility: Best Practices for Large Enter
prises, Addison-Wesley, 2007) discusses strategies for scaling up agile practices for large proj
ects. Lippert and Rook (Refactoring in Large Software Projects: Performing Complex Restructurings
 Successfully, Wiley, 2006) discuss the use of refactoring when applied in large, complex systems.
94
 PART ONE THE SOFTWARE PROCESS
 Stamelos and Sfetsos (Agile Software Development Quality Assurance, IGI Global, 2007) discuss
 SQA techniques that conform to the agile philosophy.
 Dozens of books have been written about Extreme Programming over the past decade. Beck
 (Extreme Programming Explained: Embrace Change, 2d ed., Addison-Wesley, 2004) remains the
 definitive treatment of the subject. In addition, Jeffries and his colleagues (Extreme Programming
 Installed, Addison-Wesley, 2000), Succi and Marchesi (Extreme Programming Examined,
 Addison-Wesley, 2001), Newkirk and Martin (Extreme Programming in Practice, Addison-Wesley,
 2001), and Auer and his colleagues (Extreme Programming Applied: Play to Win, Addison-Wesley,
 2001) provide a nuts-and-bolts discussion of XP along with guidance on how best to apply it.
 McBreen (Questioning Extreme Programming, Addison-Wesley, 2003) takes a critical look at XP,
 defining when and where it is appropriate. An in-depth consideration of pair programming is
 presented by McBreen (Pair Programming Illuminated, Addison-Wesley, 2003).
 ASD is addressed in depth by Highsmith [Hig00]. Schwaber (The Enterprise and Scrum,
 Microsoft Press, 2007) discusses the use of Scrum for projects that have a major business
 impact. The nuts and bolts of Scrum are discussed by Schwaber and Beedle (Agile Software
 Development with SCRUM, Prentice-Hall, 2001). Worthwhile treatments of DSDM have been
 written by the DSDM Consortium (DSDM: Business Focused Development, 2d ed., Pearson Edu
cation, 2003) and Stapleton (DSDM: The Method in Practice, Addison-Wesley, 1997). Cockburn
 (Crystal Clear, Addison-Wesley, 2005) presents an excellent overview of the Crystal family of
 processes. Palmer and Felsing [Pal02] present a detailed treatment of FDD. Carmichael and
 Haywood (Better Software Faster, Prentice-Hall, 2002) provides another useful treatment of FDD
 that includes a step-by-step journey through the mechanics of the process. Poppendieck and 
Poppendieck (Lean Development: An Agile Toolkit for Software Development Managers, Addison
Wesley, 2003) provide guidelines for managing and controlling agile projects. Ambler and
 Jeffries (Agile Modeling, Wiley, 2002) discuss AM in some depth.
 A wide variety of information sources on agile software development are available on the
 Internet. An up-to-date list of World Wide Web references that are relevant to the agile process
 can be found at the SEPA website: www.mhhe.com/engcs/compsci/pressman/
 professional/olc/ser.htm.
In 2001, Kent Beck and 16 other noted software developers, writers, and con
sultants [Bec01a] (referred to as the “Agile Alliance”) signed the “Manifesto for
 Agile Software Development.” It stated:
 We are uncovering better ways of developing software by doing it and helping others
 do it. Through this work we have come to value: 
Individuals and interactions over processes and tools
 Working software over comprehensive documentation
 Customer collaboration over contract negotiation
 Responding to change over following a plan
 That is, while there is value in the items on the right, we value the items on the 
left more.
 QUICK
 LOOK
 What is it? Agile software engi
neering combines a philosophy and
 a set of development guidelines. The
 philosophy encourages customer
 satisfaction and early incremental delivery of
 software; small, highly motivated project teams;
 informal methods; minimal software engineer
ing work products; and overall development
 simplicity. The development guidelines stress
 delivery over analysis and design (although
 these activities are not discouraged), and active
 and continuous communication between devel
opers and customers.
 Who does it? Software engineers and other
 project stakeholders (managers, customers, end
 users) work together on an agile team—a team
 that is self-organizing and in control of its own
 destiny. An agile team fosters communication
 and collaboration among all who serve on it.
 Why is it important? The modern business envi
ronment that spawns computer-based systems
 and software products is fast-paced and ever
changing. Agile software engineering repre
sents a reasonable alternative to conventional
 software engineering for certain classes of soft
ware and certain types of software projects. It
 has been demonstrated to deliver successful sys
tems quickly.
 Whatarethesteps? Agiledevelopmentmightbest
 be termed “software engineering lite.” The basic
 framework activities—communication, planning,
 modeling, construction, and deployment—
 remain. But they morph into a minimal task set
 that pushes the project team toward construction
 and delivery (some would argue that this is
 done at the expense of problem analysis and
 solution design).
 What is the work product? Both the customer
 and the software engineer have the same
 view—the only really important work product
 is an operational “software increment” that is
 delivered to the customer on the appropriate
 commitment date.
 How do I ensure that I’ve done it right? If the
 agile team agrees that the process works, and
 the team produces deliverable software
 increments that satisfy the customer, you’ve
 done it right.
 65
66
 PART ONE THE SOFTWARE PROCESS
 FDD . . . . . . . . . .86
 Industrial XP . . .77
 Lean Software
 Development . . .87
 pair 
programming . . .76
 project 
velocity . . . . . . .74
 refactoring . . . . .75
 Scrum . . . . . . . .82
 stories . . . . . . . .74
 XP process . . . . .73
 uote:
 “Agility: 1,
 everything else: 0.”
 Tom DeMarco
 A manifesto is normally associated with an emerging political movement—one
 that attacks the old guard and suggests revolutionary change (hopefully for the
 better). In some ways, that’s exactly what agile development is all about.
 Although the underlying ideas that guide agile development have been with us for
 many years, it has been less than two decades since these ideas have crystallized
 into a “movement.” In essence, agile1 methods were developed in an effort to over
come perceived and actual weaknesses in conventional software engineering. Agile
 development can provide important benefits, but it is not applicable to all projects,
 all products, all people, and all situations. It is also not antithetical to solid software
 engineering practice and can be applied as an overriding philosophy for all software
 work.
 In the modern economy, it is often difficult or impossible to predict how a
 computer-based system (e.g., a Web-based application) will evolve as time passes.
 Market conditions change rapidly, end-user needs evolve, and new competitive
 threats emerge without warning. In many situations, you won’t be able to define
 requirements fully before the project begins. You must be agile enough to respond to
 a fluid business environment.
 Fluidity implies change, and change is expensive. Particularly if it is uncontrolled
 or poorly managed. One of the most compelling characteristics of the agile approach
 is its ability to reduce the costs of change throughout the software process.
 Does this mean that a recognition of challenges posed by modern realities causes
 you to discard valuable software engineering principles, concepts, methods, and
 tools? Absolutely not! Like all engineering disciplines, software engineering contin
ues to evolve. It can be adapted easily to meet the challenges posed by a demand for
 agility.
 In a thought-provoking book on agile software development, Alistair Cockburn
 [Coc02] argues that the prescriptive process models introduced in Chapter 2 have a
 major failing: they forget the frailties of the people who build computer software. Software
 engineers are not robots. They exhibit great variation in working styles; significant dif
ferences in skill level, creativity, orderliness, consistency, and spontaneity. Some com
municate well in written form, others do not. Cockburn argues that process models
 can “deal with people’s common weaknesses with [either] discipline or tolerance” and
 that most prescriptive process models choose discipline. He states: “Because consis
tency in action is a human weakness, high discipline methodologies are fragile.”
 If process models are to work, they must provide a realistic mechanism for en
couraging the discipline that is necessary, or they must be characterized in a man
ner that shows “tolerance” for the people who do software engineering work.
 Invariably, tolerant practices are easier for software people to adopt and sustain, but
 (as Cockburn admits) they may be less productive. Like most things in life, trade-offs
 must be considered.
 1 Agile methods are sometimes referred to as light methods or lean methods.
67
 CHAPTER 3 AGILE DEVELOPMENT
 3.1 WHAT IS AGILITY?
 Just what is agility in the context of software engineering work? Ivar Jacobson
 [Jac02a] provides a useful discussion:
 Agility has become today’s buzzword when describing a modern software process. Every
one is agile. An agile team is a nimble team able to appropriately respond to changes.
 Change is what software development is very much about. Changes in the software be
ing built, changes to the team members, changes because of new technology, changes of
 all kinds that may have an impact on the product they build or the project that creates the
 product. Support for changes should be built-in everything we do in software, something
 we embrace because it is the heart and soul of software. An agile team recognizes that
 software is developed by individuals working in teams and that the skills of these people,
 their ability to collaborate is at the core for the success of the project.
 Don’t make the
 mistake of assuming
 that agility gives you
 license to hack out
 solutions. A process is
 required and discipline
 is essential.
 In Jacobson’s view, the pervasiveness of change is the primary driver for agility. Soft
ware engineers must be quick on their feet if they are to accommodate the rapid
 changes that Jacobson describes.
 But agility is more than an effective response to change. It also encompasses the
 philosophy espoused in the manifesto noted at the beginning of this chapter. It
 encourages team structures and attitudes that make communication (among team
 members, between technologists and business people, between software engineers
 and their managers) more facile. It emphasizes rapid delivery of operational soft
ware and de-emphasizes the importance of intermediate work products (not always
 a good thing); it adopts the customer as a part of the development team and works
 to eliminate the “us and them” attitude that continues to pervade many software
 projects; it recognizes that planning in an uncertain world has its limits and that a
 project plan must be flexible.
 Agility can be applied to any software process. However, to accomplish this, it is
 essential that the process be designed in a way that allows the project team to adapt
 tasks and to streamline them, conduct planning in a way that understands the fluid
ity of an agile development approach, eliminate all but the most essential work prod
ucts and keep them lean, and emphasize an incremental delivery strategy that gets
 working software to the customer as rapidly as feasible for the product type and
 operational environment.
 3.2 AGILITY AND THE COST OF CHANGE
 The conventional wisdom in software development (supported by decades of expe
rience) is that the cost of change increases nonlinearly as a project progresses
 (Figure 3.1, solid black curve). It is relatively easy to accommodate a change when a
 software team is gathering requirements (early in a project). A usage scenario might
 have to be modified, a list of functions may be extended, or a written specification
 can be edited. The costs of doing this work are minimal, and the time required will
68
 PART ONE THE SOFTWARE PROCESS
 FIGURE 3.1
 Change costs
 as a function
 of time in
 development
 uote:
 Development cost
 Cost of change
 using conventional
 software processes
 Cost of change
 using agile processes
 “Agility is dynamic,
 content specific,
 aggressively
 change embracing,
 and growth
 oriented.”
 Idealized cost of change
 using agile process
 Development schedule progress–Steven
 Goldman et al.
 An agile process
 reduces the cost of
 change because
 software is released in
 increments and change
 can be better
 controlled within an
 increment.
 not adversely affect the outcome of the project. But what if we fast-forward a num
ber of months? The team is in the middle of validation testing (something that occurs
 relatively late in the project), and an important stakeholder is requesting a major
 functional change. The change requires a modification to the architectural design of
 the software, the design and construction of three new components, modifications
 to another five components, the design of new tests, and so on. Costs escalate
 quickly, and the time and cost required to ensure that the change is made without
 unintended side effects is nontrivial.
 Proponents of agility (e.g., [Bec00], [Amb04]) argue that a well-designed agile
 process “flattens” the cost of change curve (Figure 3.1, shaded, solid curve), allowing
 a software team to accommodate changes late in a software project without dramatic
 cost and time impact. You’ve already learned that the agile process encompasses in
cremental delivery. When incremental delivery is coupled with other agile practices
 such as continuous unit testing and pair programming (discussed later in this chap
ter), the cost of making a change is attenuated. Although debate about the degree to
 which the cost curve flattens is ongoing, there is evidence [Coc01a] to suggest that a
 significant reduction in the cost of change can be achieved.
 3.3 WHAT IS ANAGILE PROCESS?
 Any agile software process is characterized in a manner that addresses a number of
 key assumptions [Fow02] about the majority of software projects: 
1. It is difficult to predict in advance which software requirements will persist
 and which will change. It is equally difficult to predict how customer
 priorities will change as the project proceeds.
69
 CHAPTER 3 AGILE DEVELOPMENT
 WebRef
 A comprehensive
 collection of articles on
 the agile process 
can be found at
 www.aanpo.org/
 articles/index.
 Although agile
 processes embrace
 change, it is still
 important to examine
 the reasons for
 change.
 Working software is
 important, but don’t
 forget that it must also
 exhibit a variety of
 quality attributes
 including reliability,
 usability, and 
maintainability.
 2. For many types of software, design and construction are interleaved. That is,
 both activities should be performed in tandem so that design models are
 proven as they are created. It is difficult to predict how much design is
 necessary before construction is used to prove the design.
 3. Analysis, design, construction, and testing are not as predictable (from a
 planning point of view) as we might like.
 Given these three assumptions, an important question arises: How do we create a
 process that can manage unpredictability? The answer, as I have already noted, lies
 in process adaptability (to rapidly changing project and technical conditions). An
 agile process, therefore, must be adaptable.
 But continual adaptation without forward progress accomplishes little. Therefore,
 an agile software process must adapt incrementally. To accomplish incremental adap
tation, an agile team requires customer feedback (so that the appropriate adaptations
 can be made). An effective catalyst for customer feedback is an operational prototype
 or a portion of an operational system. Hence, an incremental development strategy
 should be instituted. Software increments (executable prototypes or portions of an op
erational system) must be delivered in short time periods so that adaptation keeps pace
 with change (unpredictability). This iterative approach enables the customer to evalu
ate the software increment regularly, provide necessary feedback to the software team,
 and influence the process adaptations that are made to accommodate the feedback.
 3.3.1 Agility Principles
 The Agile Alliance (see [Agi03], [Fow01]) defines 12 agility principles for those who
 want to achieve agility: 
1. Our highest priority is to satisfy the customer through early and continuous
 delivery of valuable software.
 2. Welcome changing requirements, even late in development. Agile processes
 harness change for the customer’s competitive advantage.
 3. Deliver working software frequently, from a couple of weeks to a couple of
 months, with a preference to the shorter timescale.
 4. Business people and developers must work together daily throughout the
 project.
 5. Build projects around motivated individuals. Give them the environment and
 support they need, and trust them to get the job done.
 6. The most efficient and effective method of conveying information to and
 within a development team is face-to-face conversation.
 7. Working software is the primary measure of progress.
 8. Agile processes promote sustainable development. The sponsors, developers,
 and users should be able to maintain a constant pace indefinitely.
70
 PART ONE THE SOFTWARE PROCESS
 9. Continuous attention to technical excellence and good design enhances
 agility.
 10. Simplicity—the art of maximizing the amount of work not done—is 
essential.
 11. The best architectures, requirements, and designs emerge from self
organizing teams.
 12. At regular intervals, the team reflects on how to become more effective, then
 tunes and adjusts its behavior accordingly.
 Not every agile process model applies these 12 principles with equal weight, and
 some models choose to ignore (or at least downplay) the importance of one or more
 of the principles. However, the principles define an agile spirit that is maintained in
 each of the process models presented in this chapter.
 3.3.2 The Politics of Agile Development
 You don’t have to
 choose between agility
 and software engi
neering. Rather, define
 a software engineering
 approach that is agile.
 There is considerable debate (sometimes strident) about the benefits and applicabil
ity of agile software development as opposed to more conventional software engi
neering processes. Jim Highsmith [Hig02a] (facetiously) states the extremes when he
 characterizes the feeling of the pro-agility camp (“agilists”). “Traditional methodolo
gists are a bunch of stick-in-the-muds who’d rather produce flawless documentation
 than a working system that meets business needs.” As a counterpoint, he states
 (again, facetiously) the position of the traditional software engineering camp: “Light
weight, er, ‘agile’ methodologists are a bunch of glorified hackers who are going to
 be in for a heck of a surprise when they try to scale up their toys into enterprise-wide
 software.”
 Like all software technology arguments, this methodology debate risks degener
ating into a religious war. If warfare breaks out, rational thought disappears and
 beliefs rather than facts guide decision making.
 No one is against agility. The real question is: What is the best way to achieve it?
 As important, how do you build software that meets customers’ needs today and
 exhibits the quality characteristics that will enable it to be extended and scaled to
 meet customers’ needs over the long term?
 There are no absolute answers to either of these questions. Even within the agile
 school itself, there are many proposed process models (Section 3.4), each with a
 subtly different approach to the agility problem. Within each model there is a set of
 “ideas” (agilists are loath to call them “work tasks”) that represent a significant
 departure from traditional software engineering. And yet, many agile concepts are
 simply adaptations of good software engineering concepts. Bottom line: there is
 much that can be gained by considering the best of both schools and virtually
 nothing to be gained by denigrating either approach.
 If you have further interest, see [Hig01], [Hig02a], and [DeM02] for an entertain
ing summary of other important technical and political issues.
71
 CHAPTER 3 AGILE DEVELOPMENT
 uote:
 “Agile methods
 derive much of
 their agility by
 relying on the
 tacit knowledge
 embodied in the
 team, rather than
 writing the
 knowledge down
 in plans.”
 Barry Boehm
 ?
 What key
 traits must
 exist among the
 people on an
 effective software
 team?
 uote:
 “What counts as
 barely sufficient
 for one team is
 either overly
 sufficient or
 insufficient for
 another.”
 Alistair
 Cockburn
 3.3.3 Human Factors
 Proponents of agile software development take great pains to emphasize the impor
tance of “people factors.” As Cockburn and Highsmith [Coc01a] state, “Agile devel
opment focuses on the talents and skills of individuals, molding the process to
 specific people and teams.” The key point in this statement is that the process molds
 to the needs of the people and team, not the other way around.2
 If members of the software team are to drive the characteristics of the process that
 is applied to build software, a number of key traits must exist among the people on
 an agile team and the team itself:
 Competence. In an agile development (as well as software engineering)
 context, “competence” encompasses innate talent, specific software-related
 skills, and overall knowledge of the process that the team has chosen to
 apply. Skill and knowledge of process can and should be taught to all people
 who serve as agile team members.
 Common focus. Although members of the agile team may perform differ
ent tasks and bring different skills to the project, all should be focused on one
 goal—to deliver a working software increment to the customer within the
 time promised. To achieve this goal, the team will also focus on continual
 adaptations (small and large) that will make the process fit the needs of the
 team.
 Collaboration. Software engineering (regardless of process) is about as
sessing, analyzing, and using information that is communicated to the soft
ware team; creating information that will help all stakeholders understand
 the work of the team; and building information (computer software and rele
vant databases) that provides business value for the customer. To accomplish
 these tasks, team members must collaborate—with one another and all other
 stakeholders.
 Decision-making ability. Any good software team (including agile teams)
 must be allowed the freedom to control its own destiny. This implies that the
 team is given autonomy—decision-making authority for both technical and
 project issues.
 Fuzzy problem-solving ability. Software managers must recognize that
 the agile team will continually have to deal with ambiguity and will continu
ally be buffeted by change. In some cases, the team must accept the fact that
 the problem they are solving today may not be the problem that needs to be
 solved tomorrow. However, lessons learned from any problem-solving
 2 Successful software engineering organizations recognize this reality regardless of the process
 model they choose.
72
 PART ONE THE SOFTWARE PROCESS
 A self-organizing team
 is in control of the
 work it performs. The
 team makes its own
 commitments and
 defines plans to
 achieve them.
 activity (including those that solve the wrong problem) may be of benefit to
 the team later in the project.
 Mutual trust and respect. The agile team must become what DeMarco
 and Lister [DeM98] call a “jelled” team (Chapter 24). A jelled team exhibits
 the trust and respect that are necessary to make them “so strongly knit that
 the whole is greater than the sum of the parts.” [DeM98]
 Self-organization. In the context of agile development, self-organization
 implies three things: (1) the agile team organizes itself for the work to be
 done, (2) the team organizes the process to best accommodate its local envi
ronment, (3) the team organizes the work schedule to best achieve delivery
 of the software increment. Self-organization has a number of technical bene
fits, but more importantly, it serves to improve collaboration and boost team
 morale. In essence, the team serves as its own management. Ken Schwaber
 [Sch02] addresses these issues when he writes: “The team selects how much
 work it believes it can perform within the iteration, and the team commits to
 the work. Nothing demotivates a team as much as someone else making
 commitments for it. Nothing motivates a team as much as accepting the
 responsibility for fulfilling commitments that it made itself.”
 3.4 EXTREME PROGRAMMING (XP)
 In order to illustrate an agile process in a bit more detail, I’ll provide you with an
 overview of Extreme Programming (XP), the most widely used approach to agile soft
ware development. Although early work on the ideas and methods associated with
 XP occurred during the late 1980s, the seminal work on the subject has been written
 by Kent Beck [Bec04a]. More recently, a variant of XP, called Industrial XP (IXP) has
 been proposed [Ker05]. IXP refines XP and targets the agile process specifically for
 use within large organizations.
 3.4.1 XP Values
 Beck [Bec04a] defines a set of five values that establish a foundation for all work per
formed as part of XP—communication, simplicity, feedback, courage, and respect. Each
 of these values is used as a driver for specific XP activities, actions, and tasks.
 In order to achieve effective communication between software engineers and
 other stakeholders (e.g., to establish required features and functions for the soft
ware), XP emphasizes close, yet informal (verbal) collaboration between customers
 and developers, the establishment of effective metaphors3 for communicating
 important concepts, continuous feedback, and the avoidance of voluminous docu
mentation as a communication medium.
 3 In the XP context, a metaphor is “a story that everyone—customers, programmers, and managers—
 can tell about how the system works” [Bec04a].
73
 CHAPTER 3 AGILE DEVELOPMENT
 Keep it simple
 whenever you can, but
 recognize that
 continual “refactoring”
 can absorb significant
 time and resources.
 uote:
 “XP is the answer
 to the question,
 ‘How little can we
 do and still build
 great software?’“
 Anonymous
 WebRef
 An excellent overview
 of “rules” for XP can
 be found at www
 .extremeprogramm
 ing.org/rules.html.
 To achieve simplicity, XP restricts developers to design only for immediate needs,
 rather than consider future needs. The intent is to create a simple design that can be
 easily implemented in code). If the design must be improved, it can be refactored4 at
 a later time.
 Feedback is derived from three sources: the implemented software itself, the
 customer, and other software team members. By designing and implementing an
 effective testing strategy (Chapters 17 through 20), the software (via test results) pro
vides the agile team with feedback. XP makes use of the unit test as its primary test
ing tactic. As each class is developed, the team develops a unit test to exercise each
 operation according to its specified functionality. As an increment is delivered to a
 customer, the user stories or use cases (Chapter 5) that are implemented by the
 increment are used as a basis for acceptance tests. The degree to which the software
 implements the output, function, and behavior of the use case is a form of feedback.
 Finally, as new requirements are derived as part of iterative planning, the team pro
vides the customer with rapid feedback regarding cost and schedule impact.
 Beck [Bec04a] argues that strict adherence to certain XP practices demands
 courage. A better word might be discipline. For example, there is often significant
 pressure to design for future requirements. Most software teams succumb, arguing
 that “designing for tomorrow” will save time and effort in the long run. An agile XP
 team must have the discipline (courage) to design for today, recognizing that future
 requirements may change dramatically, thereby demanding substantial rework of
 the design and implemented code.
 By following each of these values, the agile team inculcates respect among it
 members, between other stakeholders and team members, and indirectly, for the
 software itself. As they achieve successful delivery of software increments, the team
 develops growing respect for the XP process.
 3.4.2 The XP Process
 Extreme Programming uses an object-oriented approach (Appendix 2) as its pre
ferred development paradigm and encompasses a set of rules and practices that
 occur within the context of four framework activities: planning, design, coding, and
 testing. Figure 3.2 illustrates the XP process and notes some of the key ideas and
 tasks that are associated with each framework activity. Key XP activities are sum
marized in the paragraphs that follow.
 Planning. The planning activity (also called the planning game) begins with
 listening—a requirements gathering activity that enables the technical members of
 the XP team to understand the business context for the software and to get a broad
 4 Refactoring allows a software engineer to improve the internal structure of a design (or source
 code) without changing its external functionality or behavior. In essence, refactoring can be used
 to improve the efficiency, readability, or performance of a design or the code that implements a
 design.
74
 PART ONE THE SOFTWARE PROCESS
 FIGURE 3.2
 The Extreme
 Programming
 process
 ?
 What is an
 XP “story”?
 WebRef
 A worthwhile XP
 “planning game” can
 be found at:
 c2.com/cgi/
 wiki?planningGame.
 simple design
 CRC cards
 user stories
 values
 acceptance test criteria
 iteration plan
 Release
 spike solutions
 prototypes
 refactoring
 design
 pair programming
 planning
 software increment
 project velocity computed
 unit test
 continuous integration
 acceptance testing
 test
 coding
 feel for required output and major features and functionality. Listening leads to the
 creation of a set of “stories” (also called user stories) that describe required output,
 features, and functionality for software to be built. Each story (similar to use cases
 described in Chapter 5) is written by the customer and is placed on an index card.
 The customer assigns a value (i.e., a priority) to the story based on the overall busi
ness value of the feature or function.5 Members of the XP team then assess each
 story and assign a cost—measured in development weeks—to it. If the story is esti
mated to require more than three development weeks, the customer is asked to split
 the story into smaller stories and the assignment of value and cost occurs again. It
 is important to note that new stories can be written at any time.
 Customers and developers work together to decide how to group stories into the
 next release (the next software increment) to be developed by the XP team. Once a
 basic commitment (agreement on stories to be included, delivery date, and other
 project matters) is made for a release, the XP team orders the stories that will be de
veloped in one of three ways: (1) all stories will be implemented immediately (within
 a few weeks), (2) the stories with highest value will be moved up in the schedule and
 implemented first, or (3) the riskiest stories will be moved up in the schedule and
 implemented first.
 After the first project release (also called a software increment) has been deliv
ered, the XP team computes project velocity. Stated simply, project velocity is the
 5 The value of a story may also be dependent on the presence of another story.
75
 CHAPTER 3 AGILE DEVELOPMENT
 Project velocity is a
 subtle measure of
 team productivity.
 XP deemphasizes the
 importance of design.
 Not everyone agrees.
 In fact, there are times
 when design should be
 emphasized.
 WebRef
 Refactoring techniques
 and tools can be
 found at:
 www.refactoring
 .com.
 number of customer stories implemented during the first release. Project velocity can
 then be used to (1) help estimate delivery dates and schedule for subsequent releases
 and (2) determine whether an overcommitment has been made for all stories across
 the entire development project. If an overcommitment occurs, the content of releases
 is modified or end delivery dates are changed.
 As development work proceeds, the customer can add stories, change the value
 of an existing story, split stories, or eliminate them. The XP team then reconsiders all
 remaining releases and modifies its plans accordingly.
 Design. XP design rigorously follows the KIS (keep it simple) principle. A simple
 design is always preferred over a more complex representation. In addition, the de
sign provides implementation guidance for a story as it is written—nothing less,
 nothing more. The design of extra functionality (because the developer assumes it
 will be required later) is discouraged.6
 XP encourages the use of CRC cards (Chapter 7) as an effective mechanism for
 thinking about the software in an object-oriented context. CRC (class-responsibility
collaborator) cards identify and organize the object-oriented classes7 that are rele
vant to the current software increment. The XP team conducts the design exercise
 using a process similar to the one described in Chapter 8. The CRC cards are the only
 design work product produced as part of the XP process.
 If a difficult design problem is encountered as part of the design of a story, XP rec
ommends the immediate creation of an operational prototype of that portion of the
 design. Called a spike solution, the design prototype is implemented and evaluated.
 The intent is to lower risk when true implementation starts and to validate the orig
inal estimates for the story containing the design problem.
 In the preceding section, we noted that XP encourages refactoring—a construction
 technique that is also a method for design optimization. Fowler [Fow00] describes
 refactoring in the following manner:
 Refactoring is the process of changing a software system in such a way that it does not
 alter the external behavior of the code yet improves the internal structure. It is a disci
plined way to clean up code [and modify/simplify the internal design] that minimizes the
 chances of introducing bugs. In essence, when you refactor you are improving the design
 of the code after it has been written.
 Because XP design uses virtually no notation and produces few, if any, work prod
ucts other than CRC cards and spike solutions, design is viewed as a transient arti
fact that can and should be continually modified as construction proceeds. The intent
 of refactoring is to control these modifications by suggesting small design changes
 6 These design guidelines should be followed in every software engineering method, although there
 are times when sophisticated design notation and terminology may get in the way of simplicity.
 7 Object-oriented classes are discussed in Appendix 2, in Chapter 8, and throughout Part 2 of this
 book.
76
 PART ONE THE SOFTWARE PROCESS
 Refactoring improves
 the internal structure of
 a design (or source
 code) without
 changing its external
 functionality or
 behavior.
 WebRef
 Useful information on
 XP can be obtained 
at www
 .xprogramming.
 com.
 ?
 What is 
pair
 programming?
 Many software teams
 are populated by indi
vidualists. You’ll have
 to work to change that
 culture if pair program
ming is to work effec
tively.
 ?
 XP?
 How are unit
 tests used in
 that “can radically improve the design” [Fow00]. It should be noted, however, that
 the effort required for refactoring can grow dramatically as the size of an application
 grows.
 A central notion in XP is that design occurs both before and after coding com
mences. Refactoring means that design occurs continuously as the system is con
structed. In fact, the construction activity itself will provide the XP team with
 guidance on how to improve the design.
 Coding. After stories are developed and preliminary design work is done, the team
 does not move to code, but rather develops a series of unit tests that will exercise
 each of the stories that is to be included in the current release (software increment).8
 Once the unit test9 has been created, the developer is better able to focus on what
 must be implemented to pass the test. Nothing extraneous is added (KIS). Once the
 code is complete, it can be unit-tested immediately, thereby providing instantaneous
 feedback to the developers.
 A key concept during the coding activity (and one of the most talked about aspects
 of XP) is pair programming. XP recommends that two people work together at one
 computer workstation to create code for a story. This provides a mechanism for real
time problem solving (two heads are often better than one) and real-time quality as
surance (the code is reviewed as it is created). It also keeps the developers focused
 on the problem at hand. In practice, each person takes on a slightly different role. For
 example, one person might think about the coding details of a particular portion of
 the design while the other ensures that coding standards (a required part of XP) are
 being followed or that the code for the story will satisfy the unit test that has been
 developed to validate the code against the story.
 As pair programmers complete their work, the code they develop is integrated
 with the work of others. In some cases this is performed on a daily basis by an inte
gration team. In other cases, the pair programmers have integration responsibility.
 This “continuous integration” strategy helps to avoid compatibility and interfacing
 problems and provides a “smoke testing” environment (Chapter 17) that helps to
 uncover errors early.
 Testing. I have already noted that the creation of unit tests before coding com
mences is a key element of the XP approach. The unit tests that are created should
 be implemented using a framework that enables them to be automated (hence, they
 can be executed easily and repeatedly). This encourages a regression testing strat
egy (Chapter 17) whenever code is modified (which is often, given the XP refactor
ing philosophy).
 8 This approach is analogous to knowing the exam questions before you begin to study. It makes
 studying much easier by focusing attention only on the questions that will be asked.
 9 Unit testing, discussed in detail in Chapter 17, focuses on an individual software component, exer
cising the component’s interface, data structures, and functionality in an effort to uncover errors
 that are local to the component.
77
 CHAPTER 3 AGILE DEVELOPMENT
 XP acceptance tests
 are derived from user
 stories.
 ?
 What new
 practices are
 appended to XP
 to create IXP?
 uote:
 “Ability is what
 you’re capable of
 doing. Motivation
 determines what
 you do. Attitude
 determines how
 well you do it.”
 Lou Holtz
 As the individual unit tests are organized into a “universal testing suite” [Wel99],
 integration and validation testing of the system can occur on a daily basis. This pro
vides the XP team with a continual indication of progress and also can raise warn
ing flags early if things go awry. Wells [Wel99] states: “Fixing small problems every
 few hours takes less time than fixing huge problems just before the deadline.”
 XP acceptance tests, also called customer tests, are specified by the customer and
 focus on overall system features and functionality that are visible and reviewable by
 the customer. Acceptance tests are derived from user stories that have been imple
mented as part of a software release.
 3.4.3 Industrial XP
 Joshua Kerievsky [Ker05] describes Industrial Extreme Programming (IXP) in the fol
lowing manner: “IXP is an organic evolution of XP. It is imbued with XP’s minimal
ist, customer-centric, test-driven spirit. IXP differs most from the original XP in its
 greater inclusion of management, its expanded role for customers, and its upgraded
 technical practices.” IXP incorporates six new practices that are designed to help
 ensure that an XP project works successfully for significant projects within a large
 organization.
 Readiness assessment. Prior to the initiation of an IXP project, the organ
ization should conduct a readiness assessment. The assessment ascertains
 whether (1) an appropriate development environment exists to support IXP,
 (2) the team will be populated by the proper set of stakeholders, (3) the or
ganization has a distinct quality program and supports continuous improve
ment, (4) the organizational culture will support the new values of an agile
 team, and (5) the broader project community will be populated appropriately.
 Project community. Classic XP suggests that the right people be used to
 populate the agile team to ensure success. The implication is that people on
 the team must be well-trained, adaptable and skilled, and have the proper
 temperament to contribute to a self-organizing team. When XP is to be
 applied for a significant project in a large organization, the concept of the
 “team” should morph into that of a community. A community may have a
 technologist and customers who are central to the success of a project as
 well as many other stakeholders (e.g., legal staff, quality auditors, manufac
turing or sales types) who “are often at the periphery of an IXP project yet
 they may play important roles on the project” [Ker05]. In IXP, the community
 members and their roles should be explicitly defined and mechanisms for
 communication and coordination between community members should be
 established.
 Project chartering. The IXP team assesses the project itself to determine
 whether an appropriate business justification for the project exists and
 whether the project will further the overall goals and objectives of the
78
 PART ONE THE SOFTWARE PROCESS
 organization. Chartering also examines the context of the project to deter
mine how it complements, extends, or replaces existing systems or
 processes.
 Test-driven management. An IXP project requires measurable criteria for
 assessing the state of the project and the progress that has been made to
 date. Test-driven management establishes a series of measurable “destina
tions” [Ker05] and then defines mechanisms for determining whether or not
 these destinations have been reached.
 Retrospectives. An IXP team conducts a specialized technical review
 (Chapter 15) after a software increment is delivered. Called a retrospective,
 the review examines “issues, events, and lessons-learned” [Ker05] across a
 software increment and/or the entire software release. The intent is to
 improve the IXP process.
 Continuous learning. Because learning is a vital part of continuous
 process improvement, members of the XP team are encouraged (and possi
bly, incented) to learn new methods and techniques that can lead to a higher
quality product.
 In addition to the six new practices discussed, IXP modifies a number of existing
 XP practices. Story-driven development (SDD) insists that stories for acceptance tests
 be written before a single line of code is generated. Domain-driven design (DDD) is
 an improvement on the “system metaphor” concept used in XP. DDD [Eva03] sug
gests the evolutionary creation of a domain model that “accurately represents how
 domain experts think about their subject” [Ker05]. Pairing extends the XP pair
programming concept to include managers and other stakeholders. The intent is to
 improve knowledge sharing among XP team members who may not be directly in
volved in technical development. Iterative usability discourages front-loaded inter
face design in favor of usability design that evolves as software increments are
 delivered and users’ interaction with the software is studied.
 IXP makes smaller modifications to other XP practices and redefines certain roles
 and responsibilities to make them more amenable to significant projects for large
 organizations. For further discussion of IXP, visit http://industrialxp.org.
 3.4.4 The XP Debate
 All new process models and methods spur worthwhile discussion and in some in
stances heated debate. Extreme Programming has done both. In an interesting book
 that examines the efficacy of XP, Stephens and Rosenberg [Ste03] argue that many
 XP practices are worthwhile, but others have been overhyped, and a few are prob
lematic. The authors suggest that the codependent nature of XP practices are both
 its strength and its weakness. Because many organizations adopt only a subset of XP
 practices, they weaken the efficacy of the entire process. Proponents counter that
 XP is continuously evolving and that many of the issues raised by critics have been
79
 CHAPTER 3 AGILE DEVELOPMENT
 addressed as XP practice matures. Among the issues that continue to trouble some
 critics of XP are:10
 ?
 What are
 some of the
 issues that lead to
 an XP debate?
 • Requirements volatility. Because the customer is an active member of the XP
 team, changes to requirements are requested informally. As a consequence,
 the scope of the project can change and earlier work may have to be
 modified to accommodate current needs. Proponents argue that this happens
 regardless of the process that is applied and that XP provides mechanisms for
 controlling scope creep.
 • Conflicting customer needs. Many projects have multiple customers, each with
 his own set of needs. In XP, the team itself is tasked with assimilating the
 needs of different customers, a job that may be beyond their scope of
 authority.
 • Requirements are expressed informally. User stories and acceptance tests are
 the only explicit manifestation of requirements in XP. Critics argue that a
 more formal model or specification is often needed to ensure that omissions,
 inconsistencies, and errors are uncovered before the system is built. Propo
nents counter that the changing nature of requirements makes such models
 and specification obsolete almost as soon as they are developed.
 • Lack of formal design. XP deemphasizes the need for architectural design and
 in many instances, suggests that design of all kinds should be relatively
 informal. Critics argue that when complex systems are built, design must be
 emphasized to ensure that the overall structure of the software will exhibit
 quality and maintainability. XP proponents suggest that the incremental
 nature of the XP process limits complexity (simplicity is a core value) and
 therefore reduces the need for extensive design.
 You should note that every software process has flaws and that many software or
ganizations have used XP successfully. The key is to recognize where a process may
 have weaknesses and to adapt it to the specific needs of your organization.
 SAFEHOME
 Considering Agile Software Development
 The scene: Doug Miller’s office.
 The Players: Doug Miller, software engineering
 manager; Jamie Lazar, software team member; Vinod
 Raman, software team member.
 The conversation:
 (A knock on the door, Jamie and Vinod enter Doug’s office)
 Jamie: Doug, you got a minute?
 10 For a detailed look at some thoughtful criticism that has been leveled at XP, visit
 www.softwarereality.com/ExtremeProgramming.jsp.
3.5 OTHERAGILEPROCESSMODELS
 The history of software engineering is littered with dozens of obsolete process
 descriptions and methodologies, modeling methods and notations, tools, and
 technology. Each flared in notoriety and was then eclipsed by something new and
 (purportedly) better. With the introduction of a wide array of agile process models—
 each contending for acceptance within the software development community—the
 agile movement is following the same historical path.11
 As I noted in the last section, the most widely used of all agile process models
 isExtreme Programming (XP). But many other agile process models have been
 proposed and are in use across the industry. Among the most common are:
 •Adaptive Software Development (ASD)
 •Scrum
 •Dynamic Systems Development Method (DSDM)
 80 PART ONE THE SOFTWARE PROCESS
 Doug: Sure Jamie, what’s up?
 Jamie:We’ve been thinking about our process
 discussion yesterday . . . you know, what process we’re
 going to choose for this new SafeHomeproject.
 Doug:And?
 Vinod: I was talking to a friend at another company,
 and he was telling me about Extreme Programming. It’s
 an agile process model . . . heard of it?
 Doug: Yeah, some good, some bad.
 Jamie:Well, it sounds pretty good to us. Lets you
 develop software really fast, uses something called pair
 programming to do real-time quality checks . . . it’s pretty
 cool, I think.
 Doug: It does have a lot of really good ideas. I like the
 pair-programming concept, for instance, and the idea
 that stakeholders should be part of the team.
 Jamie:Huh? You mean that marketing will work on the
 project team with us?
 Doug (nodding): They’re a stakeholder, aren’t they?
 Jamie: Jeez . . . they’ll be requesting changes every five
 minutes.
 Vinod:Not necessarily. My friend said that there are
 ways to “embrace” changes during an XP project.
 Doug: So you guys think we should use XP?
 Jamie: It’s definitely worth considering.
 Doug: I agree. And even if we choose an incremental
 model as our approach, there’s no reason why we can’t
 incorporate much of what XP has to offer.
 Vinod:Doug, before you said “some good, some bad.”
 What was the “bad”?
 Doug: The thing I don’t like is the way XP downplays
 analysis and design . . . sort of says that writing code is
 where the action is . . . 
(The team members look at one another and smile.)
 Doug: So you agree with the XP approach?
 Jamie (speaking for both):Writing code is what
 we do, Boss!
 Doug (laughing): True, but I’d like to see you spend a
 little less time coding and then recoding and a little more
 time analyzing what has to be done and designing a
 solution that works.
 Vinod:Maybe we can have it both ways, agility with a
 little discipline.
 Doug: I think we can, Vinod. In fact, I’m sure of it.
 uote:
 “Our profession
 goes through
 methodologies like
 a 14-year-old goes
 through clothing.”
 Stephen
 Hawrysh and
 JimRuprecht
 11This is not a bad thing. Before one or more models or methods are accepted as a de facto standard,
 all must contend for the hearts and minds of software engineers. The “winners” evolve into best
 practice, while the “losers” either disappear or merge with the winning models.
81
 CHAPTER 3 AGILE DEVELOPMENT
 • Crystal
 • Feature Drive Development (FDD)
 • Lean Software Development (LSD)
 • Agile Modeling (AM)
 • Agile Unified Process (AUP)
 In the sections that follow, I present a very brief overview of each of these agile
 process models. It is important to note that all agile process models conform (to a
 greater or lesser degree) to the Manifesto for Agile Software Development and the prin
ciples noted in Section 3.3.1. For additional detail, refer to the references noted in
 each subsection or for a survey, examine the “agile software development” entry
 in Wikipedia.12
 3.5.1 Adaptive Software Development (ASD)
 WebRef
 Useful resources for
 ASD can be found at
 www.adaptivesd
 .com.
 Adaptive Software Development (ASD) has been proposed by Jim Highsmith [Hig00] as
 a technique for building complex software and systems. The philosophical under
pinnings of ASD focus on human collaboration and team self-organization.
 Highsmith argues that an agile, adaptive development approach based on collab
oration is “as much a source of order in our complex interactions as discipline and
 engineering.” He defines an ASD “life cycle” (Figure 3.3) that incorporates three
 phases, speculation, collaboration, and learning.
 FIGURE 3.3
 Adaptive
 software
 development
 adaptive cycle planning
 mission statement
 project constraints
 basic requirements
 time-boxed release plan
 Release
 Requirements gathering
 JAD
 mini-specs
 speculation
 software increment
 adjustments for subsequent cycles
 collaboration
 components implemented/tested
 focus groups for feedback
 formal technical reviews
 learning
 postmortems
 12 See http://en.wikipedia.org/wiki/Agile_software_development#Agile_methods.
82
 PART ONE THE SOFTWARE PROCESS
 Effective collaboration
 with your customer will
 only occur if you
 jettison any “us and
 them” attitudes.
 ASD emphasizes
 learning as a key
 element in achieving 
a “self-organizing”
 team.
 WebRef
 Useful Scrum
 information and
 resources can be found
 at www
 .controlchaos.com.
 During speculation, the project is initiated and adaptive cycle planning is con
ducted. Adaptive cycle planning uses project initiation information—the customer’s
 mission statement, project constraints (e.g., delivery dates or user descriptions), and
 basic requirements—to define the set of release cycles (software increments) that
 will be required for the project.
 No matter how complete and farsighted the cycle plan, it will invariably change.
 Based on information obtained at the completion of the first cycle, the plan is re
viewed and adjusted so that planned work better fits the reality in which an ASD
 team is working.
 Motivated people use collaboration in a way that multiplies their talent and cre
ative output beyond their absolute numbers. This approach is a recurring theme in
 all agile methods. But collaboration is not easy. It encompasses communication and
 teamwork, but it also emphasizes individualism, because individual creativity plays
 an important role in collaborative thinking. It is, above all, a matter of trust. People
 working together must trust one another to (1) criticize without animosity, (2) assist
 without resentment, (3) work as hard as or harder than they do, (4) have the skill set
 to contribute to the work at hand, and (5) communicate problems or concerns in a
 way that leads to effective action.
 As members of an ASD team begin to develop the components that are part of an
 adaptive cycle, the emphasis is on “learning” as much as it is on progress toward
 a completed cycle. In fact, Highsmith [Hig00] argues that software developers often
 overestimate their own understanding (of the technology, the process, and the proj
ect) and that learning will help them to improve their level of real understanding.
 ASD teams learn in three ways: focus groups (Chapter 5), technical reviews (Chap
ter 14), and project postmortems.
 The ASD philosophy has merit regardless of the process model that is used. ASD’s
 overall emphasis on the dynamics of self-organizing teams, interpersonal collabo
ration, and individual and team learning yield software project teams that have a
 much higher likelihood of success.
 3.5.2 Scrum
 Scrum (the name is derived from an activity that occurs during a rugby match13) is
 an agile software development method that was conceived by Jeff Sutherland and his
 development team in the early 1990s. In recent years, further development on the
 Scrum methods has been performed by Schwaber and Beedle [Sch01a].
 Scrum principles are consistent with the agile manifesto and are used to guide
 development activities within a process that incorporates the following framework
 activities: requirements, analysis, design, evolution, and delivery. Within each
 13 A group of players forms around the ball and the teammates work together (sometimes violently!)
 to move the ball downfield.
every 24
 hours
 30 days
 Scrum: 15 minute daily meeting.
 Team members respond to basics:
 1) What did you do since last Scrum
 meeting?
 2) Do you have any obstacles?
 3) What will you do before next
 meeting?
 Sprint Backlog:
 Feature(s)
 assigned
 to sprint
 Product Backlog:
 Prioritized product features desired by the customer
 Backlog
 items
 expanded
 by team
 New functionality
 is demonstrated
 at end of sprint
 framework activity, work tasks occur within a process pattern (discussed in the fol
lowing paragraph) called a sprint.The work conducted within a sprint (the number
 of sprints required for each framework activity will vary depending on product com
plexity and size) is adapted to the problem at hand and is defined and often modified
 in real time by the Scrum team. The overall flow of the Scrum process is illustrated
 in Figure 3.4.
 Scrum emphasizes the use of a set of software process patterns [Noy02] that have
 proven effective for projects with tight timelines, changing requirements, and business
 criticality. Each of these process patterns defines a set of development actions:
 Backlog—a prioritized list of project requirements or features that provide busi
ness value for the customer. Items can be added to the backlog at any time (this is
 how changes are introduced). The product manager assesses the backlog and
 updates priorities as required.
 Sprints—consist of work units that are required to achieve a requirement de
fined in the backlog that must be fit into a predefined time-box14(typically 30 days).
 CHAPTER 3 AGILE DEVELOPMENT 83
 14A time-boxis a project management term (see Part 4 of this book) that indicates a period of time
 that has been allocated to accomplish some task.
 FIGURE3.4
 Scrum process
 flow
 Scrum incorporates a
 set of process patterns
 that emphasize project
 priorities,
 compartmentalized
 work units,
 communication, and
 frequent customer
 feedback.
84
 PART ONE THE SOFTWARE PROCESS
 Changes (e.g., backlog work items) are not introduced during the sprint. Hence, the
 sprint allows team members to work in a short-term, but stable environment.
 Scrum meetings—are short (typically 15 minutes) meetings held daily by the Scrum
 team. Three key questions are asked and answered by all team members [Noy02]:
 • What did you do since the last team meeting?
 • What obstacles are you encountering?
 • What do you plan to accomplish by the next team meeting?
 A team leader, called a Scrum master, leads the meeting and assesses the responses
 from each person. The Scrum meeting helps the team to uncover potential problems
 as early as possible. Also, these daily meetings lead to “knowledge socialization”
 [Bee99] and thereby promote a self-organizing team structure.
 Demos—deliver the software increment to the customer so that functionality that
 has been implemented can be demonstrated and evaluated by the customer. It is im
portant to note that the demo may not contain all planned functionality, but rather
 those functions that can be delivered within the time-box that was established.
 Beedle and his colleagues [Bee99] present a comprehensive discussion of these pat
terns in which they state: “Scrum assumes up-front the existence of chaos. . . . ” The
 Scrum process patterns enable a software team to work successfully in a world
 where the elimination of uncertainty is impossible.
 3.5.3 Dynamic Systems Development Method (DSDM)
 WebRef
 Useful resources for
 DSSD can be found at
 www.dsdm.org.
 The Dynamic Systems Development Method (DSDM) [Sta97] is an agile software devel
opment approach that “provides a framework for building and maintaining systems
 which meet tight time constraints through the use of incremental prototyping in a con
trolled project environment” [CCS02]. The DSDM philosophy is borrowed from a mod
ified version of the Pareto principle—80 percent of an application can be delivered in
 20 percent of the time it would take to deliver the complete (100 percent) application.
 DSDM is an iterative software process in which each iteration follows the 80 per
cent rule. That is, only enough work is required for each increment to facilitate
 movement to the next increment. The remaining detail can be completed later when
 more business requirements are known or changes have been requested and
 accommodated.
 The DSDM Consortium (www.dsdm.org) is a worldwide group of member com
panies that collectively take on the role of “keeper” of the method. The consortium
 has defined an agile process model, called the DSDM life cycle that defines three dif
ferent iterative cycles, preceded by two additional life cycle activities:
 Feasibility study—establishes the basic business requirements and constraints
 associated with the application to be built and then assesses whether the applica
tion is a viable candidate for the DSDM process.
85
 CHAPTER 3 AGILE DEVELOPMENT
 DSDM is a process
 framework that can
 adopt the tactics of
 another agile approach
 such as XP.
 Crystal is a family of
 process models with
 the same “genetic
 code” but different
 methods for adapting
 to project
 characteristics.
 Business study—establishes the functional and information requirements that
 will allow the application to provide business value; also, defines the basic
 application architecture and identifies the maintainability requirements for the
 application.
 Functional model iteration—produces a set of incremental prototypes that
 demonstrate functionality for the customer. (Note: All DSDM prototypes are in
tended to evolve into the deliverable application.) The intent during this iterative
 cycle is to gather additional requirements by eliciting feedback from users as they
 exercise the prototype.
 Design and build iteration—revisits prototypes built during functional model
 iteration to ensure that each has been engineered in a manner that will enable it to
 provide operational business value for end users. In some cases, functional model
 iteration and design and build iteration occur concurrently.
 Implementation—places the latest software increment (an “operationalized” pro
totype) into the operational environment. It should be noted that (1) the increment
 may not be 100 percent complete or (2) changes may be requested as the incre
ment is put into place. In either case, DSDM development work continues by
 returning to the functional model iteration activity.
 DSDM can be combined with XP (Section 3.4) to provide a combination approach
 that defines a solid process model (the DSDM life cycle) with the nuts and bolts prac
tices (XP) that are required to build software increments. In addition, the ASD con
cepts of collaboration and self-organizing teams can be adapted to a combined
 process model.
 3.5.4 Crystal
 Alistair Cockburn [Coc05] and Jim Highsmith [Hig02b] created the Crystal family of
 agile methods15 in order to achieve a software development approach that puts a
 premium on “maneuverability” during what Cockburn characterizes as “a resource
limited, cooperative game of invention and communication, with a primary goal of
 delivering useful, working software and a secondary goal of setting up for the next
 game” [Coc02].
 To achieve maneuverability, Cockburn and Highsmith have defined a set of
 methodologies, each with core elements that are common to all, and roles, process
 patterns, work products, and practice that are unique to each. The Crystal family is
 actually a set of example agile processes that have been proven effective for differ
ent types of projects. The intent is to allow agile teams to select the member of the
 crystal family that is most appropriate for their project and environment.
 15 The name “crystal” is derived from the characteristics of geological crystals, each with its own
 color, shape, and hardness.
86
 PART ONE THE SOFTWARE PROCESS
 3.5.5 Feature Driven Development (FDD)
 WebRef
 A wide variety of
 articles and
 presentations on FDD
 can be found at:
 www.featuredrive
 ndevelopment
 .com/.
 Feature Driven Development (FDD) was originally conceived by Peter Coad and his
 colleagues [Coa99] as a practical process model for object-oriented software engi
neering. Stephen Palmer and John Felsing [Pal02] have extended and improved
 Coad’s work, describing an adaptive, agile process that can be applied to moderately
 sized and larger software projects.
 Like other agile approaches, FDD adopts a philosophy that (1) emphasizes col
laboration among people on an FDD team; (2) manages problem and project
 complexity using feature-based decomposition followed by the integration of
 software increments, and (3) communication of technical detail using verbal,
 graphical, and text-based means. FDD emphasizes software quality assurance
 activities by encouraging an incremental development strategy, the use of design
 and code inspections, the application of software quality assurance audits (Chap
ter 16), the collection of metrics, and the use of patterns (for analysis, design, and
 construction).
 In the context of FDD, a feature “is a client-valued function that can be imple
mented in two weeks or less” [Coa99]. The emphasis on the definition of features
 provides the following benefits:
 • Because features are small blocks of deliverable functionality, users can
 describe them more easily; understand how they relate to one another more
 readily; and better review them for ambiguity, error, or omissions.
 • Features can be organized into a hierarchical business-related grouping.
 • Since a feature is the FDD deliverable software increment, the team develops
 operational features every two weeks.
 • Because features are small, their design and code representations are easier
 to inspect effectively.
 • Project planning, scheduling, and tracking are driven by the feature
 hierarchy, rather than an arbitrarily adopted software engineering 
task set.
 Coad and his colleagues [Coa99] suggest the following template for defining a
 feature:
 <action> the <result> <by for of to> a(n) <object>
 where an <object> is “a person, place, or thing (including roles, moments in time or
 intervals of time, or catalog-entry-like descriptions).” Examples of features for an 
e-commerce application might be:
 Add the product to shopping cart
 Display the technical-specifications of the product
 Store the shipping-information for the customer
87
 CHAPTER 3 AGILE DEVELOPMENT
 FIGURE 3.5
 Feature Driven
 Development
 [Coa99] (with
 permission)
 Develop
 an
 Overall
 Model
 Build a
 Features
 List
 Plan
 By
 Feature
 Design
 By
 Feature
 (more shape
 than content)
 A list of features
 grouped into sets
 and subject areas
 A development plan
 Class owners
 Feature Set Owners
 A design
 package
 (sequences)
 Build
 By
 Feature
 Completed
 client-value
 function
 A feature set groups related features into business-related categories and is defined
 [Coa99] as:
 <action><-ing> a(n) <object>
 For example: Making a product sale is a feature set that would encompass the fea
tures noted earlier and others.
 The FDD approach defines five “collaborating” [Coa99] framework activities (in
 FDD these are called “processes”) as shown in Figure 3.5.
 FDD provides greater emphasis on project management guidelines and tech
niques than many other agile methods. As projects grow in size and complexity,
 ad hoc project management is often inadequate. It is essential for developers, their
 managers, and other stakeholders to understand project status—what accomplish
ments have been made and problems have been encountered. If deadline pressure
 is significant, it is critical to determine if software increments (features) are properly
 scheduled. To accomplish this, FDD defines six milestones during the design and
 implementation of a feature: “design walkthrough, design, design inspection, code,
 code inspection, promote to build” [Coa99].
 3.5.6 Lean Software Development (LSD)
 Lean Software Development (LSD) has adapted the principles of lean manufacturing
 to the world of software engineering. The lean principles that inspire the LSD process
 can be summarized ([Pop03], [Pop06a]) as eliminate waste, build quality in, create
 knowledge, defer commitment, deliver fast, respect people, and optimize the whole.
 Each of these principles can be adapted to the software process. For example,
 eliminate waste within the context of an agile software project can be interpreted
 to mean [Das05]: (1) adding no extraneous features or functions, (2) assessing the
 cost and schedule impact of any newly requested requirement, (3) removing any
 superfluous process steps, (4) establishing mechanisms to improve the way team
 members find information, (5) ensuring the testing finds as many errors as possible,
88
 PART ONE THE SOFTWARE PROCESS
 (6) reducing the time required to request and get a decision that affects the software
 or the process that is applied to create it, and (7) streamlining the manner in which
 information is transmitted to all stakeholders involved in the process.
 For a detailed discussion of LSD and pragmatic guidelines for implementing the
 process, you should examine [Pop06a] and [Pop06b].
 3.5.7 Agile Modeling (AM)
 WebRef
 Comprehensive
 information on agile
 modeling can be found
 at: www
 .agilemodeling.com.
 uote:
 “I was in the drug
 store the other day
 trying to get a cold
 medication . . . not
 easy. There’s an
 entire wall of
 products you need.
 You stand there
 going, Well, this
 one is quick acting
 but this is long
 lasting. . . . Which
 is more important,
 the present or the
 future?”
 Jerry Seinfeld
 There are many situations in which software engineers must build large, business
critical systems. The scope and complexity of such systems must be modeled so that
 (1) all constituencies can better understand what needs to be accomplished, (2) the
 problem can be partitioned effectively among the people who must solve it, and
 (3) quality can be assessed as the system is being engineered and built.
 Over the past 30 years, a wide variety of software engineering modeling methods
 and notation have been proposed for analysis and design (both architectural and
 component-level). These methods have merit, but they have proven to be difficult
 to apply and challenging to sustain (over many projects). Part of the problem is the
 “weight” of these modeling methods. By this I mean the volume of notation required,
 the degree of formalism suggested, the sheer size of the models for large projects,
 and the difficulty in maintaining the model(s) as changes occur. Yet analysis and de
sign modeling have substantial benefit for large projects—if for no other reason than
 to make these projects intellectually manageable. Is there an agile approach to soft
ware engineering modeling that might provide an alternative?
 At “The Official Agile Modeling Site,” Scott Ambler [Amb02a] describes agile mod
eling (AM) in the following manner:
 Agile Modeling (AM) is a practice-based methodology for effective modeling and documen
tation of software-based systems. Simply put, Agile Modeling (AM) is a collection of values,
 principles, and practices for modeling software that can be applied on a software develop
ment project in an effective and light-weight manner. Agile models are more effective than
 traditional models because they are just barely good, they don’t have to be perfect.
 Agile modeling adopts all of the values that are consistent with the agile manifesto.
 The agile modeling philosophy recognizes that an agile team must have the courage
 to make decisions that may cause it to reject a design and refactor. The team must
 also have the humility to recognize that technologists do not have all the answers and
 that business experts and other stakeholders should be respected and embraced.
 Although AM suggests a wide array of “core” and “supplementary” modeling prin
ciples, those that make AM unique are [Amb02a]:
 Model with a purpose. A developer who uses AM should have a specific
 goal (e.g., to communicate information to the customer or to help better un
derstand some aspect of the software) in mind before creating the model.
 Once the goal for the model is identified, the type of notation to be used and
 level of detail required will be more obvious.
89
 CHAPTER 3 AGILE DEVELOPMENT
 Use multiple models. There are many different models and notations that
 can be used to describe software. Only a small subset is essential for most
 projects. AM suggests that to provide needed insight, each model should
 present a different aspect of the system and only those models that provide
 value to their intended audience should be used.
 “Traveling light” is an
 appropriate philosophy
 for all software engi
neering work. Build
 only those models that
 provide value … no
 more, no less.
 Travel light. As software engineering work proceeds, keep only those mod
els that will provide long-term value and jettison the rest. Every work product
 that is kept must be maintained as changes occur. This represents work that
 slows the team down. Ambler [Amb02a] notes that “Every time you decide to
 keep a model you trade-off agility for the convenience of having that informa
tion available to your team in an abstract manner (hence potentially enhanc
ing communication within your team as well as with project stakeholders).”
 Content is more important than representation. Modeling should im
part information to its intended audience. A syntactically perfect model that
 imparts little useful content is not as valuable as a model with flawed nota
tion that nevertheless provides valuable content for its audience.
 Know the models and the tools you use to create them. Understand
 the strengths and weaknesses of each model and the tools that are used to
 create it.
 Adapt locally. The modeling approach should be adapted to the needs of
 the agile team.
 A major segment of the software engineering community has adopted the Unified
 Modeling Language (UML)16 as the preferred method for representing analysis and
 design models. The Unified Process (Chapter 2) has been developed to provide a
 framework for the application of UML. Scott Ambler [Amb06] has developed a sim
plified version of the UP that integrates his agile modeling philosophy.
 3.5.8 Agile Unified Process (AUP)
 The Agile Unified Process (AUP) adopts a “serial in the large” and “iterative in the
 small” [Amb06] philosophy for building computer-based systems. By adopting the
 classic UP phased activities—inception, elaboration, construction, and transition—AUP
 provides a serial overlay (i.e., a linear sequence of software engineering activities)
 that enables a team to visualize the overall process flow for a software project. How
ever, within each of the activities, the team iterates to achieve agility and to deliver
 meaningful software increments to end users as rapidly as possible. Each AUP iter
ation addresses the following activities [Amb06]: 
• Modeling. UML representations of the business and problem domains are
 created. However, to stay agile, these models should be “just barely good
 enough” [Amb06] to allow the team to proceed.
 16 A brief tutorial on UML is presented in Appendix 1.
90
 PART ONE THE SOFTWARE PROCESS
 • Implementation. Models are translated into source code.
 • Testing. Like XP, the team designs and executes a series of tests to uncover
 errors and ensure that the source code meets its requirements.
 • Deployment. Like the generic process activity discussed in Chapters 1 and 2,
 deployment in this context focuses on the delivery of a software increment
 and the acquisition of feedback from end users.
 • Configuration and project management. In the context of AUP, configuration
 management (Chapter 22) addresses change management, risk manage
ment, and the control of any persistent work products17 that are produced by
 the team. Project management tracks and controls the progress of the team
 and coordinates team activities.
 • Environment management. Environment management coordinates a process
 infrastructure that includes standards, tools, and other support technology
 available to the team.
 Although the AUP has historical and technical connections to the Unified Modeling
 Language, it is important to note that UML modeling can be using in conjunction
 with any of the agile process models described in Section 3.5.
 SOFTWARE TOOLS
 Agile Development
 Objective: The objective of agile development
 tools is to assist in one or more aspects of agile
 development with an emphasis on facilitating the rapid
 generation of operational software. These tools can also
 be used when prescriptive process models (Chapter 2) are
 applied.
 Mechanics: Tool mechanics vary. In general, agile tool
 sets encompass automated support for project planning,
 use case development and requirements gathering, rapid
 design, code generation, and testing.
 Representative Tools:18
 Note: Because agile development is a hot topic, most
 software tools vendors purport to sell tools that support 
the agile approach. The tools noted here have
 characteristics that make them particularly useful for
 agile projects.
 OnTime, developed by Axosoft (www.axosoft.com),
 provides agile process management support for
 various technical activities within the process.
 Ideogramic UML, developed by Ideogramic
 (www.ideogramic.com) is a UML tool set
 specifically developed for use within an agile 
process.
 Together Tool Set, distributed by Borland
 (www.borland.com), provides a tools suite that
 supports many technical activities within XP and other
 agile processes.
 17 A persistent work product is a model or document or test case produced by the team that will be kept
 for an indeterminate period of time. It will not be discarded once the software increment is
 delivered.
 18 Tools noted here do not represent an endorsement, but rather a sampling of tools in this category.
 In most cases, tool names are trademarked by their respective developers.
91
 CHAPTER 3 AGILE DEVELOPMENT
 3.6 A TOOL SET FOR THE AGILE PROCESS
 The “tool set” that
 supports agile
 processes focuses
 more on people issues
 than it does on
 technology issues.
 Some proponents of the agile philosophy argue that automated software tools (e.g.,
 design tools) should be viewed as a minor supplement to the team’s activities, and
 not at all pivotal to the success of the team. However, Alistair Cockburn [Coc04] sug
gests that tools can have a benefit and that “agile teams stress using tools that per
mit the rapid flow of understanding. Some of those tools are social, starting even at
 the hiring stage. Some tools are technological, helping distributed teams simulate
 being physically present. Many tools are physical, allowing people to manipulate
 them in workshops.”
 Because acquiring the right people (hiring), team collaboration, stakeholder com
munication, and indirect management are key elements in virtually all agile process
 models, Cockburn argues that “tools” that address these issues are critical success
 factors for agility. For example, a hiring “tool” might be the requirement to have a
 prospective team member spend a few hours pair programming with an existing
 member of the team. The “fit” can be assessed immediately.
 Collaborative and communication “tools” are generally low tech and incorporate
 any mechanism (“physical proximity, whiteboards, poster sheets, index cards, and
 sticky notes” [Coc04]) that provides information and coordination among agile de
velopers. Active communication is achieved via the team dynamics (e.g., pair pro
gramming), while passive communication is achieved by “information radiators”
 (e.g., a flat panel display that presents the overall status of different components of
 an increment). Project management tools deemphasize the Gantt chart and replace
 it with earned value charts or “graphs of tests created versus passed . . . other agile
 tools are used to optimize the environment in which the agile team works (e.g., more
 efficient meeting areas), improve the team culture by nurturing social interactions
 (e.g., collocated teams), physical devices (e.g., electronic whiteboards), and process
 enhancement (e.g., pair programming or time-boxing)” [Coc04].
 Are any of these things really tools? They are, if they facilitate the work performed
 by an agile team member and enhance the quality of the end product.
 3.7 SUMMARY
 In a modern economy, market conditions change rapidly, customer and end-user
 needs evolve, and new competitive threats emerge without warning. Practitioners
 must approach software engineering in a manner that allows them to remain agile—
 to define maneuverable, adaptive, lean processes that can accommodate the needs
 of modern business.
 An agile philosophy for software engineering stresses four key issues: the impor
tance of self-organizing teams that have control over the work they perform, com
munication and collaboration between team members and between practitioners
 and their customers, a recognition that change represents an opportunity, and
92
 PART ONE THE SOFTWARE PROCESS
 an emphasis on rapid delivery of software that satisfies the customer. Agile process
 models have been designed to address each of these issues.
 Extreme programming (XP) is the most widely used agile process. Organized as
 four framework activities—planning, design, coding, and testing—XP suggests a
 number of innovative and powerful techniques that allow an agile team to create
 frequent software releases that deliver features and functionality that have been de
scribed and then prioritized by stakeholders.
 Other agile process models also stress human collaboration and team self
organization, but define their own framework activities and select different points of
 emphasis. For example, ASD uses an iterative process that incorporates adaptive
 cycle planning, relatively rigorous requirement gathering methods, and an iterative
 development cycle that incorporates customer focus groups and formal technical re
views as real-time feedback mechanisms. Scrum emphasizes the use of a set of soft
ware process patterns that have proven effective for projects with tight time lines,
 changing requirements, and business criticality. Each process pattern defines a set
 of development tasks and allows the Scrum team to construct a process that is
 adapted to the needs of the project. The Dynamic Systems Development Method
 (DSDM) advocates the use of time-box scheduling and suggests that only enough
 work is required for each software increment to facilitate movement to the next
 increment. Crystal is a family of agile process models that can be adopted to the spe
cific characteristics of a project.
 Feature Driven Development (FDD) is somewhat more “formal” than other agile
 methods, but still maintains agility by focusing the project team on the development
 of features—a client-valued function that can be implemented in two weeks or less.
 Lean Software Development (LSD) has adapted the principles of lean manufacturing
 to the world of software engineering. Agile modeling (AM) suggests that modeling is
 essential for all systems, but that the complexity, type, and size of the model must be
 tuned to the software to be built. The Agile Unified Process (AUP) adopts a “serial in
 the large” and “iterative in the small” philosophy for building software.
 PROBLEMS AND POINTS TO PONDER
 3.1. Reread “The Manifesto for Agile Software Development” at the beginning of this chapter.
 Can you think of a situation in which one or more of the four “values” could get a software team
 into trouble?
 3.2. Describe agility (for software projects) in your own words.
 3.3. Why does an iterative process make it easier to manage change? Is every agile process dis
cussed in this chapter iterative? Is it possible to complete a project in just one iteration and still
 be agile? Explain your answers.
 3.4. Could each of the agile processes be described using the generic framework activities
 noted in Chapter 2? Build a table that maps the generic activities into the activities defined for
 each agile process.
 3.5. Try to come up with one more “agility principle” that would help a software engineering
 team become even more maneuverable.
93
 CHAPTER 3 AGILE DEVELOPMENT
 3.6. Select one agility principle noted in Section 3.3.1 and try to determine whether each of the
 process models presented in this chapter exhibits the principle. [Note: I have presented an
 overview of these process models only, so it may not be possible to determine whether a prin
ciple has been addressed by one or more of the models, unless you do additional research
 (which is not required for this problem).]
 3.7. Why do requirements change so much? After all, don’t people know what they want?
 3.8. Most agile process models recommend face-to-face communication. Yet today, members
 of a software team and their customers may be geographically separated from one another. Do
 you think this implies that geographical separation is something to avoid? Can you think of ways
 to overcome this problem?
 3.9. Write an XP user story that describes the “favorite places” or “bookmarks” feature avail
able on most Web browsers.
 3.10. What is a spike solution in XP?
 3.11. Describe the XP concepts of refactoring and pair programming in your own words.
 3.12. Do a bit more reading and describe what a time-box is. How does this assist an ASD team
 in delivering software increments in a short time period?
 3.13. Do the 80 percent rule in DSDM and the time-boxing approach defined for ASD achieve
 the same result?
 3.14. Using the process pattern template presented in Chapter 2, develop a process pattern for
 any one of the Scrum patterns presented in Section 3.5.2.
 3.15. Why is Crystal called a family of agile methods?
 3.16. Using the FDD feature template described in Section 3.5.5, define a feature set for a Web
 browser. Now develop a set of features for the feature set.
 3.17. Visit the Official Agile Modeling Site and make a complete list of all core and supple
mentary AM principles.
 3.18. The tool set proposed in Section 3.6 supports many of the “soft” aspects of agile meth
ods. Since communication is so important, recommend an actual tool set that might be used to
 enhance communication among stakeholders on an agile team.
 FURTHER READINGS AND INFORMATION SOURCES
 The overall philosophy and underlying principles of agile software development are considered
 in depth in many of the books referenced in the body of this chapter. In addition, books by Shaw
 and Warden (The Art of Agile Development, O’Reilly Media, Inc., 2008), Hunt (Agile Software Con
struction, Springer, 2005), and Carmichael and Haywood (Better Software Faster, Prentice-Hall,
 2002) present useful discussions of the subject. Aguanno (Managing Agile Projects, Multi
Media Publications, 2005), Highsmith (Agile Project Management: Creating Innovative Products,
 Addison-Wesley, 2004), and Larman (Agile and Iterative Development: A Manager’s Guide,
 Addison-Wesley, 2003) present a management overview and consider project management
 issues. Highsmith (Agile Software Development Ecosystems, Addison-Wesley, 2002) presents a
 survey of agile principles, processes, and practices. A worthwhile discussion of the delicate bal
ance between agility and discipline is presented by Booch and his colleagues (Balancing Agility
 and Discipline, Addison-Wesley, 2004).
 Martin (Clean Code: A Handbook of Agile Software Craftsmanship, Prentice-Hall, 2009) pres
ents the principles, patterns, and practices required to develop “clean code” in an agile software
 engineering environment. Leffingwell (Scaling Software Agility: Best Practices for Large Enter
prises, Addison-Wesley, 2007) discusses strategies for scaling up agile practices for large proj
ects. Lippert and Rook (Refactoring in Large Software Projects: Performing Complex Restructurings
 Successfully, Wiley, 2006) discuss the use of refactoring when applied in large, complex systems.
94
 PART ONE THE SOFTWARE PROCESS
 Stamelos and Sfetsos (Agile Software Development Quality Assurance, IGI Global, 2007) discuss
 SQA techniques that conform to the agile philosophy.
 Dozens of books have been written about Extreme Programming over the past decade. Beck
 (Extreme Programming Explained: Embrace Change, 2d ed., Addison-Wesley, 2004) remains the
 definitive treatment of the subject. In addition, Jeffries and his colleagues (Extreme Programming
 Installed, Addison-Wesley, 2000), Succi and Marchesi (Extreme Programming Examined,
 Addison-Wesley, 2001), Newkirk and Martin (Extreme Programming in Practice, Addison-Wesley,
 2001), and Auer and his colleagues (Extreme Programming Applied: Play to Win, Addison-Wesley,
 2001) provide a nuts-and-bolts discussion of XP along with guidance on how best to apply it.
 McBreen (Questioning Extreme Programming, Addison-Wesley, 2003) takes a critical look at XP,
 defining when and where it is appropriate. An in-depth consideration of pair programming is
 presented by McBreen (Pair Programming Illuminated, Addison-Wesley, 2003).
 ASD is addressed in depth by Highsmith [Hig00]. Schwaber (The Enterprise and Scrum,
 Microsoft Press, 2007) discusses the use of Scrum for projects that have a major business
 impact. The nuts and bolts of Scrum are discussed by Schwaber and Beedle (Agile Software
 Development with SCRUM, Prentice-Hall, 2001). Worthwhile treatments of DSDM have been
 written by the DSDM Consortium (DSDM: Business Focused Development, 2d ed., Pearson Edu
cation, 2003) and Stapleton (DSDM: The Method in Practice, Addison-Wesley, 1997). Cockburn
 (Crystal Clear, Addison-Wesley, 2005) presents an excellent overview of the Crystal family of
 processes. Palmer and Felsing [Pal02] present a detailed treatment of FDD. Carmichael and
 Haywood (Better Software Faster, Prentice-Hall, 2002) provides another useful treatment of FDD
 that includes a step-by-step journey through the mechanics of the process. Poppendieck and 
Poppendieck (Lean Development: An Agile Toolkit for Software Development Managers, Addison
Wesley, 2003) provide guidelines for managing and controlling agile projects. Ambler and
 Jeffries (Agile Modeling, Wiley, 2002) discuss AM in some depth.
 A wide variety of information sources on agile software development are available on the
 Internet. An up-to-date list of World Wide Web references that are relevant to the agile process
 can be found at the SEPA website: www.mhhe.com/engcs/compsci/pressman/
 professional/olc/ser.htm.
